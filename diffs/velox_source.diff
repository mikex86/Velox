diff --git a/src/main/java/me/mikex86/velox/chunk/ChunkLoadStatePrinter.java b/src/main/java/me/mikex86/velox/chunk/ChunkLoadStatePrinter.java
new file mode 100644
index 0000000..239ec96
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/ChunkLoadStatePrinter.java
@@ -0,0 +1,62 @@
+package me.mikex86.velox.chunk;
+
+import me.mikex86.velox.tick.region.RegionTickManager;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.*;
+
+import javax.imageio.ImageIO;
+import java.awt.*;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * A debug utility to print chunk load states onto an image saved in the folder "chunks_states".
+ */
+public class ChunkLoadStatePrinter {
+
+    public static void printChunkLoadState(RegionTickManager manager, Chunk currentlyUnloading) {
+        int xStart = -2000, zStart = -2000;
+        int xEnd = 2000, zEnd = 2000;
+        BufferedImage image = new BufferedImage(xEnd - xStart, zEnd - zStart, BufferedImage.TYPE_4BYTE_ABGR);
+        for (int x = xStart; x < xEnd; x++) {
+            for (int z = zStart; z < zEnd; z++) {
+
+                int rgb;
+                ChunkPos pos = currentlyUnloading != null ? currentlyUnloading.getPos() : null;
+                if (pos != null && pos.x == x && pos.z == z) {
+                    rgb = Color.MAGENTA.getRGB();
+                } else {
+                    Chunk chunk = manager.getChunk(x, z);
+                    if (chunk == null) {
+                        rgb = Color.BLACK.getRGB();
+                    } else {
+                        boolean loaded = chunk.loaded;
+                        if (loaded)
+                            rgb = Color.GREEN.getRGB();
+                        else
+                            rgb = Color.RED.getRGB();
+                    }
+                }
+                image.setRGB(x - xStart, z - zStart, rgb);
+            }
+        }
+        try {
+            ImageIO.write(image, "PNG", getNextFile());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static File getNextFile() {
+        File file;
+        int counter = 0;
+        do {
+            file = new File("chunk_states/state_" + counter + ".png");
+            file.getParentFile().mkdirs();
+            counter++;
+        } while (file.exists());
+        return file;
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/chunk/ConcurrentChunkProvider.java b/src/main/java/me/mikex86/velox/chunk/ConcurrentChunkProvider.java
new file mode 100644
index 0000000..78fdffc
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/ConcurrentChunkProvider.java
@@ -0,0 +1,45 @@
+package me.mikex86.velox.chunk;
+
+import java.util.concurrent.Executor;
+import java.util.function.Supplier;
+
+import me.mikex86.velox.chunk.cache.IChunkCache;
+import me.mikex86.velox.chunk.cache.ChunkCache;
+import net.minecraft.world.server.ServerChunkProvider;
+import net.minecraft.world.server.ServerWorld;
+
+import com.mojang.datafixers.DataFixer;
+
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.IChunk;
+import net.minecraft.world.chunk.listener.IChunkStatusListener;
+import net.minecraft.world.gen.ChunkGenerator;
+import net.minecraft.world.gen.feature.template.TemplateManager;
+import net.minecraft.world.storage.DimensionSavedDataManager;
+
+import net.minecraft.world.storage.SaveFormat.LevelSave;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class ConcurrentChunkProvider extends ServerChunkProvider {
+
+    @NotNull
+    private final IChunkCache chunkCache = new ChunkCache(key -> super.fallbackLookup(key.getChunkX(), key.getChunkZ(), key.getStatusIndex(), key.shouldLoad()));
+
+    public ConcurrentChunkProvider(ServerWorld worldIn, LevelSave worldDirectory, DataFixer dataFixer,
+                                   TemplateManager templateManagerIn, Executor executorIn, ChunkGenerator chunkGeneratorIn, int viewDistance,
+                                   boolean spawnHostiles, IChunkStatusListener p_i51537_8_, Supplier<DimensionSavedDataManager> p_i51537_9_) {
+        super(worldIn, worldDirectory, dataFixer, templateManagerIn, executorIn, chunkGeneratorIn, viewDistance, spawnHostiles, p_i51537_8_, p_i51537_9_);
+    }
+
+    @Override
+    protected void clearCache() {
+        // Invoked after every tick. Do nothing here...
+    }
+
+    @Nullable
+    @Override
+    protected IChunk getChunk(long packedChunkPos, @NotNull ChunkStatus requiredStatus, boolean load) {
+        return this.chunkCache.getChunk(packedChunkPos, requiredStatus, load);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/chunk/cache/ChunkCache.java b/src/main/java/me/mikex86/velox/chunk/cache/ChunkCache.java
new file mode 100644
index 0000000..56f4f8d
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/cache/ChunkCache.java
@@ -0,0 +1,88 @@
+package me.mikex86.velox.chunk.cache;
+
+import com.github.benmanes.caffeine.cache.Caffeine;
+import com.github.benmanes.caffeine.cache.LoadingCache;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.IChunk;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
+
+public class ChunkCache implements IChunkCache {
+
+    @NotNull
+    private final LoadingCache<ChunkLookupKey, IChunk> cache;
+
+    public ChunkCache(@NotNull Function<@NotNull ChunkLookupKey, IChunk> cacheBuildFunction) {
+        // TODO: MAKE CONFIGURABLE
+        this.cache = Caffeine.newBuilder()
+                .maximumSize(10_000)
+                .expireAfterWrite(5, TimeUnit.MINUTES)
+                .build(cacheBuildFunction::apply);
+    }
+
+    @Override
+    @Nullable
+    public IChunk getChunk(long packedChunkPos, ChunkStatus requiredStatus, boolean load) {
+        return this.cache.get(new ChunkLookupKey(packedChunkPos, requiredStatus, load));
+    }
+
+    public static class ChunkLookupKey {
+
+        private final long key;
+        private final int chunkX, chunkZ;
+        private final ChunkStatus statusIndex;
+        private final boolean load;
+
+        public ChunkLookupKey(long key, ChunkStatus statusIndex, boolean load) {
+            this.key = key;
+            this.chunkX = ChunkPos.getX(key);
+            this.chunkZ = ChunkPos.getZ(key);
+            this.statusIndex = statusIndex;
+            this.load = load;
+        }
+
+        public int getChunkX() {
+            return chunkX;
+        }
+
+        public int getChunkZ() {
+            return chunkZ;
+        }
+
+        public ChunkStatus getStatusIndex() {
+            return statusIndex;
+        }
+
+        public boolean shouldLoad() {
+            return load;
+        }
+
+        public static ChunkLookupKey of(int chunkX, int chunkZ, ChunkStatus requiredChunkStatus, boolean load) {
+            return new ChunkLookupKey(ChunkPos.asLong(chunkX, chunkZ), requiredChunkStatus, load);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            ChunkLookupKey that = (ChunkLookupKey) o;
+
+            if (key != that.key) return false;
+            if (statusIndex != that.statusIndex) return false;
+            return load == that.load;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = (int) (key ^ (key >>> 32));
+            result = 31 * result + statusIndex.getIndex();
+            result = 31 * result + (load ? 1 : 0);
+            return result;
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/chunk/cache/IChunkCache.java b/src/main/java/me/mikex86/velox/chunk/cache/IChunkCache.java
new file mode 100644
index 0000000..f5571ec
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/cache/IChunkCache.java
@@ -0,0 +1,13 @@
+package me.mikex86.velox.chunk.cache;
+
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.IChunk;
+import org.jetbrains.annotations.Nullable;
+
+public interface IChunkCache {
+
+    @Nullable
+    IChunk getChunk(long packedChunkPos, ChunkStatus requiredStatus, boolean load);
+
+
+}
diff --git a/src/main/java/me/mikex86/velox/optimizedtnt/ExplosionDistanceMap.java b/src/main/java/me/mikex86/velox/optimizedtnt/ExplosionDistanceMap.java
new file mode 100644
index 0000000..b73469b
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/optimizedtnt/ExplosionDistanceMap.java
@@ -0,0 +1,52 @@
+package me.mikex86.velox.optimizedtnt;
+
+import me.mikex86.velox.utils.MathUtils;
+
+import java.util.Arrays;
+
+public class ExplosionDistanceMap {
+
+    private static final int distanceMapResolution = 8;
+    private static final int distanceMapResolutionSquared = distanceMapResolution * distanceMapResolution;
+    private static final int distanceMapLength = distanceMapResolution * distanceMapResolution * distanceMapResolution;
+    private static final double[] preBakedDistanceMap = new double[distanceMapLength];
+
+    static {
+        initializeDistanceMap();
+    }
+
+    private static void initializeDistanceMap() {
+        Arrays.fill(preBakedDistanceMap, 0.0); // Clear distance map
+
+        // Populate distance map with unit distance [0, 1) values
+        for (int x = 0; x < distanceMapResolution; x++) {
+            for (int y = 0; y < distanceMapResolution; y++) {
+                for (int z = 0; z < distanceMapResolution; z++) {
+                    double xUnitOffset = x / (double) distanceMapResolution;
+                    double yUnitOffset = y / (double) distanceMapResolution;
+                    double zUnitOffset = z / (double) distanceMapResolution;
+                    double unitDistance = Math.sqrt((xUnitOffset * xUnitOffset) + (yUnitOffset * yUnitOffset) + (zUnitOffset * zUnitOffset));
+                    int index = distanceMapIndex(x, y, z);
+                    preBakedDistanceMap[index] = unitDistance;
+                }
+            }
+        }
+    }
+
+    public static double getDistance(int x, int y, int z) {
+        x = MathUtils.clamp(x, 0, distanceMapResolution - 1);
+        y = MathUtils.clamp(y, 0, distanceMapResolution - 1);
+        z = MathUtils.clamp(z, 0, distanceMapResolution - 1);
+        int index = distanceMapIndex(x, y, z);
+        return preBakedDistanceMap[index];
+    }
+
+    public static int getDistanceMapResolution() {
+        return distanceMapResolution;
+    }
+
+    private static int distanceMapIndex(int x, int y, int z) {
+        return x + y * distanceMapResolution + z * distanceMapResolutionSquared;
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/optimizedtnt/OptimizedExplosion.java b/src/main/java/me/mikex86/velox/optimizedtnt/OptimizedExplosion.java
new file mode 100644
index 0000000..4186891
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/optimizedtnt/OptimizedExplosion.java
@@ -0,0 +1,100 @@
+package me.mikex86.velox.optimizedtnt;
+
+import com.google.common.collect.Sets;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockState;
+import net.minecraft.block.Blocks;
+import net.minecraft.block.TNTBlock;
+import net.minecraft.entity.item.TNTEntity;
+import net.minecraft.fluid.FluidState;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+import java.util.Set;
+
+public class OptimizedExplosion {
+
+    public static Set<BlockPos> getExplodedBlockPositions(World world, double x, double y, double z, float radius) {
+        Set<BlockPos> explodedBlockPositions = Sets.newHashSet();
+
+        int distanceMapRes = ExplosionDistanceMap.getDistanceMapResolution();
+        for (int xo = 0; xo < distanceMapRes; xo++) {
+            for (int yo = 0; yo < distanceMapRes; yo++) {
+                for (int zo = 0; zo < distanceMapRes; zo++) {
+                    double unitDistance = ExplosionDistanceMap.getDistance(xo, yo, zo);
+                    if (unitDistance < 1) {
+                        double randomScale = (0.8 + world.random.nextDouble() * 0.2);
+                        double radiusScaledXOffset = (xo / (double) distanceMapRes) * radius * randomScale;
+                        double radiusScaledYOffset = (yo / (double) distanceMapRes) * radius * randomScale;
+                        double radiusScaledZOffset = (zo / (double) distanceMapRes) * radius * randomScale;
+                        BlockPos pos;
+
+                        // Repeat the explosion in all octants
+
+                        // y up
+                        pos = new BlockPos(x + radiusScaledXOffset, y + radiusScaledYOffset, z + radiusScaledZOffset);
+                        explodedBlockPositions.add(pos);
+
+                        pos = new BlockPos(x + radiusScaledXOffset, y + radiusScaledYOffset, z - radiusScaledZOffset);
+                        explodedBlockPositions.add(pos);
+
+                        pos = new BlockPos(x - radiusScaledXOffset, y + radiusScaledYOffset, z + radiusScaledZOffset);
+                        explodedBlockPositions.add(pos);
+
+                        pos = new BlockPos(x - radiusScaledXOffset, y + radiusScaledYOffset, z - radiusScaledZOffset);
+                        explodedBlockPositions.add(pos);
+
+                        // y down
+                        pos = new BlockPos(x + radiusScaledXOffset, y - radiusScaledYOffset, z + radiusScaledZOffset);
+                        explodedBlockPositions.add(pos);
+
+                        pos = new BlockPos(x + radiusScaledXOffset, y - radiusScaledYOffset, z - radiusScaledZOffset);
+                        explodedBlockPositions.add(pos);
+
+                        pos = new BlockPos(x - radiusScaledXOffset, y - radiusScaledYOffset, z + radiusScaledZOffset);
+                        explodedBlockPositions.add(pos);
+
+                        pos = new BlockPos(x - radiusScaledXOffset, y - radiusScaledYOffset, z - radiusScaledZOffset);
+                        explodedBlockPositions.add(pos);
+                    }
+                }
+            }
+        }
+        return explodedBlockPositions;
+    }
+
+    private static float getBlockExplosionResistance(BlockState blockstate, FluidState fluidstate) {
+        if (blockstate.isAir() && fluidstate.isEmpty())
+            return -1;
+        return Math.max(blockstate.getBlock().getExplosionResistance(), fluidstate.getExplosionResistance());
+    }
+
+
+    public static void explode(World world, Set<BlockPos> toExplode) {
+        for (BlockPos pos : toExplode) {
+            explodeBlock(world, pos);
+        }
+    }
+
+    private static void explodeBlock(World world, BlockPos blockPos) {
+        BlockState blockstate = world.getBlockState(blockPos);
+        Block block = blockstate.getBlock();
+        if (!blockstate.isAir()) {
+            world.setBlock(blockPos, Blocks.AIR.defaultBlockState(), 3);
+            onBlockExplosion(block, world, blockPos);
+        }
+    }
+
+    private static void onBlockExplosion(Block block, World world, BlockPos blockPos) {
+        if (block instanceof TNTBlock) {
+            // a tnt entity when exploding away a tnt entity
+            TNTEntity tntentity = new TNTEntity(world, (double) blockPos.getX() + 0.5D, (double) blockPos.getY(), (double) blockPos.getZ() + 0.5D, null);
+            tntentity.setFuse((short) (world.random.nextInt(tntentity.getLife() / 4) + tntentity.getLife() / 8));
+            world.addFreshEntity(tntentity);
+        } else {
+            // other block implementations do not use the explosion parameter, therefore we can leave it null.
+            // UPDATE_CAUTION: Check if new blocks access the explosion parameter in Block#wasExploded
+            block.wasExploded(world, blockPos, null);
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/optimizedtnt/OptimizedTnt.java b/src/main/java/me/mikex86/velox/optimizedtnt/OptimizedTnt.java
new file mode 100644
index 0000000..fe33bad
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/optimizedtnt/OptimizedTnt.java
@@ -0,0 +1,157 @@
+package me.mikex86.velox.optimizedtnt;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import me.mikex86.velox.utils.Streamer;
+import me.mikex86.velox.utils.threading.ThreadingUtil;
+import net.minecraft.enchantment.ProtectionEnchantment;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.LivingEntity;
+import net.minecraft.entity.item.TNTEntity;
+import net.minecraft.entity.player.PlayerEntity;
+import net.minecraft.entity.player.ServerPlayerEntity;
+import net.minecraft.network.play.server.SExplosionPacket;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.vector.Vector3d;
+import net.minecraft.world.Explosion;
+import net.minecraft.world.World;
+import net.minecraft.world.server.ServerWorld;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.stream.Collectors;
+
+public class OptimizedTnt {
+
+    // TODO: MAKE CONFIGURABLE
+    private static final int nThreads = Runtime.getRuntime().availableProcessors();
+
+    @NotNull
+    private static final ExecutorService service = ThreadingUtil.newWorkerPool("TntPool", nThreads, null);
+
+    public static void performExplosions(Collection<Entity> allEntities) {
+
+        // Compute all TNT entities to tick
+        Collection<TNTEntity> tntEntities = allEntities.parallelStream().filter(e -> e instanceof TNTEntity).map(e -> (TNTEntity) e).collect(Collectors.toList());
+
+        try {
+            // Tick TNT entities. (Performs movement + sets TNTEntity#exploded)
+            Streamer.streamBatched(service, nThreads, tntEntities, TNTEntity::tick);
+        } catch (InterruptedException | ExecutionException e) {
+            e.printStackTrace();
+        }
+
+        // Compute all TNT entities that exploded during this tick
+        Collection<TNTEntity> exploded = tntEntities.parallelStream().filter(e -> e.exploded).collect(Collectors.toList());
+
+        // Compute block positions to explode in their respective worlds
+        Map<World, Set<BlockPos>> explodedBlockWorldMap = Collections.synchronizedMap(Maps.newHashMap());
+        try {
+            Streamer.streamBatched(service, nThreads, exploded,
+                    tntEntity -> {
+                        World world = tntEntity.level;
+                        Set<BlockPos> toExplode = explodedBlockWorldMap.get(world);
+                        if (toExplode == null) {
+                            toExplode = Sets.newConcurrentHashSet();
+                            explodedBlockWorldMap.put(world, toExplode);
+                        }
+                        toExplode.addAll(getTNTExplodedBlockPositions(tntEntity));
+                    }
+            );
+        } catch (InterruptedException | ExecutionException e) {
+            e.printStackTrace();
+        }
+
+        // Damage entities
+        Map<PlayerEntity, Vector3d> hitPlayers = performTntEntityDamage(exploded);
+
+        // Send explosion packets
+        if (!exploded.isEmpty()) {
+            for (TNTEntity tntEntity : exploded) {
+                List<ServerPlayerEntity> nearbyPlayers = ((ServerWorld) tntEntity.level).getPlayers(player -> player.distanceToSqr(tntEntity) < 4096);
+                for (ServerPlayerEntity nearbyPlayer : nearbyPlayers) {
+                    // send an empty block list because the blocks are updated via a multi block change packet anyways... WTF MOJANG?
+                    nearbyPlayer.connection.send(new SExplosionPacket(tntEntity.getX(), tntEntity.getY(), tntEntity.getZ(), 4F, Lists.newArrayList(), hitPlayers.get(nearbyPlayer)));
+                }
+            }
+        }
+
+        // Break blocks to explode, spawns tnt entities when exploding a tnt block, tntEntities is now outdated
+        for (Map.Entry<World, Set<BlockPos>> worldSetEntry : explodedBlockWorldMap.entrySet()) {
+            ServerWorld world = (ServerWorld) worldSetEntry.getKey();
+            Set<BlockPos> toExplode = worldSetEntry.getValue();
+            OptimizedExplosion.explode(world, toExplode);
+        }
+    }
+
+    private static Map<PlayerEntity, Vector3d> performTntEntityDamage(Collection<TNTEntity> exploded) {
+        Map<PlayerEntity, Vector3d> hitPlayers = Maps.newConcurrentMap();
+        for (TNTEntity tntEntity : exploded) {
+            try {
+                Streamer.streamBatched(service, nThreads, exploded, entity -> hitPlayers.putAll(performTntEntityDamage(tntEntity)));
+            } catch (InterruptedException | ExecutionException e) {
+                e.printStackTrace();
+            }
+        }
+        return hitPlayers;
+    }
+
+    private static Map<PlayerEntity, Vector3d> performTntEntityDamage(TNTEntity tntEntity) {
+        Map<PlayerEntity, Vector3d> hitPlayers = Maps.newHashMap();
+        float radius = 4.0F;
+        float f2 = radius * 2.0F;
+        int k1 = MathHelper.floor(tntEntity.getX() - (double) f2 - 1.0D);
+        int l1 = MathHelper.floor(tntEntity.getX() + (double) f2 + 1.0D);
+        int i2 = MathHelper.floor(tntEntity.getY() - (double) f2 - 1.0D);
+        int i1 = MathHelper.floor(tntEntity.getY() + (double) f2 + 1.0D);
+        int j2 = MathHelper.floor(tntEntity.getZ() - (double) f2 - 1.0D);
+        int j1 = MathHelper.floor(tntEntity.getZ() + (double) f2 + 1.0D);
+
+        List<Entity> entities = tntEntity.level.getEntities(tntEntity, new AxisAlignedBB(k1, i2, j2, l1, i1, j1));
+        Vector3d vector3d = new Vector3d(tntEntity.getX(), tntEntity.getY(), tntEntity.getZ());
+
+        for (int k2 = 0; k2 < entities.size(); ++k2) {
+            Entity entity = entities.get(k2);
+            if (!entity.ignoreExplosion()) {
+                double d12 = (double) (MathHelper.sqrt(entity.distanceToSqr(vector3d)) / f2);
+                if (d12 <= 1.0D) {
+                    double d5 = entity.getX() - tntEntity.getX();
+                    double d7 = (entity instanceof TNTEntity ? entity.getY() : entity.getEyeY()) - tntEntity.getY();
+                    double d9 = entity.getZ() - tntEntity.getZ();
+                    double d13 = (double) MathHelper.sqrt(d5 * d5 + d7 * d7 + d9 * d9);
+                    if (d13 != 0.0D) {
+                        d5 = d5 / d13;
+                        d7 = d7 / d13;
+                        d9 = d9 / d13;
+                        // Don't use expensive getSeenPercent (performs raytracing) when the entity to check is another TNT entity. Doesn't make any sense. We just need to explode it.
+                        double d14 = (d12 / 100);
+                        double d10 = (1.0D - d12) * d14;
+//                        entity.hurt(DamageSource.explosion(tntEntity.getOwner()), (float) ((int) ((d10 * d10 + d10) / 2.0D * 7.0D * (double) f2 + 1.0D)));
+                        double d11 = d10;
+                        if (entity instanceof LivingEntity) {
+                            d11 = ProtectionEnchantment.getExplosionKnockbackAfterDampener((LivingEntity) entity, d10);
+                        }
+
+                        entity.setDeltaMovement(entity.getDeltaMovement().add(d5 * d11, d7 * d11, d9 * d11));
+                        if (entity instanceof PlayerEntity) {
+                            PlayerEntity playerentity = (PlayerEntity) entity;
+                            if (!playerentity.isSpectator() && (!playerentity.isCreative() || !playerentity.abilities.flying)) {
+                                hitPlayers.put(playerentity, new Vector3d(d5 * d10, d7 * d10, d9 * d10));
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        return hitPlayers;
+    }
+
+    private static Set<BlockPos> getTNTExplodedBlockPositions(TNTEntity entity) {
+        return OptimizedExplosion.getExplodedBlockPositions(entity.level, entity.getX(), entity.getY(0.0625D), entity.getZ(), 4.0F);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/debug/MadMaxTickManager.java b/src/main/java/me/mikex86/velox/tick/debug/MadMaxTickManager.java
new file mode 100644
index 0000000..0cd9673
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/debug/MadMaxTickManager.java
@@ -0,0 +1,46 @@
+package me.mikex86.velox.tick.debug;
+
+import me.mikex86.velox.utils.CollectionUtils;
+import me.mikex86.velox.utils.Streamer;
+import net.minecraft.entity.Entity;
+
+import java.util.Collection;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+import java.util.function.Consumer;
+
+/**
+ * A tick model that provokes thread safety errors by just streaming all entities in optimal batch sizes on all cores.
+ * This is horrendously unsafe
+ */
+public class MadMaxTickManager {
+
+    /**
+     * Whether mad max mode is enabled
+     * Debug/Development feature only.
+     */
+    public static boolean MAD_MAX_MODE = false;
+
+    private static final int nThreads = Runtime.getRuntime().availableProcessors();
+    private static final ExecutorService service = MAD_MAX_MODE ? Executors.newFixedThreadPool(nThreads, new ThreadFactory() {
+        private int nThreads = 0;
+        @Override
+        public Thread newThread(Runnable runnable) {
+            Thread thread = new Thread(runnable, "MadMaxTickWorker-" + nThreads++);
+            thread.setDaemon(true);
+            return thread;
+        }
+    }) : null;
+
+    public static void tickMadMax(Collection<Entity> entities, Consumer<Entity> action) {
+        // TODO: IMPLEMENT TickRegionManager ENTITY REGION TASKS
+        entities = CollectionUtils.immutableCopy(entities);
+        try {
+            Streamer.streamBatched(service, nThreads, entities, action);
+        } catch (InterruptedException | ExecutionException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/global/WorldTickManager.java b/src/main/java/me/mikex86/velox/tick/global/WorldTickManager.java
new file mode 100644
index 0000000..ea56b99
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/global/WorldTickManager.java
@@ -0,0 +1,122 @@
+package me.mikex86.velox.tick.global;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import me.mikex86.velox.tick.region.RegionTickManager;
+import me.mikex86.veloxapi.game.GameTick;
+import me.mikex86.veloxapi.threading.WorldThreadGuard;
+import net.minecraft.world.World;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Queue;
+import java.util.function.Supplier;
+
+/**
+ * Grants global synchronized access without concurrent interference to the global state of a world.
+ * Allows for the execution of tasks in that context.
+ */
+public class WorldTickManager {
+
+    private static final Map<Integer, Queue<Runnable>> worldTaskMap = Maps.newConcurrentMap();
+    private static final Map<Integer, Optional<Thread>> threadAccessMap = Maps.newConcurrentMap();
+    private static final Map<Integer, RegionTickManager> tickRegionManagers = Maps.newConcurrentMap();
+
+    public static void addTickRegionManager(@NotNull World world, @NotNull RegionTickManager regionTickManager) {
+        tickRegionManagers.put(world.getWorldId(), regionTickManager);
+    }
+
+    public static synchronized Queue<Runnable> getTaskQueue(int worldId) {
+        Queue<Runnable> tasks = worldTaskMap.get(worldId);
+        if (tasks == null) {
+            tasks = Queues.newConcurrentLinkedQueue();
+            worldTaskMap.put(worldId, tasks);
+        }
+        return tasks;
+    }
+
+    public static void runGlobalTask(World world, Runnable task) {
+        getTaskQueue(world.getWorldId()).add(task);
+    }
+
+    public static void runGlobalTask(WorldThreadGuard<? extends World> world, Runnable task) {
+        getTaskQueue(world.getWorldId()).add(task);
+    }
+
+    private static void grantCurrentThreadAccess(World world) {
+        int worldId = world.getWorldId();
+        threadAccessMap.put(worldId, Optional.of(Thread.currentThread()));
+    }
+
+    private static void revokeThreadAccess(World world) {
+        int worldId = world.getWorldId();
+        threadAccessMap.put(worldId, Optional.empty());
+    }
+
+    public static void runTasks(World world) {
+        int worldId = world.getWorldId();
+
+        grantCurrentThreadAccess(world);
+        Queue<Runnable> taskQueue = getTaskQueue(worldId);
+        Iterator<Runnable> iterator = taskQueue.iterator();
+        while (iterator.hasNext()) {
+            Runnable runnable = iterator.next();
+            runnable.run();
+            if (runnable instanceof RepeatingTaskRunnable<?> && !((RepeatingTaskRunnable<?>) runnable).getRepeatingTask().isCancelled()) {
+                continue; // do not remove if the runnable is a repeating task and it is not cancelled
+            }
+            iterator.remove();
+        }
+        revokeThreadAccess(world);
+    }
+
+    public static boolean hasThreadGlobalMutationAccess(@NotNull WorldThreadGuard<? extends World> world, @NotNull Thread thread) {
+        return threadAccessMap.get(world.getWorldId()).orElse(null) == thread;
+    }
+
+    @Nullable
+    public static RegionTickManager getWorldRegionTickManager(int worldId) {
+        return tickRegionManagers.get(worldId);
+    }
+
+
+    public static void scheduleRepeatingTask(@NotNull World world, @NotNull GameTick.RepeatingTask<World> repeatingTask) {
+        runGlobalTask(world, RepeatingTaskRunnable.make(repeatingTask, () -> world));
+    }
+
+    public static void scheduleRepeatingTask(@NotNull WorldThreadGuard<? extends World> world, @NotNull GameTick.RepeatingTask<World> repeatingTask) {
+        runGlobalTask(world, RepeatingTaskRunnable.make(repeatingTask, world::getValue));
+    }
+
+    private static class RepeatingTaskRunnable<T> implements Runnable {
+
+        @NotNull
+        private final GameTick.RepeatingTask<T> repeatingTask;
+
+        @NotNull
+        private final Supplier<T> parameterValueSupplier;
+
+        private RepeatingTaskRunnable(@NotNull GameTick.RepeatingTask<T> repeatingTask, @NotNull Supplier<T> parameterValueSupplier) {
+            this.repeatingTask = repeatingTask;
+            this.parameterValueSupplier = parameterValueSupplier;
+        }
+
+        @Override
+        public void run() {
+            this.repeatingTask.accept(this.parameterValueSupplier.get());
+        }
+
+        @NotNull
+        public static <T> RepeatingTaskRunnable<T> make(@NotNull GameTick.RepeatingTask<T> repeatingTask, @NotNull Supplier<T> parameterValueSupplier) {
+            return new RepeatingTaskRunnable<>(repeatingTask, parameterValueSupplier);
+        }
+
+        @NotNull
+        public GameTick.RepeatingTask<T> getRepeatingTask() {
+            return repeatingTask;
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/region/RegionTickManager.java b/src/main/java/me/mikex86/velox/tick/region/RegionTickManager.java
new file mode 100644
index 0000000..8edaf7c
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/region/RegionTickManager.java
@@ -0,0 +1,562 @@
+package me.mikex86.velox.tick.region;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import me.mikex86.velox.tick.global.WorldTickManager;
+import me.mikex86.velox.tick.ticklist.entity.EntityTickList;
+import me.mikex86.velox.utils.CollectionUtils;
+import me.mikex86.veloxapi.game.GameTick;
+import me.mikex86.veloxapi.region.Region;
+import me.mikex86.veloxapi.threading.EntityThreadGuard;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.server.ChunkManager;
+import net.minecraft.world.server.ServerChunkProvider;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+/**
+ * Creates and destroys regions when chunks are loaded/unloaded.
+ * <p>
+ * Delegates tick list building and the scheduling of tasks on those tick lists to the individual regions.
+ */
+public class RegionTickManager {
+
+    private static final int nThreads = Runtime.getRuntime().availableProcessors();
+
+    // TODO: This is only static because multiple TickRegionManager instances can exist that should not have a service on their own claiming every core
+    // TODO: Config options
+    private static final ExecutorService service = new ThreadPoolExecutor(nThreads, nThreads,
+            0L, TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<>(),
+            new ThreadFactory() {
+
+                private int nThreads = 0;
+
+                @Override
+                public Thread newThread(Runnable runnable) {
+                    Thread thread = new Thread(runnable, "TickWorker-" + nThreads);
+                    thread.setDaemon(true);
+                    nThreads++;
+                    return thread;
+                }
+            });
+
+    /**
+     * List containing all existing regions
+     */
+    private final List<TickRegion> regionList = Lists.newArrayList();
+
+    /**
+     * Maps the position of chunks to the TickRegion they are part of
+     */
+    private final Map<ChunkPos, TickRegion> tickRegionMap = Maps.newConcurrentMap();
+
+    /**
+     * A lock to ensure thread safe access to the TickRegionManager state
+     */
+    private final ReadWriteLock lock = new ReentrantReadWriteLock();
+
+    /**
+     * A queue for all entity tick tasks that should be executed in the respective regions
+     */
+    private final Queue<EntityTaskPair> entityInRegionTasks = Queues.newLinkedBlockingQueue();
+
+    /**
+     * The world the RegionTickManager is parent to
+     */
+    private final World world;
+
+    public RegionTickManager(World world) {
+        this.world = world;
+    }
+
+    /**
+     * Invoked when a chunk is either loaded or unloaded.
+     * The method will rebuild regions accordingly.
+     *
+     * @param chunk        the chunk that is getting loaded/unloaded
+     * @param newLoadState the new load state of the chunk. true, if the chunk is getting loaded, false if the chunk is getting unloaded.
+     */
+    public void informChunkLoadStateChange(Chunk chunk, boolean newLoadState) {
+        long start = System.currentTimeMillis();
+        this.lock.writeLock().lock();
+        try {
+            TickRegion chunkDstRegion = this.findRegion(chunk);
+            if (chunkDstRegion == null) {
+                chunkDstRegion = createRegion();
+            }
+            if (newLoadState) {
+                boolean modified = addChunkToRegion(chunkDstRegion, chunk);
+                if (!modified) {
+                    System.err.println("Chunk was already contained in it's region before it was even loaded. This should never happen");
+                }
+                // Merge bordering regions:
+                // Checks if "chunk" borders any region that is not its current region.
+                // Removes the other region after adding its
+                // chunks to the region of "chunk"
+                for (Iterator<TickRegion> iterator = this.regionList.iterator(); iterator.hasNext(); ) {
+                    TickRegion region = iterator.next();
+                    if (region == chunkDstRegion) continue;
+                    if (region.containsOrBorders(chunk)) {
+                        mergeRegion(chunkDstRegion, region);
+                        iterator.remove();
+                    }
+                }
+            } else {
+                boolean modified = chunkDstRegion.removeChunk(chunk);
+                if (!modified) {
+                    System.err.println("Chunk was never contained in it's region. This should never happen");
+                }
+                if (chunkDstRegion.isEmpty()) {
+                    removeRegion(chunkDstRegion);
+                } else {
+                    checkRegionSplit(chunkDstRegion, chunk);
+                }
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+        long end = System.currentTimeMillis();
+//        System.out.println("informChunkLoadStateChange(" + newLoadState + ") took: " + (end - start) + " ms; TickRegionManager: " + this);
+    }
+
+    // not thread safe
+    private void checkRegionSplit(TickRegion region, Chunk unloadedChunk) {
+        ChunkManager chunkManager = ((ServerChunkProvider) unloadedChunk.getLevel().getChunkSource()).chunkMap;
+        // Split the region if it is not continuous.
+        // Check for non continuity by checking if you can travel between
+        // the neighboring chunks of the chunk that has just been unloaded.
+        // We will create max. 4 regions in the worst case.
+
+        Collection<Chunk> allChunks = region.getChunks();
+
+        List<Chunk> neighbors = Lists.newArrayListWithCapacity(4);
+        region.getNeighbors(true, neighbors, Lists.newArrayList(), unloadedChunk);
+
+        assert neighbors.size() == 4;
+
+        for (int i = 0; i < neighbors.size() - 1; i++) {
+            Chunk neighbor1 = neighbors.get(i);
+            Chunk neighbor2 = neighbors.get(i + 1);
+            if (neighbor1 == null || neighbor2 == null)
+                continue;
+            List<Chunk> chunks = region.floodFillFromChunkUntilChunk(neighbor1, neighbor2);
+            Chunk lastChunk = chunks.get(chunks.size() - 1);
+            if (lastChunk != neighbor2) {
+                // we have not reached the neighboring chunk, the neighbors are in different regions
+                // if that is the case, "chunks" contains all chunks part of that region, because the flood fill didn't early stop.
+                if (!chunks.equals(allChunks)) {
+
+                    // Create new region with just the "chunks" list.
+                    // "chunks" may contain chunks that are pending unload.
+                    // In the worst case scenario, they are all pending unload, eg. on teleport.
+                    // In that case chunks will unload in basically random order resulting in catastrophically
+                    // high region complexity for the short time until those regions are deleted.
+                    // In that case, we don't want to even create a region, thus the initial null value of "newRegion".
+
+                    TickRegion newRegion = null;
+                    for (Chunk chunk : chunks) {
+                        if (chunkManager.pendingUnloads.containsKey(chunk.getPos().toLong())) {
+                            // Don't add this chunk to the new region, it is pending unload.
+                            // We are not yet removing it from the old region: When the chunk
+                            // is actually unloaded, #informChunkLoadStateChange will be invoked anyways.
+                            // Ticks might still be performed in those chunks. If we were to remove these from the region now,
+                            // these ticks could simply not be performed.
+                            continue;
+                        }
+                        // Create the region only then, when we know that at least one
+                        // chunk actually gets added to it.
+                        if (newRegion == null) {
+                            newRegion = createRegion();
+                        }
+                        newRegion.addChunk(chunk);
+                        region.removeChunk(chunk);
+                        if (region.isEmpty()) {
+                            removeRegion(region);
+                        }
+                        this.tickRegionMap.put(chunk.getPos(), newRegion);
+                    }
+                }
+            }
+        }
+    }
+
+    public void buildEntityTickList(Iterator<Entity> entityIt, Predicate<Entity> tickingPredicate) {
+        this.lock.writeLock().lock();
+        try {
+            while (entityIt.hasNext()) {
+                Entity entity = entityIt.next();
+                if (!tickingPredicate.test(entity)) {
+                    continue;
+                }
+                TickRegion region = this.lookupRegion(entity);
+                if (region == null) {
+                    // TODO: use a dummy region for these maybe existent edge cases?
+                    System.err.println("Could not find region for entity: " + entity);
+                } else {
+                    region.addToEntityTickList(entity);
+                }
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+    }
+
+    public void applyEntityTask(Consumer<Entity> entityTask) {
+        this.lock.readLock().lock();
+        Collection<TickRegion> regionIterable = CollectionUtils.immutableCopy(this.regionList);
+        this.lock.readLock().unlock();
+
+        int nRegions = regionIterable.size();
+        CountDownLatch latch = new CountDownLatch(nRegions);
+        for (TickRegion region : regionIterable) {
+            runAsync(() -> {
+                region.setStateMutatingThread();
+                // Run entity state mutating tasks pre tick.
+                {
+                    Iterator<EntityTaskPair> iterator = this.entityInRegionTasks.iterator();
+                    while (iterator.hasNext()) {
+                        EntityTaskPair task = iterator.next();
+                        task.visited++;
+                        // willTick will only return false when the entity way already ticked.
+                        // We have not yet called applyTaskToEntityTickList.
+                        // and it will not be called until this loop completes.
+                        if (region.getEntityTickList().willTick(task.getEntityId())) {
+                            task.task.run();
+                            iterator.remove();
+                        }
+                    }
+                }
+                region.resetMutatingThread();
+                try {
+                    try {
+                        region.applyTaskToEntityTickList(entityTask);
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                } finally {
+                    latch.countDown();
+                }
+            });
+        }
+        try {
+            latch.await();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+        for (Iterator<EntityTaskPair> iterator = entityInRegionTasks.iterator(); iterator.hasNext(); ) {
+            EntityTaskPair task = iterator.next();
+            // If the task was checked by all regions if it should be executed on it,
+            // and it is still in this list, this means the entity is
+            // not in any region the TickRegionManager is tracking.
+            // The task could have been visited less than this number,
+            // if the task was added during the current tick.
+            // The region destined to received it, might have already completed
+            // the task visiting loop and has therefore missed it.
+            // In that case we do nothing, we leave it in the task queue
+            // and it will be dealt with next tick.
+            if (task.visited == nRegions) {
+                task.getOnOmitted().run();
+                iterator.remove();
+            }
+        }
+    }
+
+    private void runAsync(Runnable task) {
+        service.execute(task);
+    }
+
+    // weakly consistent, if #lock is not used
+    private TickRegion lookupRegion(int blockX, int blockZ) {
+        ChunkPos chunkPos = new ChunkPos(blockX >> 4, blockZ >> 4);
+        return this.tickRegionMap.get(chunkPos);
+    }
+
+    // weakly consistent, if #lock is not used
+    private TickRegion lookupRegion(BlockPos pos) {
+        ChunkPos chunkPos = new ChunkPos(pos.getX() >> 4, pos.getZ() >> 4);
+        return this.tickRegionMap.get(chunkPos);
+    }
+
+    // weakly consistent, if #lock is not used
+    private TickRegion lookupRegion(Entity entity) {
+        ChunkPos chunkPos = new ChunkPos(entity.xChunk, entity.zChunk);
+        return this.tickRegionMap.get(chunkPos);
+    }
+
+    private boolean addChunkToRegion(TickRegion region, Chunk chunk) {
+        this.tickRegionMap.put(chunk.getPos(), region);
+        return region.addChunk(chunk);
+    }
+
+    /**
+     * Merges the two regions.
+     *
+     * @param dstRegion the region to merge into
+     * @param srcRegion the region whose chunks should be merged into the other region
+     */
+    // not thread safe
+    private void mergeRegion(TickRegion dstRegion, TickRegion srcRegion) {
+        dstRegion.merge(srcRegion);
+        Collection<Chunk> chunks = srcRegion.getChunks();
+        for (Chunk chunk : chunks) {
+            this.tickRegionMap.put(chunk.getPos(), dstRegion);
+        }
+    }
+
+    // not thread safe
+    private void removeRegion(TickRegion region) {
+        Collection<Chunk> chunks = region.getChunks();
+        for (Chunk chunk : chunks) {
+            this.tickRegionMap.remove(chunk.getPos());
+        }
+        this.regionList.remove(region);
+    }
+
+    // not thread safe
+    private TickRegion createRegion() {
+        TickRegion region = new TickRegion();
+        this.regionList.add(region);
+        return region;
+    }
+
+    // not thread safe
+    private TickRegion findRegion(Chunk chunk) {
+        for (TickRegion region : this.regionList) {
+            if (region.containsOrBorders(chunk)) {
+                return region;
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public String toString() {
+        return "RegionManager{" +
+                "numRegions=" + this.regionList.size() + ", " +
+                "regionList=" + this.regionList +
+                '}';
+    }
+
+    public Chunk getChunk(int x, int z) {
+        TickRegion region = this.lookupRegion(x, z);
+        if (region == null)
+            return null;
+        return region.getChunk(x, z);
+    }
+
+    public BlockPosTickList newBlockPosTickList() {
+        return new BlockPosTickList(this);
+    }
+
+    /**
+     * Runs an entity tick task in the region ticking the specified entity.
+     *
+     * @param entityId  the id of the entity that determines the region in which to execute the task
+     * @param task      the task to execute
+     * @param onOmitted is executed when the entity was not ticked during the following tick. It could be because the entity was removed / de-spawned / died etc.
+     */
+    public void runEntityTaskInRegion(int entityId, Runnable task, Runnable onOmitted) {
+        this.entityInRegionTasks.add(new EntityTaskPair(entityId, task, onOmitted));
+    }
+
+    /**
+     * Checks if the specified thread allowed to mutate the specified entity
+     */
+    public boolean isMutationAllowed(EntityThreadGuard<? extends Entity> entity, Thread thread) {
+        // Using weakly consistent position is fine here, the position can only change during entity tick.
+        // 1.
+        // If this method is invoked through on an in-region task for that entity, the entity is currently not being
+        // ticked, as the entity tick does not start until all in-region tasks that are scheduled are executed.
+        // 2.
+        // If the method is invoked concurrently (wrong thread in the first place)
+        // or during entity ticking of the region of the specified entity (not the mutating thread of the region, pre-tick task phase has ended),
+        // the entity might already have been ticked, in which case it is no longer on the EntityTickList.
+        // If this is the case, mutation is of course not allowed.
+        // 3.
+        // If the entity is yet to be ticked and therefore is still on the tick list and the current thread
+        // is the currently mutating thread of the region, mutation is allowed.
+        // 4.
+        // If the method was invoked on a tick worker during in-region task execution of a region whose tick list does not
+        // contain the entity, but the actual worker of that entity has already ticked that entity, modifying the position so that lookupRegion
+        // will return a region that that the entity was not ticked on, the entity tick list of that region would of course not contain
+        // the entity.
+        // Parts of the last tick of the entity that made the position change would have happened "on the wrong thread", in that case
+        // we have to hope for the best. // TODO: FIX IDEAS?
+        // We do not authorize write access to that entity on the current thread because we can't even be sure that the entity's tick
+        // has completed by now. That is achieved by the willTick check, even in the special case where the mutation thread of that region would have matched,
+        // when the entity teleported into the region we have mutation access to. Don't touch an entity that might still be ticked that is actually in our
+        // region. That case is risky enough in vanilla minecraft, we don't want plugins to make it even worse.
+        TickRegion tickRegion = lookupRegion(entity.getWeaklyConsistentPosition());
+        if (!tickRegion.getEntityTickList().willTick(entity.getEntityId())) {
+            return false;
+        }
+        return tickRegion.getMutatingThread() == thread;
+    }
+
+    /**
+     * Runs the task on all regions in parallel
+     *
+     * @param task the task to run
+     */
+    private void runOnAllRegions(@NotNull Consumer<Region> task) {
+        Collection<Region> regions = regions(); // regions are not weakly consistent in global world task
+        CountDownLatch latch = new CountDownLatch(regions.size());
+        for (Region region : regions) {
+            runAsync(() -> {
+                try {
+                    task.accept(region);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                } finally {
+                    latch.countDown();
+                }
+            });
+        }
+        try {
+            latch.await();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Runs a task for all regions as a world global task.
+     * Task execution is concurrent between regions.
+     *
+     * @param task the task runnable that is invoked concurrently with all regions
+     */
+    public void runTaskInAllRegions(@NotNull Consumer<Region> task) {
+        WorldTickManager.runGlobalTask(this.world, () -> runOnAllRegions(task));
+    }
+
+    /**
+     * Schedules a repeating task for all regions as a world global task.
+     * Task execution is concurrent between regions.
+     * Task is executed until cancelled.
+     *
+     * @param repeatingTask the repeating task
+     */
+    public void scheduleRepeatingTaskInAllRegions(@NotNull GameTick.RepeatingTask<Region> repeatingTask) {
+        GameTick.RepeatingTask<World> worldTask = new GameTick.RepeatingTask<>(world -> runOnAllRegions(repeatingTask));
+        WorldTickManager.scheduleRepeatingTask(this.world, worldTask);
+    }
+
+    /**
+     * @return the regions that the region tick manager tracks. Weakly consistent, lifecycle disposable, does not expose mutability to internal state
+     */
+    @NotNull
+    private Collection<Region> regions() {
+        this.lock.readLock().lock();
+        Collection<TickRegion> regionIterable = CollectionUtils.immutableCopy(this.regionList);
+        Collection<Region> regions = Lists.newArrayList();
+        for (TickRegion region : regionIterable) {
+            EntityTickList tickList = region.getEntityTickList();
+            regions.add(DisposableImmutableRegionSnapshot.immutableCopyOf(tickList.getTickListUnsafe()));
+        }
+        this.lock.readLock().unlock();
+        return regions;
+    }
+
+    private static class DisposableImmutableRegionSnapshot implements Region {
+
+        @NotNull
+        private final Iterable<Entity> entities;
+
+        private DisposableImmutableRegionSnapshot(@NotNull Iterable<Entity> entities) {
+            this.entities = entities;
+        }
+
+        @NotNull
+        public static Region immutableCopyOf(@NotNull Iterable<Entity> entities) {
+            return new DisposableImmutableRegionSnapshot(ImmutableList.copyOf(entities));
+        }
+
+        @NotNull
+        @Override
+        public Iterable<Entity> entities() {
+            return this.entities;
+        }
+    }
+
+    private static class EntityTaskPair {
+
+        private final int entityId;
+        private final Runnable task;
+        private final Runnable onOmitted;
+        public int visited = 0;
+
+        public EntityTaskPair(int entityId, Runnable task, Runnable onOmitted) {
+            this.entityId = entityId;
+            this.task = task;
+            this.onOmitted = onOmitted;
+        }
+
+        public int getEntityId() {
+            return entityId;
+        }
+
+        public Runnable getTask() {
+            return task;
+        }
+
+        public Runnable getOnOmitted() {
+            return onOmitted;
+        }
+    }
+
+    public static class BlockPosTickList {
+
+        private final RegionTickManager regionManager;
+        private final Map<TickRegion, Queue<Runnable>> regionTaskMap = Maps.newConcurrentMap();
+
+        private BlockPosTickList(RegionTickManager regionManager) {
+            this.regionManager = regionManager;
+        }
+
+        public void scheduleBlockPosTask(BlockPos pos, Runnable task) {
+            TickRegion tickRegion = this.regionManager.lookupRegion(pos.getX(), pos.getZ());
+            Queue<Runnable> taskQueue = this.regionTaskMap.get(tickRegion);
+            if (taskQueue == null) {
+                taskQueue = Queues.newConcurrentLinkedQueue();
+                this.regionTaskMap.put(tickRegion, taskQueue);
+            }
+            taskQueue.add(task);
+        }
+
+        public void runTasks() throws InterruptedException {
+            Collection<Map.Entry<TickRegion, Queue<Runnable>>> entries = CollectionUtils.immutableCopy(this.regionTaskMap.entrySet());
+            CountDownLatch latch = new CountDownLatch(entries.size());
+            for (Map.Entry<TickRegion, Queue<Runnable>> entry : entries) {
+                Queue<Runnable> tasks = entry.getValue();
+                this.regionManager.runAsync(() -> {
+                    try {
+                        try {
+                            while (!tasks.isEmpty()) {
+                                Runnable task = tasks.remove();
+                                task.run();
+                            }
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                    } finally {
+                        latch.countDown();
+                    }
+                });
+            }
+            latch.await();
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/region/TickRegion.java b/src/main/java/me/mikex86/velox/tick/region/TickRegion.java
new file mode 100644
index 0000000..ddcd7cd
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/region/TickRegion.java
@@ -0,0 +1,164 @@
+package me.mikex86.velox.tick.region;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import me.mikex86.velox.tick.ticklist.entity.EntityTickList;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+
+import java.util.*;
+import java.util.function.Consumer;
+
+public class TickRegion {
+
+    private final Map<ChunkPos, Chunk> chunkMap = Maps.newHashMap();
+    private final EntityTickList entityTickList = new EntityTickList();
+    private volatile Thread mutatingThread = null;
+
+    public boolean addChunk(Chunk chunk) {
+        return this.chunkMap.put(chunk.getPos(), chunk) == null;
+    }
+
+    public boolean removeChunk(Chunk chunk) {
+        return this.chunkMap.remove(chunk.getPos()) != null;
+    }
+
+    public void addToEntityTickList(Entity entity) {
+        this.entityTickList.scheduleTick(entity);
+    }
+
+    public void setStateMutatingThread() {
+        this.mutatingThread = Thread.currentThread();
+    }
+
+    public void applyTaskToEntityTickList(Consumer<Entity> entityTask) {
+        this.entityTickList.performTickListTasks(entityTask);
+    }
+
+    public void resetMutatingThread() {
+        this.mutatingThread = null;
+    }
+
+    public EntityTickList getEntityTickList() {
+        return entityTickList;
+    }
+
+    public Thread getMutatingThread() {
+        return mutatingThread;
+    }
+
+    public boolean containsOrBorders(Chunk chunk) {
+        ChunkPos chunkPos = chunk.getPos();
+        for (Chunk regionChunk : this.chunkMap.values()) {
+            ChunkPos regionChunkPos = regionChunk.getPos();
+            int xDif = Math.abs(regionChunkPos.x - chunkPos.x);
+            int zDif = Math.abs(regionChunkPos.z - chunkPos.z);
+
+            // the distance can either be 0 or 1 on both xDif and zDif for "chunk" to either
+            // be at the same position as "regionChunkPos" or border it.
+            if (Math.max(xDif, zDif) <= 1) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isEmpty() {
+        return this.chunkMap.isEmpty();
+    }
+
+    public void merge(TickRegion srcRegion) {
+        this.chunkMap.putAll(srcRegion.chunkMap);
+    }
+
+    @Override
+    public String toString() {
+        return "Region{" +
+                "numChunks=" + this.chunkMap.size() +
+                '}';
+    }
+
+    public Collection<Chunk> getChunks() {
+        return chunkMap.values();
+    }
+
+    List<Chunk> floodFillFromChunkUntilChunk(Chunk startChunk, Chunk endChunk) {
+        List<Chunk> floodFilledChunks = Lists.newArrayList();
+        Set<Chunk> visited = Sets.newHashSet();
+
+        Queue<Chunk> chunkFloodQueue = Lists.newLinkedList();
+        chunkFloodQueue.add(startChunk);
+
+        while (!chunkFloodQueue.isEmpty()) {
+            Chunk chunk = chunkFloodQueue.remove();
+
+            floodFilledChunks.add(chunk);
+
+            visited.add(chunk);
+            if (chunk == endChunk) {
+                break;
+            }
+            getNeighbors(false, chunkFloodQueue, visited, chunk);
+        }
+
+        return floodFilledChunks;
+    }
+
+//    List<Chunk> floodFillFromChunk(Chunk firstChunk) {
+//        List<Chunk> floodFilledChunks = Lists.newLinkedList();
+//
+//        Set<Chunk> chunkFloodSet = Sets.newHashSet();
+//        chunkFloodSet.add(firstChunk);
+//
+//        while (!chunkFloodSet.isEmpty()) {
+//            Chunk chunk = chunkFloodSet.iterator().next();
+//            floodFilledChunks.add(chunk);
+//            getNeighbors(chunkFloodSet, chunk);
+//        }
+//
+//        return floodFilledChunks;
+//    }
+
+    void getNeighbors(boolean addNulls, Collection<Chunk> dst, Collection<Chunk> visited, Chunk chunk) {
+        ChunkPos pos = chunk.getPos();
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x - 1, pos.z);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x + 1, pos.z);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x, pos.z - 1);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x, pos.z + 1);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+    }
+
+    public Chunk getChunk(int blockX, int blockZ) {
+        ChunkPos chunkPos = new ChunkPos(blockX >> 4, blockZ >> 4);
+        return this.chunkMap.get(chunkPos);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/ticklist/block/ConcurrentTickList.java b/src/main/java/me/mikex86/velox/tick/ticklist/block/ConcurrentTickList.java
new file mode 100644
index 0000000..155ab18
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/ticklist/block/ConcurrentTickList.java
@@ -0,0 +1,37 @@
+package me.mikex86.velox.tick.ticklist.block;
+
+import me.mikex86.velox.tick.region.RegionTickManager;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.world.NextTickListEntry;
+import net.minecraft.world.server.ServerTickList;
+import net.minecraft.world.server.ServerWorld;
+
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+public class ConcurrentTickList<T> extends ServerTickList<T> {
+
+    private final RegionTickManager.BlockPosTickList tickList;
+
+    public ConcurrentTickList(ServerWorld p_i231625_1_, Predicate<T> p_i231625_2_, Function<T, ResourceLocation> p_i231625_3_, Consumer<NextTickListEntry<T>> p_i231625_4_) {
+        super(p_i231625_1_, p_i231625_2_, p_i231625_3_, p_i231625_4_);
+        RegionTickManager regionTickManager = p_i231625_1_.regionTickManager;
+        this.tickList = regionTickManager.newBlockPosTickList();
+    }
+
+    @Override
+    protected void tickEntry(NextTickListEntry<T> entry) {
+        this.tickList.scheduleBlockPosTask(entry.pos, () -> super.tickEntry(entry));
+    }
+
+    @Override
+    protected void postTick() {
+        // Actually perform the ticks
+        try {
+            this.tickList.runTasks();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/ticklist/entity/EntityTickList.java b/src/main/java/me/mikex86/velox/tick/ticklist/entity/EntityTickList.java
new file mode 100644
index 0000000..4074c19
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/ticklist/entity/EntityTickList.java
@@ -0,0 +1,43 @@
+package me.mikex86.velox.tick.ticklist.entity;
+
+import com.google.common.collect.Queues;
+import it.unimi.dsi.fastutil.ints.IntLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.ints.IntSets;
+import net.minecraft.entity.Entity;
+
+import java.util.Queue;
+import java.util.function.Consumer;
+
+/**
+ * A simple tick list for entities.
+ * The entities to tick will be determined by calling {@link #scheduleTick(Entity)} on the entity to schedule to be ticked.
+ * {@link #performTickListTasks(Consumer)} will poll the entities and apply the ticker to perform the scheduled tick tasks
+ * for the entities.
+ */
+public class EntityTickList {
+
+    private final Queue<Entity> tickList = Queues.newConcurrentLinkedQueue();
+    private final IntSet entityIds = IntSets.synchronize(new IntLinkedOpenHashSet());
+
+    public synchronized void scheduleTick(Entity entity) {
+        this.tickList.add(entity);
+        this.entityIds.add(entity.getId());
+    }
+
+    public synchronized void performTickListTasks(Consumer<Entity> ticker) {
+        while (!this.tickList.isEmpty()) {
+            Entity entity = this.tickList.remove();
+            this.entityIds.remove(entity.getId());
+            ticker.accept(entity);
+        }
+    }
+
+    public boolean willTick(int entityId) {
+        return this.entityIds.contains(entityId);
+    }
+
+    public Queue<Entity> getTickListUnsafe() {
+        return tickList;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/ArrayUtils.java b/src/main/java/me/mikex86/velox/utils/ArrayUtils.java
new file mode 100644
index 0000000..e6fdbb6
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/ArrayUtils.java
@@ -0,0 +1,23 @@
+package me.mikex86.velox.utils;
+
+public class ArrayUtils {
+
+    public static int[] unbox(Integer[] boxed) {
+        int[] unboxed = new int[boxed.length];
+        for (int i = 0; i < boxed.length; i++) {
+            Integer integer = boxed[i];
+            unboxed[i] = integer == null ? 0 : integer;
+        }
+        return unboxed;
+    }
+
+    public static long[] unbox(Long[] boxed) {
+        long[] unboxed = new long[boxed.length];
+        for (int i = 0; i < boxed.length; i++) {
+            Long aLong = boxed[i];
+            unboxed[i] = aLong == null ? 0 : aLong;
+        }
+        return unboxed;
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/utils/CollectionUtils.java b/src/main/java/me/mikex86/velox/utils/CollectionUtils.java
new file mode 100644
index 0000000..9eaca5e
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/CollectionUtils.java
@@ -0,0 +1,34 @@
+package me.mikex86.velox.utils;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import net.minecraft.world.server.ChunkManager;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+public class CollectionUtils {
+
+    public static <T> List<T> collectToList(Iterator<T> iterator) {
+        List<T> values = Lists.newArrayList();
+        while (iterator.hasNext()) {
+            values.add(iterator.next());
+        }
+        return values;
+    }
+
+    public static<T> Iterable<T> prefetchIterable(Iterable<T> iterable) {
+        return collectToList(iterable.iterator());
+    }
+
+    public static<T> Iterator<T> prefetchIterator(Iterator<T> iterable) {
+        return collectToList(iterable).iterator();
+    }
+
+    public static <T> Collection<T> immutableCopy(Collection<T> collection) {
+        return ImmutableList.copyOf(collection);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/MathUtils.java b/src/main/java/me/mikex86/velox/utils/MathUtils.java
new file mode 100644
index 0000000..3ced56b
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/MathUtils.java
@@ -0,0 +1,33 @@
+package me.mikex86.velox.utils;
+
+import static java.lang.Math.floorDiv;
+
+public class MathUtils {
+
+    /**
+     * Uses crazy standford magic to round up to the next power of two.
+     * For zero, it will return back zero again. This is a small anomaly of the function
+     * for performance reasons.
+     *
+     * @param n a given number
+     * @return the next power of two after (or equal to) n
+     */
+    public static int npot(int n) {
+        n--;
+        n |= n >> 1;
+        n |= n >> 2;
+        n |= n >> 4;
+        n |= n >> 8;
+        n |= n >> 16;
+        n++;
+        return n;
+    }
+
+    public static long floorMod(long x, long y) {
+        return x - floorDiv(x, y) * y;
+    }
+
+    public static int clamp(int value, int low, int high) {
+        return value > high ? high : value < low ? low : value;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/PeriodicInvoker.java b/src/main/java/me/mikex86/velox/utils/PeriodicInvoker.java
new file mode 100644
index 0000000..4b2fcc7
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/PeriodicInvoker.java
@@ -0,0 +1,28 @@
+package me.mikex86.velox.utils;
+
+import java.util.concurrent.TimeUnit;
+
+public class PeriodicInvoker implements Runnable {
+
+    private final Runnable runnable;
+    private final long time;
+    private final TimeUnit timeUnit;
+
+    public PeriodicInvoker(Runnable runnable, long time, TimeUnit timeUnit) {
+        this.runnable = runnable;
+        this.time = time;
+        this.timeUnit = timeUnit;
+    }
+
+    @Override
+    public void run() {
+        try {
+            while (true) {
+                this.runnable.run();
+                Thread.sleep(this.timeUnit.toMillis(this.time));
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/StreamUtils.java b/src/main/java/me/mikex86/velox/utils/StreamUtils.java
new file mode 100644
index 0000000..411753c
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/StreamUtils.java
@@ -0,0 +1,18 @@
+package me.mikex86.velox.utils;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class StreamUtils {
+
+    public static <T> Stream<T> prefetch(Stream<T> stream) {
+        return stream.collect(Collectors.toList()).stream();
+    }
+
+    public static <T> Stream<T> prefetchSynchronizedCollection(Collection<T> collection) {
+        T[] array = collection.toArray((T[]) new Object[0]);
+        return Arrays.stream(array);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/Streamer.java b/src/main/java/me/mikex86/velox/utils/Streamer.java
new file mode 100644
index 0000000..73cb54c
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/Streamer.java
@@ -0,0 +1,108 @@
+package me.mikex86.velox.utils;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+public class Streamer {
+
+    /**
+     * Applies a function to stream elements in batches and returns the results. This method does not mutate the stream! (how would it?)
+     *
+     * @param executor  the executor to run the functions async on
+     * @param stream    the stream to retrieve elements from
+     * @param function  the function to apply
+     * @param batchSize the size of a batch that should be processed as one completable future. The result can only be retrieved when all elements of a batch are applied
+     * @param <T>       the type of elements
+     * @param <R>       the output type of the apply function
+     * @return the futures of the batches
+     */
+    public static <T, R> List<CompletableFuture<List<R>>> applyAsync(Executor executor, Stream<T> stream, Function<T, R> function, int batchSize) {
+        List<List<T>> batches = getBatches(stream, batchSize);
+        List<CompletableFuture<List<R>>> futures = new ArrayList<>();
+        for (List<T> batch : batches) {
+            futures.add(CompletableFuture.supplyAsync(() -> {
+                List<R> results = new ArrayList<>();
+                for (T t : batch) {
+                    results.add(function.apply(t));
+                }
+                return results;
+            }, executor));
+        }
+        return futures;
+    }
+
+    /**
+     * Performs {@link #applyAsync(Executor, Stream, Function, int)} and waits for the futures to complete
+     *
+     * @throws ExecutionException   if the execution completed exceptionally
+     * @throws InterruptedException if the execution thread was interrupted
+     * @see #applyAsync(Executor, Stream, Function, int)
+     */
+    public static <T, R> void applyAsyncWait(Executor executor, Stream<T> stream, Function<T, R> function, int batchSize) throws ExecutionException, InterruptedException {
+        List<CompletableFuture<List<R>>> futures = applyAsync(executor, stream, function, batchSize);
+        for (CompletableFuture<List<R>> future : futures) {
+            future.get();
+        }
+    }
+
+    /**
+     * Splits a given stream into batches. The last batch may not be of size #batchSize
+     *
+     * @param stream    the stream to split
+     * @param batchSize number of elements of each batch
+     * @param <T>       the type of element
+     * @return the list of batches
+     */
+    public static <T> List<List<T>> getBatches(Stream<T> stream, int batchSize) {
+        AtomicInteger i = new AtomicInteger(0);
+        List<List<T>> batches = new ArrayList<>();
+        stream.forEachOrdered(e -> {
+            int ig = i.get();
+            int batchIndex = ig / batchSize;
+            if (batchIndex == batches.size()) {
+                batches.add(new ArrayList<>());
+            }
+            batches.get(batchIndex).add(e);
+            i.incrementAndGet();
+        });
+        return batches;
+    }
+
+    public static <T> void streamBatched(Executor executor, int nBatches, Collection<T> values, Consumer<T> consumer) throws InterruptedException, ExecutionException {
+        int batchSize = roundUp(values.size(), nBatches);
+        Iterator<T> iterator = values.iterator();
+        T[] batch = (T[]) new Object[batchSize];
+        int i = 0;
+        CountDownLatch entityLatch = new CountDownLatch(values.size());
+        AtomicBoolean earlyAbort = new AtomicBoolean(false);
+
+        while (iterator.hasNext()) {
+            T next = iterator.next();
+            batch[i] = next;
+            i++;
+            // if batch is fully filled or no next value is available (partial batch), schedule a task processing that batch
+            if (i == batchSize || !iterator.hasNext()) {
+                T[] batchCopy = Arrays.copyOf(batch, i);
+                executor.execute(() -> {
+                    for (T value : batchCopy) {
+                        if (!earlyAbort.get()) {
+                            consumer.accept(value);
+                        }
+                        entityLatch.countDown();
+                    }
+                });
+                i = 0;
+            }
+        }
+        entityLatch.await();
+    }
+
+    private static int roundUp(int num, int divisor) {
+        return (num + divisor - 1) / divisor;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/lock/AbstractLock.java b/src/main/java/me/mikex86/velox/utils/lock/AbstractLock.java
new file mode 100644
index 0000000..8931022
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/lock/AbstractLock.java
@@ -0,0 +1,42 @@
+package me.mikex86.velox.utils.lock;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+
+public abstract class AbstractLock implements Lock {
+
+    @Override
+    public abstract void lock();
+
+    @Override
+    public void lockInterruptibly() {
+        lock();
+    }
+
+    @Override
+    public boolean tryLock() {
+        throw new UnsupportedOperationException("tryLock() not implemented");
+    }
+
+
+    @Override
+    public boolean tryLock(long time, TimeUnit unit) {
+        long nanos = unit.toNanos(time);
+        long start = System.nanoTime();
+        while (System.nanoTime() - start < nanos) {
+            if (tryLock()) {
+                return true;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public abstract void unlock();
+
+    @Override
+    public Condition newCondition() {
+        throw new UnsupportedOperationException("newCondition() not implemented");
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/lock/DummyLock.java b/src/main/java/me/mikex86/velox/utils/lock/DummyLock.java
new file mode 100644
index 0000000..1f35585
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/lock/DummyLock.java
@@ -0,0 +1,38 @@
+package me.mikex86.velox.utils.lock;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+
+public class DummyLock implements Lock {
+
+    @Override
+    public void lock() {
+
+    }
+
+    @Override
+    public void lockInterruptibly() throws InterruptedException {
+
+    }
+
+    @Override
+    public boolean tryLock() {
+        return false;
+    }
+
+    @Override
+    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
+        return false;
+    }
+
+    @Override
+    public void unlock() {
+
+    }
+
+    @Override
+    public Condition newCondition() {
+        return null;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/lock/DummyReadWriteLock.java b/src/main/java/me/mikex86/velox/utils/lock/DummyReadWriteLock.java
new file mode 100644
index 0000000..0f4225a
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/lock/DummyReadWriteLock.java
@@ -0,0 +1,20 @@
+package me.mikex86.velox.utils.lock;
+
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+
+public class DummyReadWriteLock implements ReadWriteLock {
+
+    private final Lock lock = new DummyLock();
+
+    @Override
+    public Lock readLock() {
+        return lock;
+    }
+
+    @Override
+    public Lock writeLock() {
+        return lock;
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/utils/threading/ThreadingUtil.java b/src/main/java/me/mikex86/velox/utils/threading/ThreadingUtil.java
new file mode 100644
index 0000000..b937350
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/threading/ThreadingUtil.java
@@ -0,0 +1,27 @@
+package me.mikex86.velox.utils.threading;
+
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+
+public class ThreadingUtil {
+
+    public static ExecutorService newWorkerPool(String name, int poolSize, List<Thread> threadsOut) {
+        return Executors.newFixedThreadPool(poolSize, new ThreadFactory() {
+
+            private int nThreads = 0;
+
+            @Override
+            public Thread newThread(Runnable r) {
+                Thread thread = new Thread(r, name + "Worker" + nThreads);
+                thread.setDaemon(true);
+                if (threadsOut != null)
+                    threadsOut.add(thread);
+                nThreads++;
+                return thread;
+            }
+        });
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/veloxapiimpl/event/EventDispatcher.java b/src/main/java/me/mikex86/velox/veloxapiimpl/event/EventDispatcher.java
new file mode 100644
index 0000000..76fb72e
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/veloxapiimpl/event/EventDispatcher.java
@@ -0,0 +1,59 @@
+package me.mikex86.velox.veloxapiimpl.event;
+
+import com.google.common.collect.Lists;
+import me.mikex86.veloxapi.event.Event;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+import java.util.function.BiConsumer;
+
+/**
+ * Receives fired events (via {@link #fire(Event)} and invokes all {@link #dispatchingEndpoints} with the events class and the instance.
+ * Invocation of the endpoints is parallelized so no guarantees for execution order.
+ */
+public class EventDispatcher {
+
+    public static EventDispatcher INSTANCE = new EventDispatcher();
+
+    @NotNull
+    private final List<BiConsumer<Class<? extends Event>, Event>> dispatchingEndpoints;
+
+    public EventDispatcher() {
+        this.dispatchingEndpoints = Lists.newCopyOnWriteArrayList();
+    }
+
+    /**
+     * Adds the specified BiConsumer to {@link #dispatchingEndpoints}
+     * Events fired will be dispatched to all endpoints in the list.
+     *
+     * @param endpoint the registry that events should be dispatched to
+     */
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    public <T extends Event> void addDispatchingEndpoint(@NotNull BiConsumer<Class<T>, T> endpoint) {
+        this.dispatchingEndpoints.add((BiConsumer) endpoint);
+    }
+
+    /**
+     * Remove the specified BiConsumer from {@link #dispatchingEndpoints}
+     * The endpoint will no longer be invoked by the dispatcher when the dispatching of any currently fired event completes.
+     *
+     * @param endpoint the registry that events should be dispatched to
+     */
+    @SuppressWarnings({"rawtypes"})
+    public <T extends Event> void removeDispatchingEndpoint(@NotNull BiConsumer<Class<T>, T> endpoint) {
+        this.dispatchingEndpoints.remove((BiConsumer) endpoint);
+    }
+
+    /**
+     * Called to dispatch events to all {@link #dispatchingEndpoints}
+     *
+     * @param event the event instance fired
+     */
+    @SuppressWarnings({"unchecked"})
+    public <T extends Event> void fire(@NotNull T event) {
+        Class<T> eventClass = (Class<T>) event.getClass();
+        this.dispatchingEndpoints.parallelStream().forEach(registry -> registry.accept(eventClass, event));
+    }
+
+
+}
diff --git a/src/main/java/me/mikex86/velox/veloxapiimpl/listener/VeloxEventListenerRegistry.java b/src/main/java/me/mikex86/velox/veloxapiimpl/listener/VeloxEventListenerRegistry.java
new file mode 100644
index 0000000..c6628e0
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/veloxapiimpl/listener/VeloxEventListenerRegistry.java
@@ -0,0 +1,86 @@
+package me.mikex86.velox.veloxapiimpl.listener;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import me.mikex86.veloxapi.event.Event;
+import me.mikex86.veloxapi.event.EventListener;
+import me.mikex86.veloxapi.event.EventListenerRegistry;
+import me.mikex86.veloxapi.event.exception.ListenerRegistrationException;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Map;
+import java.util.Queue;
+
+public class VeloxEventListenerRegistry implements EventListenerRegistry {
+
+    private final Map<Class<? extends Event>, Queue<EventListenerEntry<? extends Event>>> listenerMap = Maps.newConcurrentMap();
+    private final Map<EventListener<? extends Event>, Class<? extends Event>> registeredListeners = Maps.newConcurrentMap();
+
+    @Override
+    public synchronized <T extends Event> void registerListener(@NotNull EventListener<T> eventListener, @NotNull Class<T> eventClass, @NotNull EventListener.Priority requestedPriority) {
+        if (this.registeredListeners.containsKey(eventListener)) {
+            throw new ListenerRegistrationException("Listener already registered!");
+        }
+        Queue<EventListenerEntry<T>> listeners = retrieveEventListeners(eventClass);
+        listeners.add(new EventListenerEntry<>(eventListener, requestedPriority));
+        this.registeredListeners.put(eventListener, eventClass);
+    }
+
+    @Override
+    public synchronized <T extends Event> void unregisterListener(@NotNull EventListener<T> eventListener) throws ListenerRegistrationException {
+        if (!this.registeredListeners.containsKey(eventListener)) {
+            throw new ListenerRegistrationException("Listener was never registered!");
+        }
+        Class<? extends Event> eventClazz = this.registeredListeners.get(eventListener);
+        Queue<? extends EventListenerEntry<? extends Event>> listeners = retrieveEventListeners(eventClazz);
+        listeners.removeIf(entry -> entry.getEventListener() == eventListener);
+        this.registeredListeners.remove(eventListener);
+    }
+
+    /**
+     * Retrieves the event listeners for the specified event class and creates a new list for that class if none exists.
+     */
+    @NotNull
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    private <T extends Event> Queue<EventListenerEntry<T>> retrieveEventListeners(Class<T> eventClazz) {
+        Queue<EventListenerEntry<T>> listeners = (Queue) this.listenerMap.get(eventClazz);
+        if (listeners == null) {
+            listeners = Queues.newPriorityBlockingQueue();
+            this.listenerMap.put(eventClazz, (Queue) listeners);
+        }
+        return listeners;
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    public <T extends Event> void invokeListeners(Class<T> eventClazz, T event) {
+        Queue<EventListenerEntry<T>> listenerEntries = (Queue) this.listenerMap.get(eventClazz);
+        if (listenerEntries == null)
+           return;
+        listenerEntries.parallelStream().forEach(entry -> entry.getEventListener().onEvent(event));
+    }
+
+    private static class EventListenerEntry<T extends Event> implements Comparable<EventListenerEntry<T>> {
+
+        private final EventListener<T> eventListener;
+        private final EventListener.Priority priority;
+
+        public EventListenerEntry(EventListener<T> eventListener, EventListener.Priority priority) {
+            this.eventListener = eventListener;
+            this.priority = priority;
+        }
+
+        public EventListener<T> getEventListener() {
+            return eventListener;
+        }
+
+        public EventListener.Priority getPriority() {
+            return priority;
+        }
+
+        @Override
+        public int compareTo(@NotNull VeloxEventListenerRegistry.EventListenerEntry<T> o) {
+            return Integer.compare(this.priority.getPriorityValue(), o.getPriority().getPriorityValue());
+        }
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/VeloxPlugin.java b/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/VeloxPlugin.java
new file mode 100644
index 0000000..b6a904f
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/VeloxPlugin.java
@@ -0,0 +1,53 @@
+package me.mikex86.velox.veloxapiimpl.plugin;
+
+import me.mikex86.velox.veloxapiimpl.event.EventDispatcher;
+import me.mikex86.velox.veloxapiimpl.listener.VeloxEventListenerRegistry;
+import me.mikex86.velox.veloxapiimpl.plugin.exception.PluginLoadStateException;
+import me.mikex86.veloxapi.plugin.JvmPlugin;
+import me.mikex86.veloxapi.event.Event;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.BiConsumer;
+
+public class VeloxPlugin {
+
+    @NotNull
+    private final JvmPlugin jvmPlugin;
+
+    @NotNull
+    private final VeloxEventListenerRegistry listenerRegistry;
+
+    private boolean enabled = false;
+
+    private final BiConsumer<Class<Event>, Event> eventEndpoint;
+
+
+    public VeloxPlugin(@NotNull JvmPlugin jvmPlugin) {
+        this.jvmPlugin = jvmPlugin;
+        this.listenerRegistry = new VeloxEventListenerRegistry();
+        this.eventEndpoint = this.listenerRegistry::invokeListeners;
+    }
+
+    public synchronized void enable() {
+        if (this.enabled) {
+            throw new PluginLoadStateException("Plugin is already enabled!");
+        }
+        this.enabled = true;
+        EventDispatcher.INSTANCE.addDispatchingEndpoint(this.eventEndpoint);
+    }
+
+    public synchronized void disable() {
+        if (!this.enabled) {
+            throw new PluginLoadStateException("Plugin is already disabled!");
+        }
+        this.enabled = false;
+        EventDispatcher.INSTANCE.removeDispatchingEndpoint(this.eventEndpoint);
+    }
+
+    public synchronized void initialize() {
+        if (!this.enabled) {
+            throw new PluginLoadStateException("Cannot initialize disabled plugin");
+        }
+        this.jvmPlugin.initListeners(this.listenerRegistry);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/VeloxPluginLoader.java b/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/VeloxPluginLoader.java
new file mode 100644
index 0000000..da31539
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/VeloxPluginLoader.java
@@ -0,0 +1,125 @@
+package me.mikex86.velox.veloxapiimpl.plugin;
+
+import com.google.common.collect.Lists;
+import com.google.gson.*;
+import me.mikex86.velox.veloxapiimpl.plugin.exception.PluginLoaderException;
+import me.mikex86.veloxapi.plugin.JvmPlugin;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.List;
+
+public class VeloxPluginLoader {
+
+    @NotNull
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    @NotNull
+    private final File pluginsFolder = new File("plugins");
+
+    @NotNull
+    private final Gson gson = new GsonBuilder()
+            .setPrettyPrinting()
+            .create();
+
+    @NotNull
+    private final List<VeloxPlugin> enabledPlugins = Lists.newCopyOnWriteArrayList();
+
+    @SuppressWarnings("ResultOfMethodCallIgnored")
+    public void loadPlugins() {
+        this.pluginsFolder.mkdirs();
+        File[] plugins = this.pluginsFolder.listFiles();
+        if (plugins == null) {
+            return;
+        }
+        for (File pluginFile : plugins) {
+            if (pluginFile.isFile() && pluginFile.getName().endsWith(".jar")) {
+                try {
+                    URLClassLoader pluginClassLoader = new URLClassLoader(
+                            new URL[]{pluginFile.toURI().toURL()},
+                            getClass().getClassLoader()
+                    );
+                    JvmPlugin plugin = this.loadPlugin(pluginClassLoader);
+                    VeloxPlugin veloxPlugin = new VeloxPlugin(plugin);
+                    this.initializePlugin(veloxPlugin);
+                    LOGGER.info("Successfully loaded plugin: \"" + pluginFile.getName() + "\"");
+                } catch (Exception e) {
+                    LOGGER.log(Level.ERROR, "Cannot load plugin: " + pluginFile.getName(), e);
+                }
+            }
+        }
+        LOGGER.info("Loaded " + this.enabledPlugins.size() + " plugins!");
+    }
+
+    private void initializePlugin(@NotNull VeloxPlugin plugin) {
+        this.enablePlugin(plugin);
+        plugin.initialize();
+    }
+
+    private void enablePlugin(@NotNull VeloxPlugin plugin) {
+        plugin.enable();
+        this.enabledPlugins.add(plugin);
+    }
+
+    private void disablePlugin(@NotNull VeloxPlugin plugin) {
+        plugin.disable();
+        this.enabledPlugins.remove(plugin);
+    }
+
+    public void disableAllLoadedPlugins() {
+        for (VeloxPlugin plugin : this.enabledPlugins) {
+            this.disablePlugin(plugin);
+        }
+    }
+
+    @NotNull
+    private JvmPlugin loadPlugin(@NotNull URLClassLoader classLoader) throws IOException {
+        try (InputStream stream = classLoader.getResourceAsStream("plugin.json")) {
+            if (stream == null) {
+                throw new PluginLoaderException("\"plugin.json\" not found in plugin jar");
+            }
+            JsonObject jsonObject = this.gson.fromJson(new InputStreamReader(stream), JsonObject.class);
+            JsonElement pluginClassElement = jsonObject.get("pluginClass");
+            if (pluginClassElement == null) {
+                throw new PluginLoaderException("\"plugin.json\" does not define \"pluginClass\" element");
+            }
+            if (!(pluginClassElement instanceof JsonPrimitive)) {
+                throw new PluginLoaderException("\"pluginClass\" defined in \"plugin.json\" must be a json primitive!");
+            }
+            String pluginClassName = pluginClassElement.getAsString();
+            Class<?> pluginClass;
+            try {
+                pluginClass = Class.forName(pluginClassName, true, classLoader);
+            } catch (ClassNotFoundException e) {
+                throw new PluginLoaderException("The class \"" + pluginClassName + "\" set as \"pluginClass\" defined in \"plugin.json\" does not exist");
+            }
+            Constructor<?> constructor;
+            try {
+                constructor = pluginClass.getConstructor();
+            } catch (NoSuchMethodException e) {
+                throw new PluginLoaderException("The class \"" + pluginClassName + "\" set as \"pluginClass\" defined in \"plugin.json\" does not define an empty constructor!");
+            }
+            Object instance;
+            try {
+                instance = constructor.newInstance();
+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
+                throw new PluginLoaderException("The class \"" + pluginClassName + "\" set as \"pluginClass\" defined in \"plugin.json\" could not be instanced.", e);
+            }
+            if (!(instance instanceof JvmPlugin)) {
+                throw new PluginLoaderException("The class \"" + pluginClassName + "\" set as \"pluginClass\" defined in \"plugin.json\" does not inherit from JvmPlugin!");
+            }
+            return (JvmPlugin) instance;
+        }
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/exception/PluginLoadStateException.java b/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/exception/PluginLoadStateException.java
new file mode 100644
index 0000000..987abea
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/exception/PluginLoadStateException.java
@@ -0,0 +1,19 @@
+package me.mikex86.velox.veloxapiimpl.plugin.exception;
+
+/**
+ * Thrown when plugin load state errors arise
+ */
+public class PluginLoadStateException extends RuntimeException {
+
+    public PluginLoadStateException(String message) {
+        super(message);
+    }
+
+    public PluginLoadStateException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public PluginLoadStateException(Throwable cause) {
+        super(cause);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/exception/PluginLoaderException.java b/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/exception/PluginLoaderException.java
new file mode 100644
index 0000000..ab964a0
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/veloxapiimpl/plugin/exception/PluginLoaderException.java
@@ -0,0 +1,19 @@
+package me.mikex86.velox.veloxapiimpl.plugin.exception;
+
+/**
+ * Thrown when plugin loading fails.
+ */
+public class PluginLoaderException extends RuntimeException {
+
+    public PluginLoaderException(String message) {
+        super(message);
+    }
+
+    public PluginLoaderException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public PluginLoaderException(Throwable cause) {
+        super(cause);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/veloxapiimpl/server/VeloxServer.java b/src/main/java/me/mikex86/velox/veloxapiimpl/server/VeloxServer.java
new file mode 100644
index 0000000..eba2d90
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/veloxapiimpl/server/VeloxServer.java
@@ -0,0 +1,52 @@
+package me.mikex86.velox.veloxapiimpl.server;
+
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.datafixers.DataFixer;
+import me.mikex86.velox.veloxapiimpl.plugin.VeloxPluginLoader;
+import net.minecraft.resources.DataPackRegistries;
+import net.minecraft.resources.ResourcePackList;
+import net.minecraft.server.ServerPropertiesProvider;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.management.PlayerProfileCache;
+import net.minecraft.util.registry.DynamicRegistries;
+import net.minecraft.world.chunk.listener.IChunkStatusListenerFactory;
+import net.minecraft.world.storage.IServerConfiguration;
+import net.minecraft.world.storage.SaveFormat;
+
+import java.io.IOException;
+import java.util.Objects;
+
+public class VeloxServer extends DedicatedServer {
+
+    private static VeloxServer instance;
+    private final VeloxPluginLoader pluginLoader = new VeloxPluginLoader();
+
+    public VeloxServer(Thread p_i232601_1_, DynamicRegistries.Impl p_i232601_2_, SaveFormat.LevelSave p_i232601_3_, ResourcePackList p_i232601_4_, DataPackRegistries p_i232601_5_, IServerConfiguration p_i232601_6_, ServerPropertiesProvider p_i232601_7_, DataFixer p_i232601_8_, MinecraftSessionService p_i232601_9_, GameProfileRepository p_i232601_10_, PlayerProfileCache p_i232601_11_, IChunkStatusListenerFactory p_i232601_12_) {
+        super(p_i232601_1_, p_i232601_2_, p_i232601_3_, p_i232601_4_, p_i232601_5_, p_i232601_6_, p_i232601_7_, p_i232601_8_, p_i232601_9_, p_i232601_10_, p_i232601_11_, p_i232601_12_);
+        if (instance != null) {
+            throw new IllegalStateException("Two server instances cannot exist!");
+        }
+        instance = this;
+    }
+
+    @Override
+    public boolean initServer() throws IOException {
+        boolean initServer = super.initServer();
+        if (!initServer) {
+            return false;
+        }
+        this.pluginLoader.loadPlugins();
+        return true;
+    }
+
+    @Override
+    public void stopServer() {
+        this.pluginLoader.disableAllLoadedPlugins();
+        super.stopServer();
+    }
+
+    public static VeloxServer getInstance() {
+        return Objects.requireNonNull(instance, "Global server instance not yet initialized!");
+    }
+}
diff --git a/src/main/java/me/mikex86/veloxapi/event/Event.java b/src/main/java/me/mikex86/veloxapi/event/Event.java
new file mode 100644
index 0000000..1d54157
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/event/Event.java
@@ -0,0 +1,7 @@
+package me.mikex86.veloxapi.event;
+
+/**
+ * Marker interface for event types.
+ */
+public interface Event {
+}
diff --git a/src/main/java/me/mikex86/veloxapi/event/EventListener.java b/src/main/java/me/mikex86/veloxapi/event/EventListener.java
new file mode 100644
index 0000000..a0948f9
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/event/EventListener.java
@@ -0,0 +1,40 @@
+package me.mikex86.veloxapi.event;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @param <T> the type of event the veloxapi.listener listens to
+ */
+public interface EventListener<T extends Event> {
+
+    /**
+     * Called when an event of the specified type is fired.
+     *
+     * @param event the event instance fired.
+     *              No guarantees about the identity or lifecycle of any event instance are being made.
+     */
+    void onEvent(@NotNull T event);
+
+    /**
+     * Represents the priority of execution for an EventListener.
+     *
+     * @see EventListenerRegistry
+     */
+    enum Priority {
+
+        LOW(-1), NORMAL(0), HIGH(1);
+
+        /**
+         * A numeric representation of a {@link Priority} enum constant
+         */
+        private final int priorityValue;
+
+        Priority(int priorityValue) {
+            this.priorityValue = priorityValue;
+        }
+
+        public int getPriorityValue() {
+            return priorityValue;
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/veloxapi/event/EventListenerRegistry.java b/src/main/java/me/mikex86/veloxapi/event/EventListenerRegistry.java
new file mode 100644
index 0000000..b98f2b6
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/event/EventListenerRegistry.java
@@ -0,0 +1,54 @@
+package me.mikex86.veloxapi.event;
+
+import me.mikex86.veloxapi.event.exception.ListenerRegistrationException;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Registry for event listeners.
+ * The registry is queried when an event is fired to determine which listeners should be invoked when the given
+ * even is fired in which order.
+ * Listeners only listen to the event types they are registered to be invoked with.
+ * An invocation priority for a veloxapi.listener can be requested, but no guarantees about the order of execution of the event
+ * listeners are made.
+ */
+public interface EventListenerRegistry {
+
+    /**
+     * Registers an event veloxapi.listener with normal priority.
+     * A veloxapi.listener instance cannot be registered twice.
+     * Listeners are NOT guaranteed to be invoked on the thread that fired it.
+     *
+     * @param eventListener the event veloxapi.listener to register.
+     * @param eventClass    the class of the event the veloxapi.listener listens to
+     * @param <T>           the type of event the event veloxapi.listener expects, as determined by eventClass
+     * @throws ListenerRegistrationException if the veloxapi.listener instance is already registered
+     */
+    default <T extends Event> void registerListener(@NotNull EventListener<T> eventListener, @NotNull Class<T> eventClass) throws ListenerRegistrationException {
+        registerListener(eventListener, eventClass, EventListener.Priority.NORMAL);
+    }
+
+    /**
+     * Registers an event veloxapi.listener with a specific priority.
+     * A veloxapi.listener instance cannot be registered twice.
+     * Listeners are NOT guaranteed to be invoked on the thread that fired it.
+     *
+     * @param eventListener     the event veloxapi.listener to register.
+     * @param eventClass        the class of the event the veloxapi.listener listens to
+     * @param requestedPriority he priority of execution for the veloxapi.listener.
+     * @param <T>               the type of event the event veloxapi.listener expects, as determined by eventClass.
+     *                          An invocation priority for a veloxapi.listener can be requested, but no guarantees about the order of execution of the event
+     *                          listeners are made because of parallelization.
+     * @throws ListenerRegistrationException if the veloxapi.listener instance is already registered
+     */
+    <T extends Event> void registerListener(@NotNull EventListener<T> eventListener, @NotNull Class<T> eventClass, @NotNull EventListener.Priority requestedPriority) throws ListenerRegistrationException;
+
+    /**
+     * Unregisters a given event veloxapi.listener instance.
+     *
+     * @param eventListener the veloxapi.listener to unregister
+     * @param <T>           the type of event the veloxapi.listener listens to
+     * @throws ListenerRegistrationException if the veloxapi.listener is not registered
+     */
+    <T extends Event> void unregisterListener(@NotNull EventListener<T> eventListener) throws ListenerRegistrationException;
+
+}
diff --git a/src/main/java/me/mikex86/veloxapi/event/exception/ListenerRegistrationException.java b/src/main/java/me/mikex86/veloxapi/event/exception/ListenerRegistrationException.java
new file mode 100644
index 0000000..5ede5b7
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/event/exception/ListenerRegistrationException.java
@@ -0,0 +1,21 @@
+package me.mikex86.veloxapi.event.exception;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Thrown when registration/un-registration of a veloxapi.listener fails
+ */
+public class ListenerRegistrationException extends RuntimeException {
+
+    public ListenerRegistrationException(@NotNull String message) {
+        super(message);
+    }
+
+    public ListenerRegistrationException(@NotNull String message, @NotNull Throwable cause) {
+        super(message, cause);
+    }
+
+    public ListenerRegistrationException(@NotNull Throwable cause) {
+        super(cause);
+    }
+}
diff --git a/src/main/java/me/mikex86/veloxapi/event/impl/PlayerChatEvent.java b/src/main/java/me/mikex86/veloxapi/event/impl/PlayerChatEvent.java
new file mode 100644
index 0000000..d92b0e4
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/event/impl/PlayerChatEvent.java
@@ -0,0 +1,30 @@
+package me.mikex86.veloxapi.event.impl;
+
+import me.mikex86.veloxapi.event.Event;
+import me.mikex86.veloxapi.threading.EntityThreadGuard;
+import net.minecraft.entity.player.ServerPlayerEntity;
+import org.jetbrains.annotations.NotNull;
+
+public class PlayerChatEvent implements Event {
+
+    @NotNull
+    private final String message;
+
+    @NotNull
+    private final EntityThreadGuard<ServerPlayerEntity> sender;
+
+    public PlayerChatEvent(@NotNull String message, @NotNull ServerPlayerEntity sender) {
+        this.message = message;
+        this.sender = new EntityThreadGuard<>(sender);
+    }
+
+    @NotNull
+    public String getMessage() {
+        return message;
+    }
+
+    @NotNull
+    public EntityThreadGuard<ServerPlayerEntity> getSender() {
+        return sender;
+    }
+}
diff --git a/src/main/java/me/mikex86/veloxapi/game/GameTick.java b/src/main/java/me/mikex86/veloxapi/game/GameTick.java
new file mode 100644
index 0000000..71fcaf7
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/game/GameTick.java
@@ -0,0 +1,133 @@
+package me.mikex86.veloxapi.game;
+
+import me.mikex86.velox.tick.global.WorldTickManager;
+import me.mikex86.velox.tick.region.RegionTickManager;
+import me.mikex86.veloxapi.region.Region;
+import me.mikex86.veloxapi.threading.EntityThreadGuard;
+import me.mikex86.veloxapi.threading.WorldThreadGuard;
+import net.minecraft.entity.Entity;
+import net.minecraft.world.World;
+import org.apache.logging.log4j.util.BiConsumer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Objects;
+import java.util.function.Consumer;
+
+/**
+ * Utility to interact with the minecraft game
+ */
+public class GameTick {
+
+    private static final Runnable EMPTY_RUNNABLE = () -> {
+    };
+
+    public static void runEntityTickTaskInRegion(@NotNull EntityThreadGuard<? extends Entity> entity, @NotNull Runnable task, @NotNull Runnable onOmitted) {
+        RegionTickManager regionManager = WorldTickManager.getWorldRegionTickManager(entity.getWorldId());
+        Objects.requireNonNull(regionManager, "No region manager defined for world id: " + entity.getWorldId());
+        regionManager.runEntityTaskInRegion(entity.getEntityId(), task, onOmitted);
+    }
+
+    public static void runEntityTickTaskInRegion(@NotNull EntityThreadGuard<? extends Entity> entity, @NotNull Runnable task) {
+        runEntityTickTaskInRegion(entity, task, EMPTY_RUNNABLE);
+    }
+
+    public static void runTaskInAllRegionsInWorld(@NotNull WorldThreadGuard<? extends World> world, @NotNull Consumer<Region> task) {
+        RegionTickManager regionManager = WorldTickManager.getWorldRegionTickManager(world.getWorldId());
+        Objects.requireNonNull(regionManager, "No region manager defined for world id: " + world.getWorldId());
+        regionManager.runTaskInAllRegions(task);
+    }
+
+    public static void runTaskInWorld(@NotNull WorldThreadGuard<? extends World> world, @NotNull Consumer<World> task) {
+        WorldTickManager.runGlobalTask(world, () -> {
+            World value = world.getValue();
+            task.accept(value);
+        });
+    }
+
+    public static boolean isThreadAuthorizedForRegion(@NotNull EntityThreadGuard<? extends Entity> entity, @NotNull Thread thread) {
+        RegionTickManager regionManager = WorldTickManager.getWorldRegionTickManager(entity.getWorldId());
+        Objects.requireNonNull(regionManager, "No region manager defined for world id: " + entity.getWorldId());
+        return regionManager.isMutationAllowed(entity, thread);
+    }
+
+    public static boolean isThreadAuthorizedForGlobalAccess(@NotNull WorldThreadGuard<? extends World> world, @NotNull Thread thread) {
+        return WorldTickManager.hasThreadGlobalMutationAccess(world, thread);
+    }
+
+    public static class Scheduler {
+
+        @NotNull
+        public static RepeatingTask<World> scheduleRepeatingTaskInWorld(@NotNull World world, @NotNull BiConsumer<World, RepeatingTask<World>> task) {
+            RepeatingTask<World> repeatingTask = new RepeatingTask<>();
+            repeatingTask.setTask(w -> task.accept(w, repeatingTask));
+            WorldTickManager.scheduleRepeatingTask(world, repeatingTask);
+            return repeatingTask;
+        }
+
+        @NotNull
+        public static RepeatingTask<World> scheduleRepeatingTaskInWorld(@NotNull WorldThreadGuard<? extends World> world, @NotNull BiConsumer<World, RepeatingTask<World>> task) {
+            RepeatingTask<World> repeatingTask = new RepeatingTask<>();
+            repeatingTask.setTask(w -> task.accept(w, repeatingTask));
+            WorldTickManager.scheduleRepeatingTask(world, repeatingTask);
+            return repeatingTask;
+        }
+
+        @NotNull
+        public static RepeatingTask<Region> scheduleRepeatingTaskInAllRegions(@NotNull World world, @NotNull BiConsumer<Region, RepeatingTask<Region>> task) {
+            RepeatingTask<Region> repeatingTask = new RepeatingTask<>();
+            repeatingTask.setTask(region -> task.accept(region, repeatingTask));
+
+            RegionTickManager regionManager = WorldTickManager.getWorldRegionTickManager(world.getWorldId());
+            Objects.requireNonNull(regionManager, "No region manager defined for world id: " + world.getWorldId());
+
+            regionManager.scheduleRepeatingTaskInAllRegions(repeatingTask);
+
+            return repeatingTask;
+        }
+
+
+        @NotNull
+        public static RepeatingTask<Region> scheduleRepeatingTaskInAllRegions(@NotNull WorldThreadGuard<? extends World> world, @NotNull BiConsumer<Region, RepeatingTask<Region>> task) {
+            RepeatingTask<Region> repeatingTask = new RepeatingTask<>();
+            repeatingTask.setTask(region -> task.accept(region, repeatingTask));
+
+            RegionTickManager regionManager = WorldTickManager.getWorldRegionTickManager(world.getWorldId());
+            Objects.requireNonNull(regionManager, "No region manager defined for world id: " + world.getWorldId());
+
+            regionManager.scheduleRepeatingTaskInAllRegions(repeatingTask);
+
+            return repeatingTask;
+        }
+
+    }
+
+    public static class RepeatingTask<T> implements Consumer<T> {
+
+        private Consumer<T> task = null;
+        private boolean cancelled = false;
+
+        public RepeatingTask() {
+        }
+
+        public RepeatingTask(@NotNull Consumer<T> task) {
+            this.task = task;
+        }
+
+        private void setTask(@NotNull Consumer<T> task) {
+            this.task = task;
+        }
+
+        @Override
+        public void accept(T value) {
+            Objects.requireNonNull(this.task, "Repeating task consumer not initialized!").accept(value);
+        }
+
+        public void cancel() {
+            this.cancelled = true;
+        }
+
+        public boolean isCancelled() {
+            return cancelled;
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/veloxapi/plugin/JvmPlugin.java b/src/main/java/me/mikex86/veloxapi/plugin/JvmPlugin.java
new file mode 100644
index 0000000..91bc406
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/plugin/JvmPlugin.java
@@ -0,0 +1,19 @@
+package me.mikex86.veloxapi.plugin;
+
+import me.mikex86.veloxapi.event.EventListenerRegistry;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Interface for plugins written in a JVM language.
+ */
+public interface JvmPlugin {
+
+    /**
+     * The plugin should register its event listeners in this context.
+     *
+     * @param registry allows a plugin to register event listeners.
+     *                 When an event is fired, the listeners registered to listen to the given event type will be invoked.
+     */
+    void initListeners(@NotNull EventListenerRegistry registry);
+
+}
diff --git a/src/main/java/me/mikex86/veloxapi/region/Region.java b/src/main/java/me/mikex86/veloxapi/region/Region.java
new file mode 100644
index 0000000..81fb8bf
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/region/Region.java
@@ -0,0 +1,17 @@
+package me.mikex86.veloxapi.region;
+
+import net.minecraft.entity.Entity;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a region of independent, loaded chunks that do not border any loaded other chunks.
+ */
+public interface Region {
+
+    /**
+     * @return an iterable of the entities of the region.
+     */
+    @NotNull
+    Iterable<Entity> entities();
+
+}
diff --git a/src/main/java/me/mikex86/veloxapi/threading/EntityThreadGuard.java b/src/main/java/me/mikex86/veloxapi/threading/EntityThreadGuard.java
new file mode 100644
index 0000000..46b761e
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/threading/EntityThreadGuard.java
@@ -0,0 +1,40 @@
+package me.mikex86.veloxapi.threading;
+
+import me.mikex86.veloxapi.game.GameTick;
+import me.mikex86.veloxapi.threading.exception.ThreadContextException;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.BlockPos;
+import org.jetbrains.annotations.NotNull;
+
+public class EntityThreadGuard<T extends Entity> implements ThreadGuard<T> {
+
+    @NotNull
+    private final T value;
+
+    public EntityThreadGuard(@NotNull T value) {
+        this.value = value;
+    }
+
+    @NotNull
+    @Override
+    public T getValue() {
+        Thread thread = Thread.currentThread();
+        if (!GameTick.isThreadAuthorizedForRegion(this, thread)) {
+            throw new ThreadContextException("Cannot access guarded value from unauthorized thread.");
+        }
+        return value;
+    }
+
+    public int getEntityId() {
+        return value.getId();
+    }
+
+    public int getWorldId() {
+        // This is unique as World does not override it.
+        return value.level.getWorldId();
+    }
+
+    public BlockPos getWeaklyConsistentPosition() {
+        return value.blockPosition();
+    }
+}
diff --git a/src/main/java/me/mikex86/veloxapi/threading/ThreadGuard.java b/src/main/java/me/mikex86/veloxapi/threading/ThreadGuard.java
new file mode 100644
index 0000000..ae08e39
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/threading/ThreadGuard.java
@@ -0,0 +1,10 @@
+package me.mikex86.veloxapi.threading;
+
+import org.jetbrains.annotations.NotNull;
+
+public interface ThreadGuard<T> {
+
+    @NotNull
+    T getValue();
+
+}
diff --git a/src/main/java/me/mikex86/veloxapi/threading/WorldThreadGuard.java b/src/main/java/me/mikex86/veloxapi/threading/WorldThreadGuard.java
new file mode 100644
index 0000000..ee36770
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/threading/WorldThreadGuard.java
@@ -0,0 +1,31 @@
+package me.mikex86.veloxapi.threading;
+
+import me.mikex86.veloxapi.game.GameTick;
+import me.mikex86.veloxapi.threading.exception.ThreadContextException;
+import net.minecraft.world.World;
+import org.jetbrains.annotations.NotNull;
+
+public class WorldThreadGuard<T extends World> implements ThreadGuard<T> {
+
+    @NotNull
+    private final T value;
+
+    public WorldThreadGuard(@NotNull T value) {
+        this.value = value;
+    }
+
+    @NotNull
+    @Override
+    public T getValue() {
+        Thread thread = Thread.currentThread();
+        if (!GameTick.isThreadAuthorizedForGlobalAccess(this, thread)) {
+            throw new ThreadContextException("Cannot access guarded value from unauthorized thread.");
+        }
+        return this.value;
+    }
+
+    public int getWorldId() {
+        return this.value.getWorldId();
+    }
+
+}
diff --git a/src/main/java/me/mikex86/veloxapi/threading/exception/ThreadContextException.java b/src/main/java/me/mikex86/veloxapi/threading/exception/ThreadContextException.java
new file mode 100644
index 0000000..2b6cced
--- /dev/null
+++ b/src/main/java/me/mikex86/veloxapi/threading/exception/ThreadContextException.java
@@ -0,0 +1,13 @@
+package me.mikex86.veloxapi.threading.exception;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Thrown when an operation is performed that is illegal from the calling thread
+ */
+public class ThreadContextException extends RuntimeException {
+
+    public ThreadContextException(@NotNull String message) {
+        super(message);
+    }
+}
diff --git a/build/mcp_diff_src/net/minecraft/advancements/criterion/AbstractCriterionTrigger.java b/src/main/java/net/minecraft/advancements/criterion/AbstractCriterionTrigger.java
index 0df6360..5a35f0c 100644
--- a/build/mcp_diff_src/net/minecraft/advancements/criterion/AbstractCriterionTrigger.java
+++ b/src/main/java/net/minecraft/advancements/criterion/AbstractCriterionTrigger.java
@@ -15,11 +15,15 @@ import net.minecraft.loot.ConditionArrayParser;
 import net.minecraft.loot.LootContext;
 
 public abstract class AbstractCriterionTrigger<T extends CriterionInstance> implements ICriterionTrigger<T> {
-   private final Map<PlayerAdvancements, Set<ICriterionTrigger.Listener<T>>> players = Maps.newIdentityHashMap();
+   // Velox start: player advancement map threadsafe
+   private final Map<PlayerAdvancements, Set<ICriterionTrigger.Listener<T>>> players = Maps.newConcurrentMap();
+   // Velox end
 
    public final void addPlayerListener(PlayerAdvancements p_192165_1_, ICriterionTrigger.Listener<T> p_192165_2_) {
       this.players.computeIfAbsent(p_192165_1_, (p_227072_0_) -> {
-         return Sets.newHashSet();
+         // Velox start: players advancement map trigger veloxapi.listener set threadsafe
+         return Sets.newConcurrentHashSet();
+         // Velox end
       }).add(p_192165_2_);
    }
 
diff --git a/build/mcp_diff_src/net/minecraft/command/impl/FillCommand.java b/src/main/java/net/minecraft/command/impl/FillCommand.java
index f4b569e..d0b6792 100644
--- a/build/mcp_diff_src/net/minecraft/command/impl/FillCommand.java
+++ b/src/main/java/net/minecraft/command/impl/FillCommand.java
@@ -56,40 +56,37 @@ public class FillCommand {
    }
 
    private static int fillBlocks(CommandSource p_198463_0_, MutableBoundingBox p_198463_1_, BlockStateInput p_198463_2_, FillCommand.Mode p_198463_3_, @Nullable Predicate<CachedBlockInfo> p_198463_4_) throws CommandSyntaxException {
-      int i = p_198463_1_.getXSpan() * p_198463_1_.getYSpan() * p_198463_1_.getZSpan();
-      if (i > 32768) {
-         throw ERROR_AREA_TOO_LARGE.create(32768, i);
-      } else {
-         List<BlockPos> list = Lists.newArrayList();
-         ServerWorld serverworld = p_198463_0_.getLevel();
-         int j = 0;
+      // Velox start: Remove fill block limit
+      List<BlockPos> list = Lists.newArrayList();
+      ServerWorld serverworld = p_198463_0_.getLevel();
+      int j = 0;
 
-         for(BlockPos blockpos : BlockPos.betweenClosed(p_198463_1_.x0, p_198463_1_.y0, p_198463_1_.z0, p_198463_1_.x1, p_198463_1_.y1, p_198463_1_.z1)) {
-            if (p_198463_4_ == null || p_198463_4_.test(new CachedBlockInfo(serverworld, blockpos, true))) {
-               BlockStateInput blockstateinput = p_198463_3_.filter.filter(p_198463_1_, blockpos, p_198463_2_, serverworld);
-               if (blockstateinput != null) {
-                  TileEntity tileentity = serverworld.getBlockEntity(blockpos);
-                  IClearable.tryClear(tileentity);
-                  if (blockstateinput.place(serverworld, blockpos, 2)) {
-                     list.add(blockpos.immutable());
-                     ++j;
-                  }
+      for(BlockPos blockpos : BlockPos.betweenClosed(p_198463_1_.x0, p_198463_1_.y0, p_198463_1_.z0, p_198463_1_.x1, p_198463_1_.y1, p_198463_1_.z1)) {
+         if (p_198463_4_ == null || p_198463_4_.test(new CachedBlockInfo(serverworld, blockpos, true))) {
+            BlockStateInput blockstateinput = p_198463_3_.filter.filter(p_198463_1_, blockpos, p_198463_2_, serverworld);
+            if (blockstateinput != null) {
+               TileEntity tileentity = serverworld.getBlockEntity(blockpos);
+               IClearable.tryClear(tileentity);
+               if (blockstateinput.place(serverworld, blockpos, 2)) {
+                  list.add(blockpos.immutable());
+                  ++j;
                }
             }
          }
+      }
 
-         for(BlockPos blockpos1 : list) {
-            Block block = serverworld.getBlockState(blockpos1).getBlock();
-            serverworld.blockUpdated(blockpos1, block);
-         }
+      for(BlockPos blockpos1 : list) {
+         Block block = serverworld.getBlockState(blockpos1).getBlock();
+         serverworld.blockUpdated(blockpos1, block);
+      }
 
-         if (j == 0) {
-            throw ERROR_FAILED.create();
-         } else {
-            p_198463_0_.sendSuccess(new TranslationTextComponent("commands.fill.success", j), true);
-            return j;
-         }
+      if (j == 0) {
+         throw ERROR_FAILED.create();
+      } else {
+         p_198463_0_.sendSuccess(new TranslationTextComponent("commands.fill.success", j), true);
+         return j;
       }
+      // Velox end
    }
 
    static enum Mode {
diff --git a/build/mcp_diff_src/net/minecraft/entity/item/TNTEntity.java b/src/main/java/net/minecraft/entity/item/TNTEntity.java
index f570fa0..437318c 100644
--- a/build/mcp_diff_src/net/minecraft/entity/item/TNTEntity.java
+++ b/src/main/java/net/minecraft/entity/item/TNTEntity.java
@@ -22,6 +22,9 @@ public class TNTEntity extends Entity {
    @Nullable
    private LivingEntity owner;
    private int life = 80;
+   // Velox start: TNTEntity#exploded state
+   public boolean exploded = false;
+   // Velox end
 
    public TNTEntity(EntityType<? extends TNTEntity> p_i50216_1_, World p_i50216_2_) {
       super(p_i50216_1_, p_i50216_2_);
@@ -79,8 +82,9 @@ public class TNTEntity extends Entity {
    }
 
    private void explode() {
-      float f = 4.0F;
-      this.level.explode(this, this.getX(), this.getY(0.0625D), this.getZ(), 4.0F, Explosion.Mode.BREAK);
+      // Velox start: set exploded to true on explode()
+      this.exploded = true;
+      // Velox end
    }
 
    protected void addAdditionalSaveData(CompoundNBT p_213281_1_) {
diff --git a/build/mcp_diff_src/net/minecraft/entity/player/ServerPlayerEntity.java b/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
index 339b18a..1a31073 100644
--- a/build/mcp_diff_src/net/minecraft/entity/player/ServerPlayerEntity.java
+++ b/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
@@ -3,13 +3,9 @@ package net.minecraft.entity.player;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Optional;
-import java.util.OptionalInt;
-import java.util.Random;
-import java.util.UUID;
+
+import java.util.*;
+import java.util.concurrent.LinkedBlockingDeque;
 import javax.annotation.Nullable;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.advancements.PlayerAdvancements;
@@ -136,7 +132,9 @@ public class ServerPlayerEntity extends PlayerEntity implements IContainerListen
    public ServerPlayNetHandler connection;
    public final MinecraftServer server;
    public final PlayerInteractionManager gameMode;
-   private final List<Integer> entitiesToRemove = Lists.newLinkedList();
+   // Velox start: entitiesToRemove threadsafe
+   private final Queue<Integer> entitiesToRemove = new LinkedBlockingDeque<>();
+   // Velox end
    private final PlayerAdvancements advancements;
    private final ServerStatisticsManager stats;
    private float lastRecordedHealthAndAbsorption = Float.MIN_VALUE;
diff --git a/build/mcp_diff_src/net/minecraft/network/play/ServerPlayNetHandler.java b/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java
index 7f165cd..a25d623 100644
--- a/build/mcp_diff_src/net/minecraft/network/play/ServerPlayNetHandler.java
+++ b/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java
@@ -19,6 +19,9 @@ import java.util.function.Consumer;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.veloxapiimpl.event.EventDispatcher;
+import me.mikex86.veloxapi.event.impl.PlayerChatEvent;
 import net.minecraft.advancements.Advancement;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.block.AbstractBlock;
@@ -1093,7 +1096,9 @@ public class ServerPlayNetHandler implements IServerPlayNetHandler {
                return;
             }
          }
-
+         // Velox start: fire PlayerChatEvent
+         EventDispatcher.INSTANCE.fire(new PlayerChatEvent(p_244548_1_, this.player));
+         // Velox end
          if (p_244548_1_.startsWith("/")) {
             this.handleCommand(p_244548_1_);
          } else {
diff --git a/build/mcp_diff_src/net/minecraft/profiler/Profiler.java b/src/main/java/net/minecraft/profiler/Profiler.java
index 11d9594..b61b7fc 100644
--- a/build/mcp_diff_src/net/minecraft/profiler/Profiler.java
+++ b/src/main/java/net/minecraft/profiler/Profiler.java
@@ -35,6 +35,9 @@ public class Profiler implements IResultableProfiler {
    @Nullable
    private Profiler.Section currentEntry;
    private final boolean warn;
+   // Velox start: Profiler thread-aware
+   private Thread drivingThread;
+   // Velox end
 
    public Profiler(LongSupplier p_i231482_1_, IntSupplier p_i231482_2_, boolean p_i231482_3_) {
       this.startTimeNano = p_i231482_1_.getAsLong();
@@ -48,6 +51,9 @@ public class Profiler implements IResultableProfiler {
       if (this.started) {
          LOGGER.error("Profiler tick already started - missing endTick()?");
       } else {
+         // Velox start: Profiler set driving thread
+         this.drivingThread = Thread.currentThread();
+         // Velox end
          this.started = true;
          this.path = "";
          this.paths.clear();
@@ -74,6 +80,11 @@ public class Profiler implements IResultableProfiler {
       if (!this.started) {
          LOGGER.error("Cannot push '{}' to profiler if profiler tick hasn't started - missing startTick()?", (Object)p_76320_1_);
       } else {
+         // Velox start: Check current thread on profiler calls
+         if (Thread.currentThread() != this.drivingThread){
+            return;
+         }
+         // Velox end
          if (!this.path.isEmpty()) {
             this.path = this.path + '\u001e';
          }
@@ -95,6 +106,11 @@ public class Profiler implements IResultableProfiler {
       } else if (this.startTimes.isEmpty()) {
          LOGGER.error("Tried to pop one too many times! Mismatched push() and pop()?");
       } else {
+         // Velox start: Check current thread on profiler calls
+         if (Thread.currentThread() != this.drivingThread){
+            return;
+         }
+         // Velox end
          long i = Util.getNanos();
          long j = this.startTimes.removeLong(this.startTimes.size() - 1);
          this.paths.remove(this.paths.size() - 1);
@@ -137,10 +153,20 @@ public class Profiler implements IResultableProfiler {
    }
 
    public void incrementCounter(String p_230035_1_) {
+      // Velox start: Check current thread on profiler calls
+      if (Thread.currentThread() != this.drivingThread){
+         return;
+      }
+      // Velox end
       this.getCurrentEntry().counters.addTo(p_230035_1_, 1L);
    }
 
    public void incrementCounter(Supplier<String> p_230036_1_) {
+      // Velox start: Check current thread on profiler calls
+      if (Thread.currentThread() != this.drivingThread){
+         return;
+      }
+      // Velox end
       this.getCurrentEntry().counters.addTo(p_230036_1_.get(), 1L);
    }
 
diff --git a/build/mcp_diff_src/net/minecraft/resources/IResourceManagerReloadListener.java b/src/main/java/net/minecraft/resources/IResourceManagerReloadListener.java
index 2f153b6..ba0bad6 100644
--- a/build/mcp_diff_src/net/minecraft/resources/IResourceManagerReloadListener.java
+++ b/src/main/java/net/minecraft/resources/IResourceManagerReloadListener.java
@@ -9,7 +9,7 @@ public interface IResourceManagerReloadListener extends IFutureReloadListener {
    default CompletableFuture<Void> reload(IFutureReloadListener.IStage p_215226_1_, IResourceManager p_215226_2_, IProfiler p_215226_3_, IProfiler p_215226_4_, Executor p_215226_5_, Executor p_215226_6_) {
       return p_215226_1_.wait(Unit.INSTANCE).thenRunAsync(() -> {
          p_215226_4_.startTick();
-         p_215226_4_.push("listener");
+         p_215226_4_.push("me/mikex86/veloxapi/event");
          this.onResourceManagerReload(p_215226_2_);
          p_215226_4_.pop();
          p_215226_4_.endTick();
diff --git a/build/mcp_diff_src/net/minecraft/server/CustomServerBossInfo.java b/src/main/java/net/minecraft/server/CustomServerBossInfo.java
index 0cc4ce8..85ecca1 100644
--- a/build/mcp_diff_src/net/minecraft/server/CustomServerBossInfo.java
+++ b/src/main/java/net/minecraft/server/CustomServerBossInfo.java
@@ -19,7 +19,10 @@ import net.minecraft.world.server.ServerBossInfo;
 
 public class CustomServerBossInfo extends ServerBossInfo {
    private final ResourceLocation id;
-   private final Set<UUID> players = Sets.newHashSet();
+   // Velox start: players threadsafe
+   // Reason: players modified concurrently on player tracker (stop/startSeenByPlayer)
+   private final Set<UUID> players = Sets.newConcurrentHashSet();
+   // Velox end
    private int value;
    private int max = 100;
 
diff --git a/build/mcp_diff_src/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 27796f3..ec280aa 100644
--- a/build/mcp_diff_src/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -17,6 +17,7 @@ import java.util.function.BooleanSupplier;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
 import joptsimple.OptionSpec;
+import me.mikex86.velox.veloxapiimpl.server.VeloxServer;
 import net.minecraft.command.Commands;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.nbt.INBT;
@@ -154,7 +155,9 @@ public class Main {
          saveformat$levelsave.saveDataTag(dynamicregistries$impl, iserverconfiguration);
          IServerConfiguration iserverconfiguration1 = iserverconfiguration;
          final DedicatedServer dedicatedserver = MinecraftServer.spin((p_240762_16_) -> {
-            DedicatedServer dedicatedserver1 = new DedicatedServer(p_240762_16_, dynamicregistries$impl, saveformat$levelsave, resourcepacklist, datapackregistries, iserverconfiguration1, serverpropertiesprovider, DataFixesManager.getDataFixer(), minecraftsessionservice, gameprofilerepository, playerprofilecache, LoggingChunkStatusListener::new);
+            // Velox start: Use VeloxServer
+            DedicatedServer dedicatedserver1 = new VeloxServer(p_240762_16_, dynamicregistries$impl, saveformat$levelsave, resourcepacklist, datapackregistries, iserverconfiguration1, serverpropertiesprovider, DataFixesManager.getDataFixer(), minecraftsessionservice, gameprofilerepository, playerprofilecache, LoggingChunkStatusListener::new);
+            // Velox end
             dedicatedserver1.setSingleplayerName(optionset.valueOf(optionspec8));
             dedicatedserver1.setPort(optionset.valueOf(optionspec11));
             dedicatedserver1.setDemo(optionset.has(optionspec2));
diff --git a/build/mcp_diff_src/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 746db22..89461e7 100644
--- a/build/mcp_diff_src/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -44,12 +44,16 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+
+import me.mikex86.velox.utils.threading.ThreadingUtil;
 import net.minecraft.advancements.AdvancementManager;
 import net.minecraft.advancements.FunctionManager;
 import net.minecraft.block.Block;
@@ -814,34 +818,62 @@ public abstract class MinecraftServer extends RecursiveEventLoop<TickDelayedTask
       this.profiler.pop();
    }
 
+   // Velox start: Declare dimension tick driving executor and numDimensionDriverThreads
+   private ExecutorService dimensionTickExecutor = null;
+   private int numDimensionDriverThreads = -1;
+   // Velox end
+
    protected void tickChildren(BooleanSupplier p_71190_1_) {
       this.profiler.push("commandFunctions");
       this.getFunctions().tick();
       this.profiler.popPush("levels");
-
-      for(ServerWorld serverworld : this.getAllLevels()) {
-         this.profiler.push(() -> {
-            return serverworld + " " + serverworld.dimension().location();
+      // Velox start: parallelize dimension ticking
+      Collection<ServerWorld> allLevels = Lists.newArrayList(this.getAllLevels());
+      int nNeededDimensionDriverThreads = Math.min(Runtime.getRuntime().availableProcessors(), allLevels.size());
+      if (this.dimensionTickExecutor == null || this.numDimensionDriverThreads != nNeededDimensionDriverThreads) {
+         this.dimensionTickExecutor = ThreadingUtil.newWorkerPool("DimensionTickDriver", nNeededDimensionDriverThreads, null);
+         this.numDimensionDriverThreads = nNeededDimensionDriverThreads;
+      }
+      CountDownLatch latch = new CountDownLatch(allLevels.size());
+      for(ServerWorld serverworld : allLevels) {
+         this.dimensionTickExecutor.execute(() -> {
+            try {
+               try {
+                  this.profiler.push(() -> {
+                     return serverworld + " " + serverworld.dimension().location();
+                  });
+                  if (this.tickCount % 20 == 0) {
+                     this.profiler.push("timeSync");
+                     this.playerList.broadcastAll(new SUpdateTimePacket(serverworld.getGameTime(), serverworld.getDayTime(), serverworld.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)), serverworld.dimension());
+                     this.profiler.pop();
+                  }
+
+                  this.profiler.push("tick");
+
+                  try {
+                     serverworld.tick(p_71190_1_);
+                  } catch (Throwable throwable) {
+                     CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+                     serverworld.fillReportDetails(crashreport);
+                     throw new ReportedException(crashreport);
+                  }
+
+                  this.profiler.pop();
+                  this.profiler.pop();
+               } catch (Exception e) {
+                  e.printStackTrace();
+               }
+            } finally {
+               latch.countDown();
+            }
          });
-         if (this.tickCount % 20 == 0) {
-            this.profiler.push("timeSync");
-            this.playerList.broadcastAll(new SUpdateTimePacket(serverworld.getGameTime(), serverworld.getDayTime(), serverworld.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)), serverworld.dimension());
-            this.profiler.pop();
-         }
-
-         this.profiler.push("tick");
-
-         try {
-            serverworld.tick(p_71190_1_);
-         } catch (Throwable throwable) {
-            CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
-            serverworld.fillReportDetails(crashreport);
-            throw new ReportedException(crashreport);
-         }
-
-         this.profiler.pop();
-         this.profiler.pop();
       }
+      try {
+         latch.await();
+      } catch (InterruptedException e) {
+         e.printStackTrace();
+      }
+      // Velox end
 
       this.profiler.popPush("connection");
       this.getConnection().tick();
@@ -894,9 +926,12 @@ public abstract class MinecraftServer extends RecursiveEventLoop<TickDelayedTask
       return this.levels.keySet();
    }
 
-   public Iterable<ServerWorld> getAllLevels() {
+   // Velox start: make getAllLevels
+   // Needed for: parallelize server dimensions
+   public Collection<ServerWorld> getAllLevels() {
       return this.levels.values();
    }
+   // Velox end
 
    public String getServerVersion() {
       return SharedConstants.getCurrentVersion().getName();
diff --git a/build/mcp_diff_src/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index e2a7184..f8b9c43 100644
--- a/build/mcp_diff_src/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -172,12 +172,12 @@ public class DedicatedServer extends MinecraftServer implements IServer {
          }
 
          if (serverproperties.enableQuery) {
-            LOGGER.info("Starting GS4 status listener");
+            LOGGER.info("Starting GS4 status veloxapi.listener");
             this.queryThreadGs4 = QueryThread.create(this);
          }
 
          if (serverproperties.enableRcon) {
-            LOGGER.info("Starting remote control listener");
+            LOGGER.info("Starting remote control veloxapi.listener");
             this.rconThread = MainThread.create(this);
          }
 
diff --git a/build/mcp_diff_src/net/minecraft/util/ClassInheritanceMultiMap.java b/src/main/java/net/minecraft/util/ClassInheritanceMultiMap.java
index 0ba4fdf..cf5f6bd 100644
--- a/build/mcp_diff_src/net/minecraft/util/ClassInheritanceMultiMap.java
+++ b/src/main/java/net/minecraft/util/ClassInheritanceMultiMap.java
@@ -4,6 +4,8 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import me.mikex86.velox.utils.CollectionUtils;
+
 import java.util.AbstractCollection;
 import java.util.Collection;
 import java.util.Collections;
@@ -11,12 +13,16 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.stream.Collectors;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
    private final Map<Class<?>, List<T>> byClass = Maps.newHashMap();
    private final Class<T> baseClass;
    private final List<T> allInstances = Lists.newArrayList();
+   // Velox start: ClassInheritanceMultiMap#lock
+   private final ReadWriteLock lock = new ReentrantReadWriteLock();
+   // Velox end
 
    public ClassInheritanceMultiMap(Class<T> p_i45909_1_) {
       this.baseClass = p_i45909_1_;
@@ -24,6 +30,8 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
    }
 
    public boolean add(T p_add_1_) {
+      // Velox start: ClassInheritanceMultiMap#add threadsafe
+      this.lock.writeLock().lock();
       boolean flag = false;
 
       for(Entry<Class<?>, List<T>> entry : this.byClass.entrySet()) {
@@ -31,11 +39,14 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
             flag |= entry.getValue().add(p_add_1_);
          }
       }
-
+      this.lock.writeLock().unlock();
+      // Velox end
       return flag;
    }
 
    public boolean remove(Object p_remove_1_) {
+      // Velox start: ClassInheritanceMultiMap#remove threadsafe
+      this.lock.writeLock().lock();
       boolean flag = false;
 
       for(Entry<Class<?>, List<T>> entry : this.byClass.entrySet()) {
@@ -44,7 +55,8 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
             flag |= list.remove(p_remove_1_);
          }
       }
-
+      this.lock.writeLock().unlock();
+      // Velox end
       return flag;
    }
 
@@ -53,25 +65,58 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
    }
 
    public <S> Collection<S> find(Class<S> p_219790_1_) {
+      // Velox start: ClassInheritanceMultiMap#find threadsafe
       if (!this.baseClass.isAssignableFrom(p_219790_1_)) {
          throw new IllegalArgumentException("Don't know how to search for " + p_219790_1_);
       } else {
-         List<T> list = this.byClass.computeIfAbsent(p_219790_1_, (p_219791_1_) -> {
-            return this.allInstances.stream().filter(p_219791_1_::isInstance).collect(Collectors.toList());
-         });
-         return (Collection<S>) Collections.unmodifiableCollection(list);
+         this.lock.readLock().lock();
+         List<S> classList = (List<S>) this.byClass.get(p_219790_1_);
+         this.lock.readLock().unlock();
+         if (classList == null) {
+            this.lock.writeLock().lock();
+            classList = buildClassList(p_219790_1_);
+            this.byClass.put(p_219790_1_, (List<T>) classList);
+            this.lock.writeLock().unlock();
+         }
+         return CollectionUtils.immutableCopy(classList);
+      }
+      // Velox end
+   }
+
+   // Velox start: ClassInheritanceMultiMap#buildClassList
+   private <S> List<S> buildClassList(Class<S> clazz) {
+      List<S> classList = Lists.newArrayList();
+      for (T instance : this.allInstances) {
+         if (clazz.isInstance(instance)) {
+            classList.add((S) instance);
+         }
       }
+      return classList;
    }
+   // Velox end
 
    public Iterator<T> iterator() {
-      return (Iterator<T>)(this.allInstances.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(this.allInstances.iterator()));
+      // Velox start: ClassInheritanceMultiMap#iterator threadsafe
+      List<T> allInstances = getAllInstances();
+      return allInstances.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(allInstances.iterator());
+      // Velox end
    }
 
    public List<T> getAllInstances() {
-      return ImmutableList.copyOf(this.allInstances);
+      // Velox start: ClassInheritanceMultiMap#getAllInstances threadsafe
+      this.lock.readLock().lock();
+      ImmutableList<T> immutableCopy = ImmutableList.copyOf(this.allInstances);
+      this.lock.readLock().unlock();
+      return immutableCopy;
+      // Velox end
    }
 
    public int size() {
-      return this.allInstances.size();
+      // Velox start: ClassInheritanceMultiMap#size threadsafe
+      this.lock.readLock().lock();
+      int size = this.allInstances.size();
+      this.lock.readLock().unlock();
+      return size;
+      // Velox end
    }
 }
diff --git a/build/mcp_diff_src/net/minecraft/util/concurrent/ThreadTaskExecutor.java b/src/main/java/net/minecraft/util/concurrent/ThreadTaskExecutor.java
index b2dec07..93d4619 100644
--- a/build/mcp_diff_src/net/minecraft/util/concurrent/ThreadTaskExecutor.java
+++ b/src/main/java/net/minecraft/util/concurrent/ThreadTaskExecutor.java
@@ -4,6 +4,7 @@ import com.google.common.collect.Queues;
 import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
@@ -16,7 +17,9 @@ public abstract class ThreadTaskExecutor<R extends Runnable> implements ITaskExe
    private final String name;
    private static final Logger LOGGER = LogManager.getLogger();
    private final Queue<R> pendingRunnables = Queues.newConcurrentLinkedQueue();
-   private int blockingCount;
+   // Velox start: blockingCount atomic
+   private final AtomicInteger blockingCount = new AtomicInteger();
+   // Velox end
 
    protected ThreadTaskExecutor(String p_i50403_1_) {
       this.name = p_i50403_1_;
@@ -100,19 +103,21 @@ public abstract class ThreadTaskExecutor<R extends Runnable> implements ITaskExe
    }
 
    protected boolean pollTask() {
-      R r = this.pendingRunnables.peek();
+      // Velox start: fix mojang autism. They seem to never have heard of the method poll()
+      R r = this.pendingRunnables.poll();
       if (r == null) {
          return false;
-      } else if (this.blockingCount == 0 && !this.shouldRun(r)) {
+      } else if (this.blockingCount.get() == 0 && !this.shouldRun(r)) {
          return false;
       } else {
-         this.doRunTask(this.pendingRunnables.remove());
+         this.doRunTask(r);
          return true;
       }
+      // Velox end
    }
 
    public void managedBlock(BooleanSupplier p_213161_1_) {
-      ++this.blockingCount;
+      this.blockingCount.incrementAndGet();
 
       try {
          while(!p_213161_1_.getAsBoolean()) {
@@ -121,7 +126,7 @@ public abstract class ThreadTaskExecutor<R extends Runnable> implements ITaskExe
             }
          }
       } finally {
-         --this.blockingCount;
+         this.blockingCount.decrementAndGet();
       }
 
    }
diff --git a/build/mcp_diff_src/net/minecraft/util/palette/PalettedContainer.java b/src/main/java/net/minecraft/util/palette/PalettedContainer.java
index 929a1e5..401bb26 100644
--- a/build/mcp_diff_src/net/minecraft/util/palette/PalettedContainer.java
+++ b/src/main/java/net/minecraft/util/palette/PalettedContainer.java
@@ -35,17 +35,9 @@ public class PalettedContainer<T> implements IResizeCallback<T> {
    private final ReentrantLock lock = new ReentrantLock();
 
    public void acquire() {
-      if (this.lock.isLocked() && !this.lock.isHeldByCurrentThread()) {
-         String s = Thread.getAllStackTraces().keySet().stream().filter(Objects::nonNull).map((p_210458_0_) -> {
-            return p_210458_0_.getName() + ": \n\tat " + (String)Arrays.stream(p_210458_0_.getStackTrace()).map(Object::toString).collect(Collectors.joining("\n\tat "));
-         }).collect(Collectors.joining("\n"));
-         CrashReport crashreport = new CrashReport("Writing into PalettedContainer from multiple threads", new IllegalStateException());
-         CrashReportCategory crashreportcategory = crashreport.addCategory("Thread dumps");
-         crashreportcategory.setDetail("Thread dumps", s);
-         throw new ReportedException(crashreport);
-      } else {
-         this.lock.lock();
-      }
+      // Velox start: Make PalettedContainer threadsafe
+      this.lock.lock();
+      // Velox end
    }
 
    public void release() {
diff --git a/build/mcp_diff_src/net/minecraft/village/PointOfInterestManager.java b/src/main/java/net/minecraft/village/PointOfInterestManager.java
index de4b6ec..83cf9df 100644
--- a/build/mcp_diff_src/net/minecraft/village/PointOfInterestManager.java
+++ b/src/main/java/net/minecraft/village/PointOfInterestManager.java
@@ -18,6 +18,8 @@ import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
+
+import me.mikex86.velox.utils.StreamUtils;
 import net.minecraft.block.BlockState;
 import net.minecraft.util.SectionDistanceGraph;
 import net.minecraft.util.Util;
@@ -39,69 +41,94 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
       this.distanceTracker = new PointOfInterestManager.DistanceGraph();
    }
 
-   public void add(BlockPos p_219135_1_, PointOfInterestType p_219135_2_) {
+   // Velox start: PointOfInterestManager#add threadsafe
+   public synchronized void add(BlockPos p_219135_1_, PointOfInterestType p_219135_2_) {
       this.getOrCreate(SectionPos.of(p_219135_1_).asLong()).add(p_219135_1_, p_219135_2_);
    }
+   // Velox end
+
 
-   public void remove(BlockPos p_219140_1_) {
+   // Velox start: PointOfInterestManager#remove threadsafe
+   public synchronized void remove(BlockPos p_219140_1_) {
       this.getOrCreate(SectionPos.of(p_219140_1_).asLong()).remove(p_219140_1_);
    }
+   // Velox end
+
 
-   public long getCountInRange(Predicate<PointOfInterestType> p_219145_1_, BlockPos p_219145_2_, int p_219145_3_, PointOfInterestManager.Status p_219145_4_) {
+   // Velox start: PointOfInterestManager#getCountInRange threadsafe
+   public synchronized long getCountInRange(Predicate<PointOfInterestType> p_219145_1_, BlockPos p_219145_2_, int p_219145_3_, PointOfInterestManager.Status p_219145_4_) {
       return this.getInRange(p_219145_1_, p_219145_2_, p_219145_3_, p_219145_4_).count();
    }
+   // Velox end
 
-   public boolean existsAtPosition(PointOfInterestType p_234135_1_, BlockPos p_234135_2_) {
+   // Velox start: PointOfInterestManager#existsAtPosition threadsafe
+   public synchronized boolean existsAtPosition(PointOfInterestType p_234135_1_, BlockPos p_234135_2_) {
       Optional<PointOfInterestType> optional = this.getOrCreate(SectionPos.of(p_234135_2_).asLong()).getType(p_234135_2_);
       return optional.isPresent() && optional.get().equals(p_234135_1_);
    }
+   // Velox end
 
-   public Stream<PointOfInterest> getInSquare(Predicate<PointOfInterestType> p_226353_1_, BlockPos p_226353_2_, int p_226353_3_, PointOfInterestManager.Status p_226353_4_) {
+   // Velox start: PointOfInterestManager#getInSquare threadsafe
+   public synchronized Stream<PointOfInterest> getInSquare(Predicate<PointOfInterestType> p_226353_1_, BlockPos p_226353_2_, int p_226353_3_, PointOfInterestManager.Status p_226353_4_) {
       int i = Math.floorDiv(p_226353_3_, 16) + 1;
-      return ChunkPos.rangeClosed(new ChunkPos(p_226353_2_), i).flatMap((p_226350_3_) -> {
+      return StreamUtils.prefetch(ChunkPos.rangeClosed(new ChunkPos(p_226353_2_), i).flatMap((p_226350_3_) -> {
          return this.getInChunk(p_226353_1_, p_226350_3_, p_226353_4_);
       }).filter((p_242322_2_) -> {
          BlockPos blockpos = p_242322_2_.getPos();
          return Math.abs(blockpos.getX() - p_226353_2_.getX()) <= p_226353_3_ && Math.abs(blockpos.getZ() - p_226353_2_.getZ()) <= p_226353_3_;
-      });
+      }));
    }
+   // Velox end
 
-   public Stream<PointOfInterest> getInRange(Predicate<PointOfInterestType> p_219146_1_, BlockPos p_219146_2_, int p_219146_3_, PointOfInterestManager.Status p_219146_4_) {
+   // Velox start: PointOfInterestManager#getInRange threadsafe
+   public synchronized Stream<PointOfInterest> getInRange(Predicate<PointOfInterestType> p_219146_1_, BlockPos p_219146_2_, int p_219146_3_, PointOfInterestManager.Status p_219146_4_) {
       int i = p_219146_3_ * p_219146_3_;
-      return this.getInSquare(p_219146_1_, p_219146_2_, p_219146_3_, p_219146_4_).filter((p_226349_2_) -> {
+      return StreamUtils.prefetch(this.getInSquare(p_219146_1_, p_219146_2_, p_219146_3_, p_219146_4_).filter((p_226349_2_) -> {
          return p_226349_2_.getPos().distSqr(p_219146_2_) <= (double)i;
-      });
+      }));
    }
+   // Velox end
 
-   public Stream<PointOfInterest> getInChunk(Predicate<PointOfInterestType> p_219137_1_, ChunkPos p_219137_2_, PointOfInterestManager.Status p_219137_3_) {
-      return IntStream.range(0, 16).boxed().map((p_219149_2_) -> {
+   // Velox start: PointOfInterestManager#getInChunk threadsafe
+   public synchronized Stream<PointOfInterest> getInChunk(Predicate<PointOfInterestType> p_219137_1_, ChunkPos p_219137_2_, PointOfInterestManager.Status p_219137_3_) {
+      return StreamUtils.prefetch(IntStream.range(0, 16).boxed().map((p_219149_2_) -> {
          return this.getOrLoad(SectionPos.of(p_219137_2_, p_219149_2_).asLong());
       }).filter(Optional::isPresent).flatMap((p_241393_2_) -> {
          return p_241393_2_.get().getRecords(p_219137_1_, p_219137_3_);
-      });
+      }));
    }
+   // Velox end
 
-   public Stream<BlockPos> findAll(Predicate<PointOfInterestType> p_225399_1_, Predicate<BlockPos> p_225399_2_, BlockPos p_225399_3_, int p_225399_4_, PointOfInterestManager.Status p_225399_5_) {
-      return this.getInRange(p_225399_1_, p_225399_3_, p_225399_4_, p_225399_5_).map(PointOfInterest::getPos).filter(p_225399_2_);
+   // Velox start: PointOfInterestManager#findAll threadsafe
+   public synchronized Stream<BlockPos> findAll(Predicate<PointOfInterestType> p_225399_1_, Predicate<BlockPos> p_225399_2_, BlockPos p_225399_3_, int p_225399_4_, PointOfInterestManager.Status p_225399_5_) {
+      return StreamUtils.prefetch(this.getInRange(p_225399_1_, p_225399_3_, p_225399_4_, p_225399_5_).map(PointOfInterest::getPos).filter(p_225399_2_));
    }
+   // Velox end
 
-   public Stream<BlockPos> findAllClosestFirst(Predicate<PointOfInterestType> p_242324_1_, Predicate<BlockPos> p_242324_2_, BlockPos p_242324_3_, int p_242324_4_, PointOfInterestManager.Status p_242324_5_) {
-      return this.findAll(p_242324_1_, p_242324_2_, p_242324_3_, p_242324_4_, p_242324_5_).sorted(Comparator.comparingDouble((p_242323_1_) -> {
+   // Velox start: PointOfInterestManager#findAllClosestFirst threadsafe
+   public synchronized Stream<BlockPos> findAllClosestFirst(Predicate<PointOfInterestType> p_242324_1_, Predicate<BlockPos> p_242324_2_, BlockPos p_242324_3_, int p_242324_4_, PointOfInterestManager.Status p_242324_5_) {
+      return StreamUtils.prefetch(this.findAll(p_242324_1_, p_242324_2_, p_242324_3_, p_242324_4_, p_242324_5_).sorted(Comparator.comparingDouble((p_242323_1_) -> {
          return p_242323_1_.distSqr(p_242324_3_);
-      }));
+      })));
    }
+   // Velox end
 
-   public Optional<BlockPos> find(Predicate<PointOfInterestType> p_219127_1_, Predicate<BlockPos> p_219127_2_, BlockPos p_219127_3_, int p_219127_4_, PointOfInterestManager.Status p_219127_5_) {
+   // Velox start: PointOfInterestManager#find threadsafe
+   public synchronized Optional<BlockPos> find(Predicate<PointOfInterestType> p_219127_1_, Predicate<BlockPos> p_219127_2_, BlockPos p_219127_3_, int p_219127_4_, PointOfInterestManager.Status p_219127_5_) {
       return this.findAll(p_219127_1_, p_219127_2_, p_219127_3_, p_219127_4_, p_219127_5_).findFirst();
    }
+   // Velox end
 
-   public Optional<BlockPos> findClosest(Predicate<PointOfInterestType> p_234148_1_, BlockPos p_234148_2_, int p_234148_3_, PointOfInterestManager.Status p_234148_4_) {
+   // Velox start: PointOfInterestManager#findClosest threadsafe
+   public synchronized Optional<BlockPos> findClosest(Predicate<PointOfInterestType> p_234148_1_, BlockPos p_234148_2_, int p_234148_3_, PointOfInterestManager.Status p_234148_4_) {
       return this.getInRange(p_234148_1_, p_234148_2_, p_234148_3_, p_234148_4_).map(PointOfInterest::getPos).min(Comparator.comparingDouble((p_219160_1_) -> {
          return p_219160_1_.distSqr(p_234148_2_);
       }));
    }
+   // Velox end
 
-   public Optional<BlockPos> take(Predicate<PointOfInterestType> p_219157_1_, Predicate<BlockPos> p_219157_2_, BlockPos p_219157_3_, int p_219157_4_) {
+   // Velox start: PointOfInterestManager#take threadsafe
+   public synchronized Optional<BlockPos> take(Predicate<PointOfInterestType> p_219157_1_, Predicate<BlockPos> p_219157_2_, BlockPos p_219157_3_, int p_219157_4_) {
       return this.getInRange(p_219157_1_, p_219157_3_, p_219157_4_, PointOfInterestManager.Status.HAS_SPACE).filter((p_219129_1_) -> {
          return p_219157_2_.test(p_219129_1_.getPos());
       }).findFirst().map((p_219152_0_) -> {
@@ -109,57 +136,78 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
          return p_219152_0_.getPos();
       });
    }
+   // Velox end
 
-   public Optional<BlockPos> getRandom(Predicate<PointOfInterestType> p_219163_1_, Predicate<BlockPos> p_219163_2_, PointOfInterestManager.Status p_219163_3_, BlockPos p_219163_4_, int p_219163_5_, Random p_219163_6_) {
+   // Velox start: PointOfInterestManager#getRandom threadsafe
+   public synchronized Optional<BlockPos> getRandom(Predicate<PointOfInterestType> p_219163_1_, Predicate<BlockPos> p_219163_2_, PointOfInterestManager.Status p_219163_3_, BlockPos p_219163_4_, int p_219163_5_, Random p_219163_6_) {
       List<PointOfInterest> list = this.getInRange(p_219163_1_, p_219163_4_, p_219163_5_, p_219163_3_).collect(Collectors.toList());
       Collections.shuffle(list, p_219163_6_);
       return list.stream().filter((p_234143_1_) -> {
          return p_219163_2_.test(p_234143_1_.getPos());
       }).findFirst().map(PointOfInterest::getPos);
    }
+   // Velox end
 
-   public boolean release(BlockPos p_219142_1_) {
+   // Velox start: PointOfInterestManager#release threadsafe
+   public synchronized boolean release(BlockPos p_219142_1_) {
       return this.getOrCreate(SectionPos.of(p_219142_1_).asLong()).release(p_219142_1_);
    }
+   // Velox end
 
+   // Velox start: PointOfInterestManager#exists threadsafe
    public boolean exists(BlockPos p_219138_1_, Predicate<PointOfInterestType> p_219138_2_) {
       return this.getOrLoad(SectionPos.of(p_219138_1_).asLong()).map((p_234141_2_) -> {
          return p_234141_2_.exists(p_219138_1_, p_219138_2_);
       }).orElse(false);
    }
+   // Velox end
 
-   public Optional<PointOfInterestType> getType(BlockPos p_219148_1_) {
+   // Velox start: PointOfInterestManager#getType threadsafe
+   public synchronized Optional<PointOfInterestType> getType(BlockPos p_219148_1_) {
       PointOfInterestData pointofinterestdata = this.getOrCreate(SectionPos.of(p_219148_1_).asLong());
       return pointofinterestdata.getType(p_219148_1_);
    }
+   // Velox end
 
-   public int sectionsToVillage(SectionPos p_219150_1_) {
+   // Velox start: PointOfInterestManager#sectionsToVillage threadsafe
+   public synchronized int sectionsToVillage(SectionPos p_219150_1_) {
       this.distanceTracker.runAllUpdates();
       return this.distanceTracker.getLevel(p_219150_1_.asLong());
    }
+   // Velox end
+
 
-   private boolean isVillageCenter(long p_219154_1_) {
+   // Velox start: PointOfInterestManager#isVillageCenter threadsafe
+   private synchronized boolean isVillageCenter(long p_219154_1_) {
       Optional<PointOfInterestData> optional = this.get(p_219154_1_);
       return optional == null ? false : optional.map((p_234134_0_) -> {
          return p_234134_0_.getRecords(PointOfInterestType.ALL, PointOfInterestManager.Status.IS_OCCUPIED).count() > 0L;
       }).orElse(false);
    }
+   // Velox end
 
-   public void tick(BooleanSupplier p_219115_1_) {
+   // Velox start: PointOfInterestManager#tick threadsafe
+   public synchronized void tick(BooleanSupplier p_219115_1_) {
       super.tick(p_219115_1_);
       this.distanceTracker.runAllUpdates();
    }
+   // Velox end
 
-   protected void setDirty(long p_219116_1_) {
+   // Velox start: PointOfInterestManager#setDirty threadsafe
+   protected synchronized void setDirty(long p_219116_1_) {
       super.setDirty(p_219116_1_);
       this.distanceTracker.update(p_219116_1_, this.distanceTracker.getLevelFromSource(p_219116_1_), false);
    }
+   // Velox end
 
-   protected void onSectionLoad(long p_219111_1_) {
+   // Velox start: PointOfInterestManager#onSectionLoad threadsafe
+   protected synchronized void onSectionLoad(long p_219111_1_) {
       this.distanceTracker.update(p_219111_1_, this.distanceTracker.getLevelFromSource(p_219111_1_), false);
    }
+   // Velox end
 
-   public void checkConsistencyWithBlocks(ChunkPos p_219139_1_, ChunkSection p_219139_2_) {
+   // Velox start: PointOfInterestManager#checkConsistencyWithBlocks threadsafe
+   public synchronized void checkConsistencyWithBlocks(ChunkPos p_219139_1_, ChunkSection p_219139_2_) {
       SectionPos sectionpos = SectionPos.of(p_219139_1_, p_219139_2_.bottomBlockY() >> 4);
       Util.ifElse(this.getOrLoad(sectionpos.asLong()), (p_234138_3_) -> {
          p_234138_3_.refresh((p_234145_3_) -> {
@@ -176,12 +224,16 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
 
       });
    }
+   // Velox end
 
-   private static boolean mayHavePoi(ChunkSection p_219151_0_) {
+   // Velox start: PointOfInterestManager#mayHavePoi threadsafe
+   private static synchronized boolean mayHavePoi(ChunkSection p_219151_0_) {
       return p_219151_0_.maybeHas(PointOfInterestType.ALL_STATES::contains);
    }
+   // Velox end
 
-   private void updateFromSection(ChunkSection p_219132_1_, SectionPos p_219132_2_, BiConsumer<BlockPos, PointOfInterestType> p_219132_3_) {
+   // Velox start: PointOfInterestManager#updateFromSection threadsafe
+   private synchronized void updateFromSection(ChunkSection p_219132_1_, SectionPos p_219132_2_, BiConsumer<BlockPos, PointOfInterestType> p_219132_3_) {
       p_219132_2_.blocksInside().forEach((p_234139_2_) -> {
          BlockState blockstate = p_219132_1_.getBlockState(SectionPos.sectionRelative(p_234139_2_.getX()), SectionPos.sectionRelative(p_234139_2_.getY()), SectionPos.sectionRelative(p_234139_2_.getZ()));
          PointOfInterestType.forState(blockstate).ifPresent((p_234142_2_) -> {
@@ -189,8 +241,10 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
          });
       });
    }
+   // Velox end
 
-   public void ensureLoadedAndValid(IWorldReader p_226347_1_, BlockPos p_226347_2_, int p_226347_3_) {
+   // Velox start: PointOfInterestManager#ensureLoadedAndValid threadsafe
+   public synchronized void ensureLoadedAndValid(IWorldReader p_226347_1_, BlockPos p_226347_2_, int p_226347_3_) {
       SectionPos.aroundChunk(new ChunkPos(p_226347_2_), Math.floorDiv(p_226347_3_, 16)).map((p_234147_1_) -> {
          return Pair.of(p_234147_1_, this.getOrLoad(p_234147_1_.asLong()));
       }).filter((p_234146_0_) -> {
@@ -203,6 +257,7 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
          p_226347_1_.getChunk(p_234136_1_.x, p_234136_1_.z, ChunkStatus.EMPTY);
       });
    }
+   // Velox end
 
    final class DistanceGraph extends SectionDistanceGraph {
       private final Long2ByteMap levels = new Long2ByteOpenHashMap();
diff --git a/build/mcp_diff_src/net/minecraft/world/World.java b/src/main/java/net/minecraft/world/World.java
index d5fbf20..9b04567 100644
--- a/build/mcp_diff_src/net/minecraft/world/World.java
+++ b/src/main/java/net/minecraft/world/World.java
@@ -7,10 +7,15 @@ import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.tick.global.WorldTickManager;
+import me.mikex86.velox.tick.region.RegionTickManager;
 import net.minecraft.block.AbstractFireBlock;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockState;
@@ -55,6 +60,7 @@ import net.minecraft.world.chunk.IChunk;
 import net.minecraft.world.gen.Heightmap;
 import net.minecraft.world.lighting.WorldLightManager;
 import net.minecraft.world.server.ChunkHolder;
+import net.minecraft.world.server.ServerWorld;
 import net.minecraft.world.storage.ISpawnWorldInfo;
 import net.minecraft.world.storage.IWorldInfo;
 import net.minecraft.world.storage.MapData;
@@ -70,10 +76,12 @@ public abstract class World implements IWorld, AutoCloseable {
    public static final RegistryKey<World> NETHER = RegistryKey.create(Registry.DIMENSION_REGISTRY, new ResourceLocation("the_nether"));
    public static final RegistryKey<World> END = RegistryKey.create(Registry.DIMENSION_REGISTRY, new ResourceLocation("the_end"));
    private static final Direction[] DIRECTIONS = Direction.values();
-   public final List<TileEntity> blockEntityList = Lists.newArrayList();
-   public final List<TileEntity> tickableBlockEntities = Lists.newArrayList();
-   protected final List<TileEntity> pendingBlockEntities = Lists.newArrayList();
-   protected final List<TileEntity> blockEntitiesToUnload = Lists.newArrayList();
+   // Velox start: Make tile entity lists threadsafe
+   public final List<TileEntity> blockEntityList = Lists.newCopyOnWriteArrayList();
+   public final List<TileEntity> tickableBlockEntities = Lists.newCopyOnWriteArrayList();
+   protected final List<TileEntity> pendingBlockEntities = Lists.newCopyOnWriteArrayList();
+   protected final List<TileEntity> blockEntitiesToUnload = Lists.newCopyOnWriteArrayList();
+   // Velox end
    private final Thread thread;
    private final boolean isDebug;
    private int skyDarken;
@@ -92,8 +100,14 @@ public abstract class World implements IWorld, AutoCloseable {
    private final WorldBorder worldBorder;
    private final BiomeManager biomeManager;
    private final RegistryKey<World> dimension;
+   // Velox start: TickRegionManager
+   public final RegionTickManager regionTickManager = new RegionTickManager(this);
+   // Velox end
 
    protected World(ISpawnWorldInfo p_i241925_1_, RegistryKey<World> p_i241925_2_, final DimensionType p_i241925_3_, Supplier<IProfiler> p_i241925_4_, boolean p_i241925_5_, boolean p_i241925_6_, long p_i241925_7_) {
+      // Velox start: Inform Velox API of new TickRegionManager
+      WorldTickManager.addTickRegionManager(this, this.regionTickManager);
+      // Velox end
       this.profiler = p_i241925_4_;
       this.levelData = p_i241925_1_;
       this.dimensionType = p_i241925_3_;
@@ -118,6 +132,22 @@ public abstract class World implements IWorld, AutoCloseable {
       this.isDebug = p_i241925_6_;
    }
 
+   // Velox start: unique world id
+   private final int id;
+   private static int nextId = 0;
+
+   {
+      synchronized (ServerWorld.class) {
+         id = nextId;
+         nextId++;
+      }
+   }
+
+   public int getWorldId() {
+      return id;
+   }
+   // Velox end
+
    public boolean isClientSide() {
       return this.isClientSide;
    }
@@ -168,58 +198,74 @@ public abstract class World implements IWorld, AutoCloseable {
       }
    }
 
+   // Velox start: block change lock
+   private final Lock blockChangeLock = new ReentrantLock();
+   // Velox end
+
    public boolean setBlock(BlockPos p_180501_1_, BlockState p_180501_2_, int p_180501_3_) {
-      return this.setBlock(p_180501_1_, p_180501_2_, p_180501_3_, 512);
+      // Velox start setBlock threadsafe
+      this.blockChangeLock.lock();
+      boolean changed = this.setBlock(p_180501_1_, p_180501_2_, p_180501_3_, 512);
+      this.blockChangeLock.unlock();
+      // Velox end
+      return changed;
    }
 
    public boolean setBlock(BlockPos p_241211_1_, BlockState p_241211_2_, int p_241211_3_, int p_241211_4_) {
-      if (isOutsideBuildHeight(p_241211_1_)) {
-         return false;
-      } else if (!this.isClientSide && this.isDebug()) {
-         return false;
-      } else {
-         Chunk chunk = this.getChunkAt(p_241211_1_);
-         Block block = p_241211_2_.getBlock();
-         BlockState blockstate = chunk.setBlockState(p_241211_1_, p_241211_2_, (p_241211_3_ & 64) != 0);
-         if (blockstate == null) {
+      // Velox start setBlock threadsafe
+      this.blockChangeLock.lock();
+      try {
+         if (isOutsideBuildHeight(p_241211_1_)) {
+            return false;
+         } else if (!this.isClientSide && this.isDebug()) {
             return false;
          } else {
-            BlockState blockstate1 = this.getBlockState(p_241211_1_);
-            if ((p_241211_3_ & 128) == 0 && blockstate1 != blockstate && (blockstate1.getLightBlock(this, p_241211_1_) != blockstate.getLightBlock(this, p_241211_1_) || blockstate1.getLightEmission() != blockstate.getLightEmission() || blockstate1.useShapeForLightOcclusion() || blockstate.useShapeForLightOcclusion())) {
-               this.getProfiler().push("queueCheckLight");
-               this.getChunkSource().getLightEngine().checkBlock(p_241211_1_);
-               this.getProfiler().pop();
-            }
-
-            if (blockstate1 == p_241211_2_) {
-               if (blockstate != blockstate1) {
-                  this.setBlocksDirty(p_241211_1_, blockstate, blockstate1);
+            Chunk chunk = this.getChunkAt(p_241211_1_);
+            Block block = p_241211_2_.getBlock();
+            BlockState blockstate = chunk.setBlockState(p_241211_1_, p_241211_2_, (p_241211_3_ & 64) != 0);
+            if (blockstate == null) {
+               return false;
+            } else {
+               BlockState blockstate1 = this.getBlockState(p_241211_1_);
+               if ((p_241211_3_ & 128) == 0 && blockstate1 != blockstate && (blockstate1.getLightBlock(this, p_241211_1_) != blockstate.getLightBlock(this, p_241211_1_) || blockstate1.getLightEmission() != blockstate.getLightEmission() || blockstate1.useShapeForLightOcclusion() || blockstate.useShapeForLightOcclusion())) {
+                  this.getProfiler().push("queueCheckLight");
+                  this.getChunkSource().getLightEngine().checkBlock(p_241211_1_);
+                  this.getProfiler().pop();
                }
 
-               if ((p_241211_3_ & 2) != 0 && (!this.isClientSide || (p_241211_3_ & 4) == 0) && (this.isClientSide || chunk.getFullStatus() != null && chunk.getFullStatus().isOrAfter(ChunkHolder.LocationType.TICKING))) {
-                  this.sendBlockUpdated(p_241211_1_, blockstate, p_241211_2_, p_241211_3_);
-               }
+               if (blockstate1 == p_241211_2_) {
+                  if (blockstate != blockstate1) {
+                     this.setBlocksDirty(p_241211_1_, blockstate, blockstate1);
+                  }
 
-               if ((p_241211_3_ & 1) != 0) {
-                  this.blockUpdated(p_241211_1_, blockstate.getBlock());
-                  if (!this.isClientSide && p_241211_2_.hasAnalogOutputSignal()) {
-                     this.updateNeighbourForOutputSignal(p_241211_1_, block);
+                  if ((p_241211_3_ & 2) != 0 && (!this.isClientSide || (p_241211_3_ & 4) == 0) && (this.isClientSide || chunk.getFullStatus() != null && chunk.getFullStatus().isOrAfter(ChunkHolder.LocationType.TICKING))) {
+                     this.sendBlockUpdated(p_241211_1_, blockstate, p_241211_2_, p_241211_3_);
                   }
-               }
 
-               if ((p_241211_3_ & 16) == 0 && p_241211_4_ > 0) {
-                  int i = p_241211_3_ & -34;
-                  blockstate.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
-                  p_241211_2_.updateNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
-                  p_241211_2_.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
+                  if ((p_241211_3_ & 1) != 0) {
+                     this.blockUpdated(p_241211_1_, blockstate.getBlock());
+                     if (!this.isClientSide && p_241211_2_.hasAnalogOutputSignal()) {
+                        this.updateNeighbourForOutputSignal(p_241211_1_, block);
+                     }
+                  }
+
+                  if ((p_241211_3_ & 16) == 0 && p_241211_4_ > 0) {
+                     int i = p_241211_3_ & -34;
+                     blockstate.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
+                     p_241211_2_.updateNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
+                     p_241211_2_.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
+                  }
+
+                  this.onBlockStateChange(p_241211_1_, blockstate, blockstate1);
                }
 
-               this.onBlockStateChange(p_241211_1_, blockstate, blockstate1);
+               return true;
             }
-
-            return true;
          }
+      } finally {
+         this.blockChangeLock.unlock();
       }
+      // Velox end
    }
 
    public void onBlockStateChange(BlockPos p_217393_1_, BlockState p_217393_2_, BlockState p_217393_3_) {
@@ -527,9 +573,9 @@ public abstract class World implements IWorld, AutoCloseable {
    public TileEntity getBlockEntity(BlockPos p_175625_1_) {
       if (isOutsideBuildHeight(p_175625_1_)) {
          return null;
-      } else if (!this.isClientSide && Thread.currentThread() != this.thread) {
-         return null;
+      // Velox start: remove getBlockEntity mainThread check
       } else {
+      // Velox end
          TileEntity tileentity = null;
          if (this.updatingBlockEntities) {
             tileentity = this.getPendingBlockEntityAt(p_175625_1_);
diff --git a/build/mcp_diff_src/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index 551fa3d..ae322f4 100644
--- a/build/mcp_diff_src/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -65,11 +65,15 @@ public class Chunk implements IChunk {
    private final ChunkSection[] sections = new ChunkSection[16];
    private BiomeContainer biomes;
    private final Map<BlockPos, CompoundNBT> pendingBlockEntities = Maps.newHashMap();
-   private boolean loaded;
+   // Velox start: make Chunk#loaded public
+   public boolean loaded;
+   // Velox end
    private final World level;
    private final Map<Heightmap.Type, Heightmap> heightmaps = Maps.newEnumMap(Heightmap.Type.class);
    private final UpgradeData upgradeData;
-   private final Map<BlockPos, TileEntity> blockEntities = Maps.newHashMap();
+   // Velox start: Make blockEntities map thread-safe
+   private final Map<BlockPos, TileEntity> blockEntities = Maps.newConcurrentMap();
+   // Velox end
    private final ClassInheritanceMultiMap<Entity>[] entitySections;
    private final Map<Structure<?>, StructureStart<?>> structureStarts = Maps.newHashMap();
    private final Map<Structure<?>, LongSet> structuresRefences = Maps.newHashMap();
@@ -573,6 +577,9 @@ public class Chunk implements IChunk {
    }
 
    public void setLoaded(boolean p_177417_1_) {
+      // Velox start: inform tick region manager of chunk load state change
+      this.level.regionTickManager.informChunkLoadStateChange(this, p_177417_1_);
+      // Velox end
       this.loaded = p_177417_1_;
    }
 
diff --git a/build/mcp_diff_src/net/minecraft/world/chunk/PlayerGenerationTracker.java b/src/main/java/net/minecraft/world/chunk/PlayerGenerationTracker.java
index 2ab06fe..3f91bd9 100644
--- a/build/mcp_diff_src/net/minecraft/world/chunk/PlayerGenerationTracker.java
+++ b/src/main/java/net/minecraft/world/chunk/PlayerGenerationTracker.java
@@ -1,15 +1,21 @@
 package net.minecraft.world.chunk;
 
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
+import it.unimi.dsi.fastutil.objects.Object2BooleanMaps;
 import it.unimi.dsi.fastutil.objects.Object2BooleanOpenHashMap;
+
 import java.util.stream.Stream;
+
+import me.mikex86.velox.utils.StreamUtils;
 import net.minecraft.entity.player.ServerPlayerEntity;
 
+// Velox start: PlayerGenerationTracker threadsafe
+// Reason: used by EntityTracker (invoked concurrently by ServerPlayerEntity#tick)
 public final class PlayerGenerationTracker {
-   private final Object2BooleanMap<ServerPlayerEntity> players = new Object2BooleanOpenHashMap<>();
+   private final Object2BooleanMap<ServerPlayerEntity> players = Object2BooleanMaps.synchronize(new Object2BooleanOpenHashMap<>());
 
    public Stream<ServerPlayerEntity> getPlayers(long p_219444_1_) {
-      return this.players.keySet().stream();
+      return StreamUtils.prefetchSynchronizedCollection(this.players.keySet());
    }
 
    public void addPlayer(long p_219442_1_, ServerPlayerEntity p_219442_3_, boolean p_219442_4_) {
@@ -39,3 +45,4 @@ public final class PlayerGenerationTracker {
    public void updatePlayer(long p_219445_1_, long p_219445_3_, ServerPlayerEntity p_219445_5_) {
    }
 }
+// Velox end
diff --git a/build/mcp_diff_src/net/minecraft/world/gen/feature/template/TemplateManager.java b/src/main/java/net/minecraft/world/gen/feature/template/TemplateManager.java
index 4a91012..a42d60d 100644
--- a/build/mcp_diff_src/net/minecraft/world/gen/feature/template/TemplateManager.java
+++ b/src/main/java/net/minecraft/world/gen/feature/template/TemplateManager.java
@@ -29,7 +29,9 @@ import org.apache.logging.log4j.Logger;
 
 public class TemplateManager {
    private static final Logger LOGGER = LogManager.getLogger();
-   private final Map<ResourceLocation, Template> structureRepository = Maps.newHashMap();
+   // Velox start: structureRepository concurrent
+   private final Map<ResourceLocation, Template> structureRepository = Maps.newConcurrentMap();
+   // Velox end
    private final DataFixer fixerUpper;
    private IResourceManager resourceManager;
    private final Path generatedDir;
diff --git a/build/mcp_diff_src/net/minecraft/world/raid/RaidManager.java b/src/main/java/net/minecraft/world/raid/RaidManager.java
index 67b540a..6b3430c 100644
--- a/build/mcp_diff_src/net/minecraft/world/raid/RaidManager.java
+++ b/src/main/java/net/minecraft/world/raid/RaidManager.java
@@ -26,7 +26,9 @@ import net.minecraft.world.server.ServerWorld;
 import net.minecraft.world.storage.WorldSavedData;
 
 public class RaidManager extends WorldSavedData {
-   private final Map<Integer, Raid> raidMap = Maps.newHashMap();
+   // Velox start: RaidManager#raidMap threadsafe
+   private final Map<Integer, Raid> raidMap = Maps.newConcurrentMap();
+   // Velox end
    private final ServerWorld level;
    private int nextAvailableID;
    private int tick;
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ChunkManager.java b/src/main/java/net/minecraft/world/server/ChunkManager.java
index 5ebcd28..840b509 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ChunkManager.java
+++ b/src/main/java/net/minecraft/world/server/ChunkManager.java
@@ -8,28 +8,21 @@ import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
-import java.util.Collection;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.function.BooleanSupplier;
 import java.util.function.IntFunction;
 import java.util.function.IntSupplier;
@@ -37,6 +30,8 @@ import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.utils.CollectionUtils;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ReportedException;
@@ -96,8 +91,13 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    private static final Logger LOGGER = LogManager.getLogger();
    public static final int MAX_CHUNK_DISTANCE = 33 + ChunkStatus.maxDistance();
    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new Long2ObjectLinkedOpenHashMap<>();
+   // Velox start: visibleChunkMap volatile
+   // Velox comment: visibleChunkMap is safe to be read from other threads, never mutated, only instance copy on write switched
    private volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = this.updatingChunkMap.clone();
-   private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads = new Long2ObjectLinkedOpenHashMap<>();
+   // Velox end
+   // Velox start: Make ChunkManager#pendingUnloads public and threadsafe
+   public final Long2ObjectMap<ChunkHolder> pendingUnloads = Long2ObjectMaps.synchronize(new Long2ObjectLinkedOpenHashMap<>());
+   // Velox end
    private final LongSet entitiesInLevel = new LongOpenHashSet();
    private final ServerWorld level;
    private final ServerWorldLightManager lightEngine;
@@ -116,8 +116,14 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    private final TemplateManager structureManager;
    private final File storageFolder;
    private final PlayerGenerationTracker playerMap = new PlayerGenerationTracker();
-   private final Int2ObjectMap<ChunkManager.EntityTracker> entityMap = new Int2ObjectOpenHashMap<>();
-   private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
+
+   // Velox start: entityMap synchronized
+   private final Int2ObjectMap<ChunkManager.EntityTracker> entityMap = Int2ObjectMaps.synchronize(new Int2ObjectOpenHashMap<>());
+   // Velox end
+
+   // Velox start: chunkTypeCache synchronized
+   private final Long2ByteMap chunkTypeCache = Long2ByteMaps.synchronize(new Long2ByteOpenHashMap());
+   // Velox end
    private final Queue<Runnable> unloadQueue = Queues.newConcurrentLinkedQueue();
    private int viewDistance;
 
@@ -320,6 +326,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    protected void saveAllChunks(boolean p_219177_1_) {
       if (p_219177_1_) {
          List<ChunkHolder> list = this.visibleChunkMap.values().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).peek(ChunkHolder::refreshAccessibility).collect(Collectors.toList());
+
          MutableBoolean mutableboolean = new MutableBoolean();
 
          do {
@@ -407,7 +414,6 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
                   Chunk chunk = (Chunk)p_219185_5_;
                   this.level.unload(chunk);
                }
-
                this.lightEngine.updateChunkStatus(p_219185_5_.getPos());
                this.lightEngine.tryScheduleUpdate();
                this.progressListener.onStatusChange(p_219185_5_.getPos(), (ChunkStatus)null);
@@ -762,13 +768,19 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    }
 
    protected Iterable<ChunkHolder> getChunks() {
-      return Iterables.unmodifiableIterable(this.visibleChunkMap.values());
+      // Velox start: prefech iteratable
+      return CollectionUtils.prefetchIterable(Iterables.unmodifiableIterable(this.visibleChunkMap.values()));
+      // Velox end
    }
 
    void dumpChunks(Writer p_225406_1_) throws IOException {
       CSVWriter csvwriter = CSVWriter.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("entity_count").addColumn("block_entity_count").build(p_225406_1_);
 
-      for(Entry<ChunkHolder> entry : this.visibleChunkMap.long2ObjectEntrySet()) {
+      // Velox start: Prefect iterable
+      Iterable<Entry<ChunkHolder>> entrySet = CollectionUtils.prefetchIterable(this.visibleChunkMap.long2ObjectEntrySet());
+      // Velox end
+
+      for(Entry<ChunkHolder> entry : entrySet) {
          ChunkPos chunkpos = new ChunkPos(entry.getLongKey());
          ChunkHolder chunkholder = entry.getValue();
          Optional<IChunk> optional = Optional.ofNullable(chunkholder.getLastAvailable());
@@ -851,84 +863,84 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
       return sectionpos;
    }
 
-   public void move(ServerPlayerEntity p_219183_1_) {
-      for(ChunkManager.EntityTracker chunkmanager$entitytracker : this.entityMap.values()) {
-         if (chunkmanager$entitytracker.entity == p_219183_1_) {
-            chunkmanager$entitytracker.updatePlayers(this.level.players());
+   // Velox start: EntityTracker#move threadsafe
+   // Reason: Invoked concurrently by EntityServerPlayer#tick
+   public void move(ServerPlayerEntity player) {
+      Collection<EntityTracker> entityTrackers = CollectionUtils.immutableCopy(this.entityMap.values());
+      for(ChunkManager.EntityTracker tracker : entityTrackers) {
+         if (tracker.entity == player) {
+            tracker.updatePlayers(this.level.players());
          } else {
-            chunkmanager$entitytracker.updatePlayer(p_219183_1_);
+            tracker.updatePlayer(player);
          }
       }
 
-      int l1 = MathHelper.floor(p_219183_1_.getX()) >> 4;
-      int i2 = MathHelper.floor(p_219183_1_.getZ()) >> 4;
-      SectionPos sectionpos = p_219183_1_.getLastSectionPos();
-      SectionPos sectionpos1 = SectionPos.of(p_219183_1_);
-      long i = sectionpos.chunk().toLong();
-      long j = sectionpos1.chunk().toLong();
-      boolean flag = this.playerMap.ignored(p_219183_1_);
-      boolean flag1 = this.skipPlayer(p_219183_1_);
-      boolean flag2 = sectionpos.asLong() != sectionpos1.asLong();
-      if (flag2 || flag != flag1) {
-         this.updatePlayerPos(p_219183_1_);
-         if (!flag) {
-            this.distanceManager.removePlayer(sectionpos, p_219183_1_);
+      int chunkX = MathHelper.floor(player.getX()) >> 4;
+      int chunkZ = MathHelper.floor(player.getZ()) >> 4;
+      SectionPos lastSection = player.getLastSectionPos();
+      SectionPos currentSection = SectionPos.of(player);
+      long lastSectionPacked = lastSection.chunk().toLong();
+      long currentSectionPacked = currentSection.chunk().toLong();
+      boolean ignored = this.playerMap.ignored(player);
+      boolean skipPlayer = this.skipPlayer(player);
+      boolean flag2 = lastSection.asLong() != currentSection.asLong();
+      if (flag2 || ignored != skipPlayer) {
+         this.updatePlayerPos(player);
+         if (!ignored) {
+            this.distanceManager.removePlayer(lastSection, player);
          }
 
-         if (!flag1) {
-            this.distanceManager.addPlayer(sectionpos1, p_219183_1_);
+         if (!skipPlayer) {
+            this.distanceManager.addPlayer(currentSection, player);
          }
 
-         if (!flag && flag1) {
-            this.playerMap.ignorePlayer(p_219183_1_);
+         if (!ignored && skipPlayer) {
+            this.playerMap.ignorePlayer(player);
          }
 
-         if (flag && !flag1) {
-            this.playerMap.unIgnorePlayer(p_219183_1_);
+         if (ignored && !skipPlayer) {
+            this.playerMap.unIgnorePlayer(player);
          }
 
-         if (i != j) {
-            this.playerMap.updatePlayer(i, j, p_219183_1_);
+         if (lastSectionPacked != currentSectionPacked) {
+            this.playerMap.updatePlayer(lastSectionPacked, currentSectionPacked, player);
          }
       }
 
-      int k = sectionpos.x();
-      int l = sectionpos.z();
-      if (Math.abs(k - l1) <= this.viewDistance * 2 && Math.abs(l - i2) <= this.viewDistance * 2) {
-         int k2 = Math.min(l1, k) - this.viewDistance;
-         int i3 = Math.min(i2, l) - this.viewDistance;
-         int j3 = Math.max(l1, k) + this.viewDistance;
-         int k3 = Math.max(i2, l) + this.viewDistance;
+      int k = lastSection.x();
+      int l = lastSection.z();
+      if (Math.abs(k - chunkX) <= this.viewDistance * 2 && Math.abs(l - chunkZ) <= this.viewDistance * 2) {
+         int k2 = Math.min(chunkX, k) - this.viewDistance;
+         int i3 = Math.min(chunkZ, l) - this.viewDistance;
+         int j3 = Math.max(chunkX, k) + this.viewDistance;
+         int k3 = Math.max(chunkZ, l) + this.viewDistance;
 
          for(int l3 = k2; l3 <= j3; ++l3) {
             for(int k1 = i3; k1 <= k3; ++k1) {
                ChunkPos chunkpos1 = new ChunkPos(l3, k1);
                boolean flag5 = checkerboardDistance(chunkpos1, k, l) <= this.viewDistance;
-               boolean flag6 = checkerboardDistance(chunkpos1, l1, i2) <= this.viewDistance;
-               this.updateChunkTracking(p_219183_1_, chunkpos1, new IPacket[2], flag5, flag6);
+               boolean flag6 = checkerboardDistance(chunkpos1, chunkX, chunkZ) <= this.viewDistance;
+               this.updateChunkTracking(player, chunkpos1, new IPacket[2], flag5, flag6);
             }
          }
       } else {
          for(int i1 = k - this.viewDistance; i1 <= k + this.viewDistance; ++i1) {
             for(int j1 = l - this.viewDistance; j1 <= l + this.viewDistance; ++j1) {
                ChunkPos chunkpos = new ChunkPos(i1, j1);
-               boolean flag3 = true;
-               boolean flag4 = false;
-               this.updateChunkTracking(p_219183_1_, chunkpos, new IPacket[2], true, false);
+               this.updateChunkTracking(player, chunkpos, new IPacket[2], true, false);
             }
          }
 
-         for(int j2 = l1 - this.viewDistance; j2 <= l1 + this.viewDistance; ++j2) {
-            for(int l2 = i2 - this.viewDistance; l2 <= i2 + this.viewDistance; ++l2) {
+         for(int j2 = chunkX - this.viewDistance; j2 <= chunkX + this.viewDistance; ++j2) {
+            for(int l2 = chunkZ - this.viewDistance; l2 <= chunkZ + this.viewDistance; ++l2) {
                ChunkPos chunkpos2 = new ChunkPos(j2, l2);
-               boolean flag7 = false;
-               boolean flag8 = true;
-               this.updateChunkTracking(p_219183_1_, chunkpos2, new IPacket[2], false, true);
+               this.updateChunkTracking(player, chunkpos2, new IPacket[2], false, true);
             }
          }
       }
 
    }
+   // Velox end
 
    public Stream<ServerPlayerEntity> getPlayers(ChunkPos p_219097_1_, boolean p_219097_2_) {
       return this.playerMap.getPlayers(p_219097_1_.toLong()).filter((p_219192_3_) -> {
@@ -1082,7 +1094,9 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
       private final Entity entity;
       private final int range;
       private SectionPos lastSectionPos;
-      private final Set<ServerPlayerEntity> seenBy = Sets.newHashSet();
+      // Velox start: EntityTracker#seenBy threadsafe
+      private final Set<ServerPlayerEntity> seenBy = Sets.newConcurrentHashSet();
+      // Velox end
 
       public EntityTracker(Entity p_i50468_2_, int p_i50468_3_, int p_i50468_4_, boolean p_i50468_5_) {
          this.serverEntity = new TrackedEntity(ChunkManager.this.level, p_i50468_2_, p_i50468_4_, p_i50468_5_, this::broadcast);
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerBossInfo.java b/src/main/java/net/minecraft/world/server/ServerBossInfo.java
index c17fea8..3e777f3 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerBossInfo.java
+++ b/src/main/java/net/minecraft/world/server/ServerBossInfo.java
@@ -13,7 +13,10 @@ import net.minecraft.util.text.ITextComponent;
 import net.minecraft.world.BossInfo;
 
 public class ServerBossInfo extends BossInfo {
-   private final Set<ServerPlayerEntity> players = Sets.newHashSet();
+   // Velox start: players threadsafe
+   // Reason: changed concurrently by entity tracker (start/stopSeenByPlayer)
+   private final Set<ServerPlayerEntity> players = Sets.newConcurrentHashSet();
+   // Velox end
    private final Set<ServerPlayerEntity> unmodifiablePlayers = Collections.unmodifiableSet(this.players);
    private boolean visible = true;
 
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerChunkProvider.java b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
index f0207fb..721ae5d 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerChunkProvider.java
+++ b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
@@ -6,9 +6,9 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -59,9 +59,7 @@ public class ServerChunkProvider extends AbstractChunkProvider {
    private long lastInhabitedUpdate;
    private boolean spawnEnemies = true;
    private boolean spawnFriendlies = true;
-   private final long[] lastChunkPos = new long[4];
-   private final ChunkStatus[] lastChunkStatus = new ChunkStatus[4];
-   private final IChunk[] lastChunk = new IChunk[4];
+   // Velox deletion: Removed minecraft chunk cache for thread safety and performance reasons
    @Nullable
    private WorldEntitySpawner.EntityDensityManager lastSpawnState;
 
@@ -77,7 +75,6 @@ public class ServerChunkProvider extends AbstractChunkProvider {
       this.chunkMap = new ChunkManager(p_i232603_1_, p_i232603_2_, p_i232603_3_, p_i232603_4_, p_i232603_5_, this.mainThreadProcessor, this, this.getGenerator(), p_i232603_9_, p_i232603_10_, p_i232603_7_, p_i232603_8_);
       this.lightEngine = this.chunkMap.getLightEngine();
       this.distanceManager = this.chunkMap.getDistanceManager();
-      this.clearCache();
    }
 
    public ServerWorldLightManager getLightEngine() {
@@ -93,97 +90,61 @@ public class ServerChunkProvider extends AbstractChunkProvider {
       return this.chunkMap.getTickingGenerated();
    }
 
-   private void storeInCache(long p_225315_1_, IChunk p_225315_3_, ChunkStatus p_225315_4_) {
-      for(int i = 3; i > 0; --i) {
-         this.lastChunkPos[i] = this.lastChunkPos[i - 1];
-         this.lastChunkStatus[i] = this.lastChunkStatus[i - 1];
-         this.lastChunk[i] = this.lastChunk[i - 1];
-      }
-
-      this.lastChunkPos[0] = p_225315_1_;
-      this.lastChunkStatus[0] = p_225315_4_;
-      this.lastChunk[0] = p_225315_3_;
-   }
-
    @Nullable
    public IChunk getChunk(int p_212849_1_, int p_212849_2_, ChunkStatus p_212849_3_, boolean p_212849_4_) {
-      if (Thread.currentThread() != this.mainThread) {
-         return CompletableFuture.supplyAsync(() -> {
-            return this.getChunk(p_212849_1_, p_212849_2_, p_212849_3_, p_212849_4_);
-         }, this.mainThreadProcessor).join();
-      } else {
-         IProfiler iprofiler = this.level.getProfiler();
-         iprofiler.incrementCounter("getChunk");
-         long i = ChunkPos.asLong(p_212849_1_, p_212849_2_);
-
-         for(int j = 0; j < 4; ++j) {
-            if (i == this.lastChunkPos[j] && p_212849_3_ == this.lastChunkStatus[j]) {
-               IChunk ichunk = this.lastChunk[j];
-               if (ichunk != null || !p_212849_4_) {
-                  return ichunk;
-               }
-            }
-         }
-
-         iprofiler.incrementCounter("getChunkCacheMiss");
-         CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.getChunkFutureMainThread(p_212849_1_, p_212849_2_, p_212849_3_, p_212849_4_);
-         this.mainThreadProcessor.managedBlock(completablefuture::isDone);
-         IChunk ichunk1 = completablefuture.join().map((p_222874_0_) -> {
-            return p_222874_0_;
-         }, (p_222870_1_) -> {
-            if (p_212849_4_) {
-               throw (IllegalStateException)Util.pauseInIde(new IllegalStateException("Chunk not there when requested: " + p_222870_1_));
-            } else {
-               return null;
-            }
-         });
-         this.storeInCache(i, ichunk1, p_212849_3_);
-         return ichunk1;
-      }
+      // Velox start: remove getChunk mainThread check
+      IProfiler iprofiler = this.level.getProfiler();
+      iprofiler.incrementCounter("getChunk");
+      // Velox start: Lookup chunk cache
+      long packedChunkPos = ChunkPos.asLong(p_212849_1_, p_212849_2_);
+      return getChunk(packedChunkPos, p_212849_3_, p_212849_4_);
+      // Velox end
    }
 
    @Nullable
    public Chunk getChunkNow(int p_225313_1_, int p_225313_2_) {
-      if (Thread.currentThread() != this.mainThread) {
+      // Velox start: remove getChunkNow mainThread check
+      this.level.getProfiler().incrementCounter("getChunkNow");
+
+      // Velox start: Lookup chunk cache
+      long packedChunkPos = ChunkPos.asLong(p_225313_1_, p_225313_2_);
+      IChunk chunk = getChunk(packedChunkPos, ChunkStatus.FULL, true);
+      if (chunk instanceof Chunk)
+         return (Chunk) chunk;
+      else
          return null;
-      } else {
-         this.level.getProfiler().incrementCounter("getChunkNow");
-         long i = ChunkPos.asLong(p_225313_1_, p_225313_2_);
-
-         for(int j = 0; j < 4; ++j) {
-            if (i == this.lastChunkPos[j] && this.lastChunkStatus[j] == ChunkStatus.FULL) {
-               IChunk ichunk = this.lastChunk[j];
-               return ichunk instanceof Chunk ? (Chunk)ichunk : null;
-            }
-         }
+      // Velox end
+   }
 
-         ChunkHolder chunkholder = this.getVisibleChunkIfPresent(i);
-         if (chunkholder == null) {
-            return null;
+   // Velox start: fallbackLookup
+   @Nullable
+   protected IChunk fallbackLookup(int chunkX, int chunkZ, ChunkStatus requiredStatus, boolean load) {
+      CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.getChunkFutureMainThread(chunkX, chunkZ, requiredStatus, load);
+      this.mainThreadProcessor.managedBlock(completablefuture::isDone);
+
+      return completablefuture.join().map((p_222874_0_) -> {
+         return p_222874_0_;
+      }, (p_222870_1_) -> {
+         if (load) {
+            throw (IllegalStateException)Util.pauseInIde(new IllegalStateException("Chunk not there when requested: " + p_222870_1_));
          } else {
-            Either<IChunk, ChunkHolder.IChunkLoadingError> either = chunkholder.getFutureIfPresent(ChunkStatus.FULL).getNow((Either<IChunk, ChunkHolder.IChunkLoadingError>)null);
-            if (either == null) {
-               return null;
-            } else {
-               IChunk ichunk1 = either.left().orElse((IChunk)null);
-               if (ichunk1 != null) {
-                  this.storeInCache(i, ichunk1, ChunkStatus.FULL);
-                  if (ichunk1 instanceof Chunk) {
-                     return (Chunk)ichunk1;
-                  }
-               }
-
-               return null;
-            }
+            return null;
          }
-      }
+      });
+   }
+   // Velox end
+
+   // Velox start: Expose lookupChunkCache to implement chunk cache
+   @Nullable
+   protected IChunk getChunk(long packedChunkPos, ChunkStatus requiredStatus, boolean load) {
+      return null;
    }
+   // Velox end
 
-   private void clearCache() {
-      Arrays.fill(this.lastChunkPos, ChunkPos.INVALID_CHUNK_POS);
-      Arrays.fill(this.lastChunkStatus, (Object)null);
-      Arrays.fill(this.lastChunk, (Object)null);
+   // Velox start: Expose clearCache to implement chunk cache. Attention: Invoked after every tick!
+   protected void clearCache() {
    }
+   // Velox end
 
    @OnlyIn(Dist.CLIENT)
    public CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> getChunkFuture(int p_217232_1_, int p_217232_2_, ChunkStatus p_217232_3_, boolean p_217232_4_) {
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerTickList.java b/src/main/java/net/minecraft/world/server/ServerTickList.java
index a78bb2e..43e65d5 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerTickList.java
+++ b/src/main/java/net/minecraft/world/server/ServerTickList.java
@@ -3,13 +3,10 @@ package net.minecraft.world.server;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Queue;
-import java.util.Set;
-import java.util.TreeSet;
+
+import java.util.*;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -31,12 +28,24 @@ import net.minecraft.world.TickPriority;
 public class ServerTickList<T> implements ITickList<T> {
    protected final Predicate<T> ignore;
    private final Function<T, ResourceLocation> toId;
-   private final Set<NextTickListEntry<T>> tickNextTickSet = Sets.newHashSet();
-   private final TreeSet<NextTickListEntry<T>> tickNextTickList = Sets.newTreeSet(NextTickListEntry.createTimeComparator());
+   // Velox start: tickNextTickSet threadsafe
+   private final Set<NextTickListEntry<T>> tickNextTickSet = Sets.newConcurrentHashSet();
+   // Velox end
+   // Velox start: tickNextTickList threadsafe
+   private final SortedSet<NextTickListEntry<T>> tickNextTickList = Collections.synchronizedSortedSet(Sets.newTreeSet(NextTickListEntry.createTimeComparator()));
+   // Velox end
    private final ServerWorld level;
-   private final Queue<NextTickListEntry<T>> currentlyTicking = Queues.newArrayDeque();
-   private final List<NextTickListEntry<T>> alreadyTicked = Lists.newArrayList();
+   // Velox start: currentlyTicking threadsafe
+   private final Queue<NextTickListEntry<T>> currentlyTicking = Queues.newLinkedBlockingDeque();
+   // Velox end
+   // Velox start: alreadyTicked threadsafe
+   private final List<NextTickListEntry<T>> alreadyTicked = Collections.synchronizedList(Lists.newLinkedList());
+   // Velox end
    private final Consumer<NextTickListEntry<T>> ticker;
+   // Velox start: Make ServerTickList threadsafe
+   // Reason: ServerTick list is modified concurrently by world generation
+   private final ReadWriteLock lock = new ReentrantReadWriteLock();
+   // Velox end
 
    public ServerTickList(ServerWorld p_i231625_1_, Predicate<T> p_i231625_2_, Function<T, ResourceLocation> p_i231625_3_, Consumer<NextTickListEntry<T>> p_i231625_4_) {
       this.ignore = p_i231625_2_;
@@ -46,59 +55,88 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    public void tick() {
-      int i = this.tickNextTickList.size();
-      if (i != this.tickNextTickSet.size()) {
-         throw new IllegalStateException("TickNextTick list out of synch");
-      } else {
-         if (i > 65536) {
-            i = 65536;
-         }
+      // Velox start: ServerTickList#tick threadsafe
+      this.lock.writeLock().lock();
+      try {
+         int i = this.tickNextTickList.size();
+         if (i != this.tickNextTickSet.size()) {
+            throw new IllegalStateException("TickNextTick list out of synch");
+         } else {
+            if (i > 65536) {
+               i = 65536;
+            }
 
-         ServerChunkProvider serverchunkprovider = this.level.getChunkSource();
-         Iterator<NextTickListEntry<T>> iterator = this.tickNextTickList.iterator();
-         this.level.getProfiler().push("cleaning");
+            ServerChunkProvider serverchunkprovider = this.level.getChunkSource();
+            Iterator<NextTickListEntry<T>> iterator = this.tickNextTickList.iterator();
+            this.level.getProfiler().push("cleaning");
 
-         while(i > 0 && iterator.hasNext()) {
-            NextTickListEntry<T> nextticklistentry = iterator.next();
-            if (nextticklistentry.triggerTick > this.level.getGameTime()) {
-               break;
-            }
+            while (i > 0 && iterator.hasNext()) {
+               NextTickListEntry<T> nextticklistentry = iterator.next();
+               if (nextticklistentry.triggerTick > this.level.getGameTime()) {
+                  break;
+               }
 
-            if (serverchunkprovider.isTickingChunk(nextticklistentry.pos)) {
-               iterator.remove();
-               this.tickNextTickSet.remove(nextticklistentry);
-               this.currentlyTicking.add(nextticklistentry);
-               --i;
+               if (serverchunkprovider.isTickingChunk(nextticklistentry.pos)) {
+                  iterator.remove();
+                  this.tickNextTickSet.remove(nextticklistentry);
+                  this.currentlyTicking.add(nextticklistentry);
+                  --i;
+               }
             }
-         }
 
-         this.level.getProfiler().popPush("ticking");
-
-         NextTickListEntry<T> nextticklistentry1;
-         while((nextticklistentry1 = this.currentlyTicking.poll()) != null) {
-            if (serverchunkprovider.isTickingChunk(nextticklistentry1.pos)) {
-               try {
-                  this.alreadyTicked.add(nextticklistentry1);
-                  this.ticker.accept(nextticklistentry1);
-               } catch (Throwable throwable) {
-                  CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception while ticking");
-                  CrashReportCategory crashreportcategory = crashreport.addCategory("Block being ticked");
-                  CrashReportCategory.populateBlockDetails(crashreportcategory, nextticklistentry1.pos, (BlockState)null);
-                  throw new ReportedException(crashreport);
+            this.level.getProfiler().popPush("ticking");
+
+            NextTickListEntry<T> nextticklistentry1;
+            while ((nextticklistentry1 = this.currentlyTicking.poll()) != null) {
+               if (serverchunkprovider.isTickingChunk(nextticklistentry1.pos)) {
+                  try {
+                     this.alreadyTicked.add(nextticklistentry1);
+                     // Velox start: call tickEntry to tick tick list entry
+                     this.tickEntry(nextticklistentry1);
+                     // Velox end
+                  } catch (Throwable throwable) {
+                     CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception while ticking");
+                     CrashReportCategory crashreportcategory = crashreport.addCategory("Block being ticked");
+                     CrashReportCategory.populateBlockDetails(crashreportcategory, nextticklistentry1.pos, (BlockState) null);
+                     throw new ReportedException(crashreport);
+                  }
+               } else {
+                  this.scheduleTick(nextticklistentry1.pos, nextticklistentry1.getType(), 0);
                }
-            } else {
-               this.scheduleTick(nextticklistentry1.pos, nextticklistentry1.getType(), 0);
             }
-         }
 
-         this.level.getProfiler().pop();
-         this.alreadyTicked.clear();
-         this.currentlyTicking.clear();
+            this.level.getProfiler().pop();
+            this.alreadyTicked.clear();
+            this.currentlyTicking.clear();
+         }
+      } finally {
+         // Velox end
+         this.lock.writeLock().unlock();
+         // Velox start: call postTick().
+         // Velox comment: lock must be released before calling this, the caller may try to mutate this tick list.
+         this.postTick();
       }
+      // Velox end
+   }
+
+   // Velox start: create tickEntry method
+   protected void tickEntry(NextTickListEntry<T> entry) {
+      this.ticker.accept(entry);
    }
+   // Velox end
+
+   // Velox start: create postTick
+   protected void postTick() {
+   }
+   // Velox end
 
    public boolean willTickThisTick(BlockPos p_205361_1_, T p_205361_2_) {
-      return this.currentlyTicking.contains(new NextTickListEntry(p_205361_1_, p_205361_2_));
+      // Velox start: ServerTickList#fetchTicksInArea threadsafe
+      this.lock.readLock().lock();
+      boolean contains = this.currentlyTicking.contains(new NextTickListEntry(p_205361_1_, p_205361_2_));
+      this.lock.readLock().unlock();
+      // Velox end
+      return contains;
    }
 
    public List<NextTickListEntry<T>> fetchTicksInChunk(ChunkPos p_223188_1_, boolean p_223188_2_, boolean p_223188_3_) {
@@ -110,6 +148,8 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    public List<NextTickListEntry<T>> fetchTicksInArea(MutableBoundingBox p_205366_1_, boolean p_205366_2_, boolean p_205366_3_) {
+      // Velox start: ServerTickList#fetchTicksInArea threadsafe
+      this.lock.writeLock().lock();
       List<NextTickListEntry<T>> list = this.fetchTicksInArea((List<NextTickListEntry<T>>)null, this.tickNextTickList, p_205366_1_, p_205366_2_);
       if (p_205366_2_ && list != null) {
          this.tickNextTickSet.removeAll(list);
@@ -119,7 +159,8 @@ public class ServerTickList<T> implements ITickList<T> {
       if (!p_205366_3_) {
          list = this.fetchTicksInArea(list, this.alreadyTicked, p_205366_1_, p_205366_2_);
       }
-
+      this.lock.writeLock().unlock();
+      // Velox end
       return list == null ? Collections.emptyList() : list;
    }
 
@@ -191,14 +232,22 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    private void addTickData(NextTickListEntry<T> p_219504_1_) {
+      // Velox start: ServerTickList#addTickData threadsafe
+      this.lock.writeLock().lock();
       if (!this.tickNextTickSet.contains(p_219504_1_)) {
          this.tickNextTickSet.add(p_219504_1_);
          this.tickNextTickList.add(p_219504_1_);
       }
-
+      this.lock.writeLock().unlock();
+      // Velox end
    }
 
    public int size() {
-      return this.tickNextTickSet.size();
+      // Velox start: ServerTickList#size threadsafe
+      this.lock.readLock().lock();
+      int size = this.tickNextTickSet.size();
+      this.lock.readLock().unlock();
+      // Velox end
+      return size;
    }
 }
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerWorld.java b/src/main/java/net/minecraft/world/server/ServerWorld.java
index 7120174..c6e4509 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerWorld.java
+++ b/src/main/java/net/minecraft/world/server/ServerWorld.java
@@ -9,11 +9,11 @@ import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.longs.LongSets;
-import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
-import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.objects.*;
+
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
@@ -35,6 +35,12 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.chunk.ConcurrentChunkProvider;
+import me.mikex86.velox.optimizedtnt.OptimizedTnt;
+import me.mikex86.velox.tick.debug.MadMaxTickManager;
+import me.mikex86.velox.tick.global.WorldTickManager;
+import me.mikex86.velox.tick.ticklist.block.ConcurrentTickList;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockEventData;
 import net.minecraft.block.BlockState;
@@ -49,6 +55,7 @@ import net.minecraft.entity.MobEntity;
 import net.minecraft.entity.boss.dragon.EnderDragonEntity;
 import net.minecraft.entity.boss.dragon.EnderDragonPartEntity;
 import net.minecraft.entity.effect.LightningBoltEntity;
+import net.minecraft.entity.item.TNTEntity;
 import net.minecraft.entity.merchant.IReputationTracking;
 import net.minecraft.entity.merchant.IReputationType;
 import net.minecraft.entity.passive.AnimalEntity;
@@ -146,10 +153,18 @@ import org.apache.logging.log4j.Logger;
 public class ServerWorld extends World implements ISeedReader {
    public static final BlockPos END_SPAWN_POINT = new BlockPos(100, 50, 0);
    private static final Logger LOGGER = LogManager.getLogger();
-   private final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap<>();
-   private final Map<UUID, Entity> entitiesByUuid = Maps.newHashMap();
-   private final Queue<Entity> toAddAfterTick = Queues.newArrayDeque();
-   private final List<ServerPlayerEntity> players = Lists.newArrayList();
+   // Velox start: entitiesById threadsafe
+   private final Int2ObjectMap<Entity> entitiesById = Int2ObjectMaps.synchronize(new Int2ObjectLinkedOpenHashMap<>());
+   // Velox end
+   // Velox start: entitiesByUuid threadsafe
+   private final Map<UUID, Entity> entitiesByUuid = Maps.newConcurrentMap();
+   // Velox end
+   // Velox start: toAddAfterTick threadsafe
+   private final Queue<Entity> toAddAfterTick = Queues.newConcurrentLinkedQueue();
+   // Velox end
+   // Velox start: players list threadsafe
+   private final List<ServerPlayerEntity> players = Lists.newCopyOnWriteArrayList();
+   // Velox end
    private final ServerChunkProvider chunkSource;
    boolean tickingEntities;
    private final MinecraftServer server;
@@ -158,15 +173,23 @@ public class ServerWorld extends World implements ISeedReader {
    private boolean allPlayersSleeping;
    private int emptyTime;
    private final Teleporter portalForcer;
-   private final ServerTickList<Block> blockTicks = new ServerTickList<>(this, (p_205341_0_) -> {
+   // Velox start: blockTicks use ConcurrentTickList
+   private final ServerTickList<Block> blockTicks = new ConcurrentTickList<>(this, (p_205341_0_) -> {
       return p_205341_0_ == null || p_205341_0_.defaultBlockState().isAir();
    }, Registry.BLOCK::getKey, this::tickBlock);
-   private final ServerTickList<Fluid> liquidTicks = new ServerTickList<>(this, (p_205774_0_) -> {
+   // Velox end
+   // Velox start: liquidTicks use ConcurrentTickList
+   private final ServerTickList<Fluid> liquidTicks = new ConcurrentTickList<>(this, (p_205774_0_) -> {
       return p_205774_0_ == null || p_205774_0_ == Fluids.EMPTY;
    }, Registry.FLUID::getKey, this::tickLiquid);
-   private final Set<PathNavigator> navigations = Sets.newHashSet();
+   // Velox end
+   // Velox start: navigations threadsafe
+   private final Set<PathNavigator> navigations = Sets.newConcurrentHashSet();
+   // Velox end
    protected final RaidManager raids;
-   private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>();
+   // Velox start: blockEvents threadsafe
+   private final Queue<BlockEventData> blockEvents = Queues.newLinkedBlockingDeque();
+   // Velox end
    private boolean handlingTick;
    private final List<ISpecialSpawner> customSpawners;
    @Nullable
@@ -180,9 +203,11 @@ public class ServerWorld extends World implements ISeedReader {
       this.server = p_i241885_1_;
       this.customSpawners = p_i241885_12_;
       this.serverLevelData = p_i241885_4_;
-      this.chunkSource = new ServerChunkProvider(this, p_i241885_3_, p_i241885_1_.getFixerUpper(), p_i241885_1_.getStructureManager(), p_i241885_2_, p_i241885_8_, p_i241885_1_.getPlayerList().getViewDistance(), p_i241885_1_.forceSynchronousWrites(), p_i241885_7_, () -> {
+      // Velox start: Use ConcurrentChunkProvider
+      this.chunkSource = new ConcurrentChunkProvider(this, p_i241885_3_, p_i241885_1_.getFixerUpper(), p_i241885_1_.getStructureManager(), p_i241885_2_, p_i241885_8_, p_i241885_1_.getPlayerList().getViewDistance(), p_i241885_1_.forceSynchronousWrites(), p_i241885_7_, () -> {
          return p_i241885_1_.overworld().getDataStorage();
       });
+      // Velox end
       this.portalForcer = new Teleporter(this);
       this.updateSkyBrightness();
       this.prepareWeather();
@@ -344,75 +369,124 @@ public class ServerWorld extends World implements ISeedReader {
       }
 
       if (flag3 || this.emptyTime++ < 300) {
-         if (this.dragonFight != null) {
-            this.dragonFight.tick();
-         }
 
-         this.tickingEntities = true;
-         ObjectIterator<Entry<Entity>> objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();
+         // Velox start: Call Velox tick entities method
+         this.tickEntitiesVelox();
+         // Velox end
+      }
 
-         label164:
-         while(true) {
-            Entity entity1;
-            while(true) {
-               if (!objectiterator.hasNext()) {
-                  this.tickingEntities = false;
+      iprofiler.pop();
+   }
 
-                  Entity entity;
-                  while((entity = this.toAddAfterTick.poll()) != null) {
-                     this.add(entity);
-                  }
+   // Velox start: Velox tick entity method
+   private void tickEntitiesVelox() {
+      IProfiler profiler = this.getProfiler();
 
-                  this.tickBlockEntities();
-                  break label164;
-               }
+      if (this.dragonFight != null) {
+         this.dragonFight.tick();
+      }
 
-               Entry<Entity> entry = objectiterator.next();
-               entity1 = entry.getValue();
-               Entity entity2 = entity1.getVehicle();
-               if (!this.server.isSpawningAnimals() && (entity1 instanceof AnimalEntity || entity1 instanceof WaterMobEntity)) {
-                  entity1.remove();
-               }
+      this.tickingEntities = true;
 
-               if (!this.server.areNpcsEnabled() && entity1 instanceof INPC) {
-                  entity1.remove();
-               }
+      // run entityTickingTasks
+      while (!this.entityTickingTasks.isEmpty()) {
+         this.entityTickingTasks.remove().run();
+      }
 
-               iprofiler.push("checkDespawn");
-               if (!entity1.removed) {
-                  entity1.checkDespawn();
-               }
+      // check entities for removal
+      {
+         Stream<Entry<Entity>> entityStream = this.entitiesById.int2ObjectEntrySet().stream();
+         entityStream.forEach(entry -> {
+            Entity entity = entry.getValue();
 
-               iprofiler.pop();
-               if (entity2 == null) {
-                  break;
-               }
+            // Marks all animals for removal, if spawning of animals is disabled
+            if (!this.server.isSpawningAnimals() && (entity instanceof AnimalEntity || entity instanceof WaterMobEntity)) {
+               entity.remove();
+            }
 
-               if (entity2.removed || !entity2.hasPassenger(entity1)) {
-                  entity1.stopRiding();
-                  break;
-               }
+            // Marks all NPCs for removal, if spawning of NPCs is disabled
+            if (!this.server.areNpcsEnabled() && entity instanceof INPC) {
+               entity.remove();
             }
 
-            iprofiler.push("tick");
-            if (!entity1.removed && !(entity1 instanceof EnderDragonPartEntity)) {
-               this.guardEntityTick(this::tickNonPassenger, entity1);
+            profiler.push("checkDespawn");
+            // check if the entity should be de-spawned, if it isn't marked to get removed already
+            if (!entity.removed) {
+               entity.checkDespawn();
             }
+            profiler.pop();
 
-            iprofiler.pop();
-            iprofiler.push("remove");
-            if (entity1.removed) {
-               this.removeFromChunk(entity1);
-               objectiterator.remove();
-               this.onEntityRemoved(entity1);
+            // if a vehicle is present and it is marked for removal, the entity should stop riding that vehicle
+            Entity vehicle = entity.getVehicle();
+            if (vehicle != null && (vehicle.removed || !vehicle.hasPassenger(entity))) {
+               entity.stopRiding();
             }
+         });
+      }
 
-            iprofiler.pop();
+      {
+         if (MadMaxTickManager.MAD_MAX_MODE) {
+            // tick entities
+            // TODO: MAD MAX MODE PLUGIN TASK SUPPORT?
+            MadMaxTickManager.tickMadMax(this.entitiesById.values(), this::tickEntity);
+         } else {
+            // build tick list.
+            // Passengers are ticked after main entity tick in #tickNonPassenger.
+            // 1. Avoid double ticking passengers.
+            // 2. Do not tick TNTEntities here, TNT entities are ticked separately
+            this.regionTickManager.buildEntityTickList(this.entitiesById.values().iterator(), entity -> entity.getVehicle() == null && !(entity instanceof TNTEntity));
+
+            // Run Global world tick tasks.
+            // The region tick list is built when they run, but no state mutation to the world is happening. Important!
+            // The entity tick list is used to determine which entities are in which region.
+            WorldTickManager.runTasks(this);
+
+            // tick entities
+            this.regionTickManager.applyEntityTask(this::tickEntity);
+
+            // tick tnt
+            OptimizedTnt.performExplosions(this.entitiesById.values());
+         }
+      }
+      // remove all entities marked for removal from the entity lists (server global, chunk local, invoke listeners etc...)
+      {
+         Stream<Entry<Entity>> entityStream = this.entitiesById.int2ObjectEntrySet().stream();
+         entityStream.forEach(entry -> {
+            Entity entity = entry.getValue();
+            profiler.push("remove");
+            if (entity.removed) {
+               this.removeFromChunk(entity);
+               this.onEntityRemoved(entity);
+            }
+            profiler.pop();
+         });
+         this.entitiesById.int2ObjectEntrySet().removeIf(e -> e.getValue().removed);
+      }
+      this.tickingEntities = false;
+
+      // Add pending entities
+      {
+         Entity entity;
+         while ((entity = this.toAddAfterTick.poll()) != null) {
+            this.add(entity);
          }
       }
 
-      iprofiler.pop();
+      // tick block entities
+      this.tickBlockEntities();
    }
+   // Velox end
+
+   // Velox start: individual entity tick method
+   private void tickEntity(Entity entity) {
+      IProfiler profiler = this.getProfiler();
+      profiler.push("tick");
+      if (!entity.removed && !(entity instanceof EnderDragonPartEntity)) {
+         this.guardEntityTick(this::tickNonPassenger, entity);
+      }
+      profiler.pop();
+   }
+   // Velox end
 
    protected void tickTime() {
       if (this.tickTime) {
@@ -1019,7 +1093,9 @@ public class ServerWorld extends World implements ISeedReader {
 
    private void runBlockEvents() {
       while(!this.blockEvents.isEmpty()) {
-         BlockEventData blockeventdata = this.blockEvents.removeFirst();
+         // Velox start: blockEvents remove() instead of removeFirst()
+         BlockEventData blockeventdata = this.blockEvents.remove();
+         // Velox end
          if (this.doBlockEvent(blockeventdata)) {
             this.server.getPlayerList().broadcast((PlayerEntity)null, (double)blockeventdata.getPos().getX(), (double)blockeventdata.getPos().getY(), (double)blockeventdata.getPos().getZ(), 64.0D, this.dimension(), new SBlockActionPacket(blockeventdata.getPos(), blockeventdata.getBlock(), blockeventdata.getParamA(), blockeventdata.getParamB()));
          }
@@ -1410,4 +1486,16 @@ public class ServerWorld extends World implements ISeedReader {
          p_241121_0_.setBlockAndUpdate(p_241122_1_, Blocks.OBSIDIAN.defaultBlockState());
       });
    }
+
+   // Velox start: runTaskPreNextTick
+   private final Queue<Runnable> entityTickingTasks = Queues.newLinkedBlockingDeque();
+   /**
+    * Runs the specified runnable before the next tick starts. If the dimension is currently not being ticked, the
+    * task will not be executed until a player/forced chunk makes it tick.
+    * @param task the task to execute
+    */
+   public void runEntityTickingTaskNextTick(Runnable task) {
+      this.entityTickingTasks.add(task);
+   }
+   // Velox end
 }
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerWorldLightManager.java b/src/main/java/net/minecraft/world/server/ServerWorldLightManager.java
index 5d9de01..0d5114a 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerWorldLightManager.java
+++ b/src/main/java/net/minecraft/world/server/ServerWorldLightManager.java
@@ -26,7 +26,7 @@ import org.apache.logging.log4j.Logger;
 
 public class ServerWorldLightManager extends WorldLightManager implements AutoCloseable {
    private static final Logger LOGGER = LogManager.getLogger();
-   private final DelegatedTaskExecutor<Runnable> taskMailbox;
+   private final ITaskExecutor<Runnable> taskMailbox;
    private final ObjectList<Pair<ServerWorldLightManager.Phase, Runnable>> lightTasks = new ObjectArrayList<>();
    private final ChunkManager chunkMap;
    private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> sorterMailbox;
diff --git a/build/mcp_diff_src/net/minecraft/world/server/TicketManager.java b/src/main/java/net/minecraft/world/server/TicketManager.java
index 49f8f4a..caf86b2 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/TicketManager.java
+++ b/src/main/java/net/minecraft/world/server/TicketManager.java
@@ -1,25 +1,19 @@
 package net.minecraft.world.server;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2IntMap;
-import it.unimi.dsi.fastutil.longs.Long2IntMaps;
-import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
-import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import javax.annotation.Nullable;
 import net.minecraft.entity.player.ServerPlayerEntity;
 import net.minecraft.util.SortedArraySet;
@@ -36,7 +30,10 @@ import org.apache.logging.log4j.Logger;
 public abstract class TicketManager {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final int PLAYER_TICKET_LEVEL = 33 + ChunkStatus.getDistance(ChunkStatus.FULL) - 2;
-   private final Long2ObjectMap<ObjectSet<ServerPlayerEntity>> playersPerChunk = new Long2ObjectOpenHashMap<>();
+   // Velox start: Generalize to Map and Set
+   // Reason: Set and Map implementation now concurrent because EntityTracker modifies it concurrently
+   private final Map<Long, Set<ServerPlayerEntity>> playersPerChunk = Maps.newConcurrentMap();
+   // Velox end
    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap<>();
    private final TicketManager.ChunkTicketTracker ticketTracker = new TicketManager.ChunkTicketTracker();
    private final TicketManager.PlayerChunkTracker naturalSpawnChunkCounter = new TicketManager.PlayerChunkTracker(8);
@@ -58,7 +55,8 @@ public abstract class TicketManager {
       this.mainThreadExecutor = p_i50707_2_;
    }
 
-   protected void purgeStaleTickets() {
+   // Velox start: purgeStaleTickets threadsafe
+   protected synchronized void purgeStaleTickets() {
       ++this.ticketTickCounter;
       ObjectIterator<Entry<SortedArraySet<Ticket<?>>>> objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
 
@@ -76,6 +74,7 @@ public abstract class TicketManager {
       }
 
    }
+   // Velox end
 
    private static int getTicketLevelAt(SortedArraySet<Ticket<?>> p_229844_0_) {
       return !p_229844_0_.isEmpty() ? p_229844_0_.first().getTicketLevel() : ChunkManager.MAX_CHUNK_DISTANCE + 1;
@@ -89,7 +88,8 @@ public abstract class TicketManager {
    @Nullable
    protected abstract ChunkHolder updateChunkScheduling(long p_219372_1_, int p_219372_3_, @Nullable ChunkHolder p_219372_4_, int p_219372_5_);
 
-   public boolean runAllUpdates(ChunkManager p_219353_1_) {
+   // Velox start: runAllUpdates threadsafe
+   public synchronized boolean runAllUpdates(ChunkManager p_219353_1_) {
       this.naturalSpawnChunkCounter.runAllUpdates();
       this.playerTicketManager.runAllUpdates();
       int i = Integer.MAX_VALUE - this.ticketTracker.runDistanceUpdates(Integer.MAX_VALUE);
@@ -133,6 +133,7 @@ public abstract class TicketManager {
          return flag;
       }
    }
+   // Velox end
 
    private void addTicket(long p_219347_1_, Ticket<?> p_219347_3_) {
       SortedArraySet<Ticket<?>> sortedarrayset = this.getTickets(p_219347_1_);
@@ -157,23 +158,31 @@ public abstract class TicketManager {
       this.ticketTracker.update(p_219349_1_, getTicketLevelAt(sortedarrayset), false);
    }
 
-   public <T> void addTicket(TicketType<T> p_219356_1_, ChunkPos p_219356_2_, int p_219356_3_, T p_219356_4_) {
+   // Velox start: addTicket threadsafe
+   public synchronized <T> void addTicket(TicketType<T> p_219356_1_, ChunkPos p_219356_2_, int p_219356_3_, T p_219356_4_) {
       this.addTicket(p_219356_2_.toLong(), new Ticket<>(p_219356_1_, p_219356_3_, p_219356_4_));
    }
+   // Velox end
 
-   public <T> void removeTicket(TicketType<T> p_219345_1_, ChunkPos p_219345_2_, int p_219345_3_, T p_219345_4_) {
+   // Velox start: removeTicket threadsafe
+   public synchronized <T> void removeTicket(TicketType<T> p_219345_1_, ChunkPos p_219345_2_, int p_219345_3_, T p_219345_4_) {
       Ticket<T> ticket = new Ticket<>(p_219345_1_, p_219345_3_, p_219345_4_);
       this.removeTicket(p_219345_2_.toLong(), ticket);
    }
+   // Velox end
 
-   public <T> void addRegionTicket(TicketType<T> p_219331_1_, ChunkPos p_219331_2_, int p_219331_3_, T p_219331_4_) {
+   // Velox start: addRegionTicket threadsafe
+   public synchronized  <T> void addRegionTicket(TicketType<T> p_219331_1_, ChunkPos p_219331_2_, int p_219331_3_, T p_219331_4_) {
       this.addTicket(p_219331_2_.toLong(), new Ticket<>(p_219331_1_, 33 - p_219331_3_, p_219331_4_));
    }
+   // Velox end
 
-   public <T> void removeRegionTicket(TicketType<T> p_219362_1_, ChunkPos p_219362_2_, int p_219362_3_, T p_219362_4_) {
+   // Velox start: addRegionTicket threadsafe
+   public synchronized <T> void removeRegionTicket(TicketType<T> p_219362_1_, ChunkPos p_219362_2_, int p_219362_3_, T p_219362_4_) {
       Ticket<T> ticket = new Ticket<>(p_219362_1_, 33 - p_219362_3_, p_219362_4_);
       this.removeTicket(p_219362_2_.toLong(), ticket);
    }
+   // Velox end
 
    private SortedArraySet<Ticket<?>> getTickets(long p_229848_1_) {
       return this.tickets.computeIfAbsent(p_229848_1_, (p_229851_0_) -> {
@@ -181,7 +190,8 @@ public abstract class TicketManager {
       });
    }
 
-   protected void updateChunkForced(ChunkPos p_219364_1_, boolean p_219364_2_) {
+   // Velox start: updateChunkForced threadsafe
+   protected synchronized void updateChunkForced(ChunkPos p_219364_1_, boolean p_219364_2_) {
       Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, 31, p_219364_1_);
       if (p_219364_2_) {
          this.addTicket(p_219364_1_.toLong(), ticket);
@@ -190,11 +200,15 @@ public abstract class TicketManager {
       }
 
    }
+   // Velox end
 
    public void addPlayer(SectionPos p_219341_1_, ServerPlayerEntity p_219341_2_) {
       long i = p_219341_1_.chunk().toLong();
       this.playersPerChunk.computeIfAbsent(i, (p_219361_0_) -> {
-         return new ObjectOpenHashSet();
+         // Velox start: Use concurrent hash set
+         // Reason: Entity tracker modifies concurrently
+         return Sets.newConcurrentHashSet();
+         // Velox end
       }).add(p_219341_2_);
       this.naturalSpawnChunkCounter.update(i, 0, true);
       this.playerTicketManager.update(i, 0, true);
@@ -202,7 +216,10 @@ public abstract class TicketManager {
 
    public void removePlayer(SectionPos p_219367_1_, ServerPlayerEntity p_219367_2_) {
       long i = p_219367_1_.chunk().toLong();
-      ObjectSet<ServerPlayerEntity> objectset = this.playersPerChunk.get(i);
+      // Velox start: Generalize to Set
+      // Reason: Set implementation now concurrent because EntityTracker modifies it concurrently
+      Set<ServerPlayerEntity> objectset = this.playersPerChunk.get(i);
+      // Velox end
       objectset.remove(p_219367_2_);
       if (objectset.isEmpty()) {
          this.playersPerChunk.remove(i);
@@ -212,7 +229,8 @@ public abstract class TicketManager {
 
    }
 
-   protected String getTicketDebugString(long p_225413_1_) {
+   // Velox start: getTicketDebugString threadsafe
+   protected synchronized String getTicketDebugString(long p_225413_1_) {
       SortedArraySet<Ticket<?>> sortedarrayset = this.tickets.get(p_225413_1_);
       String s;
       if (sortedarrayset != null && !sortedarrayset.isEmpty()) {
@@ -223,10 +241,13 @@ public abstract class TicketManager {
 
       return s;
    }
+   // Velox end
 
-   protected void updatePlayerTickets(int p_219354_1_) {
+   // Velox start: updatePlayerTickets threadsafe
+   protected synchronized void updatePlayerTickets(int p_219354_1_) {
       this.playerTicketManager.updateViewDistance(p_219354_1_);
    }
+   // Velox end
 
    public int getNaturalSpawnChunkCount() {
       this.naturalSpawnChunkCounter.runAllUpdates();
@@ -284,9 +305,12 @@ public abstract class TicketManager {
       }
    }
 
+   // Velox start: PlayerChunkTracker threadsafe.
+   // Reason: Invoked by EntityTracker
    class PlayerChunkTracker extends ChunkDistanceGraph {
-      protected final Long2ByteMap chunks = new Long2ByteOpenHashMap();
+      protected final Long2ByteMap chunks = Long2ByteMaps.synchronize(new Long2ByteOpenHashMap());
       protected final int maxDistance;
+      private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
       protected PlayerChunkTracker(int p_i50684_2_) {
          super(p_i50684_2_ + 2, 16, 256);
@@ -294,19 +318,30 @@ public abstract class TicketManager {
          this.chunks.defaultReturnValue((byte)(p_i50684_2_ + 2));
       }
 
+      @Override
+      public void update(long p_215491_1_, int p_215491_3_, boolean p_215491_4_) {
+         this.lock.writeLock().lock();
+         super.update(p_215491_1_, p_215491_3_, p_215491_4_);
+         this.lock.writeLock().unlock();
+      }
+
       protected int getLevel(long p_215471_1_) {
-         return this.chunks.get(p_215471_1_);
+         this.lock.readLock().lock();
+         byte level = this.chunks.get(p_215471_1_);
+         this.lock.readLock().unlock();
+         return level;
       }
 
       protected void setLevel(long p_215476_1_, int p_215476_3_) {
+         this.lock.writeLock().lock();
          byte b0;
          if (p_215476_3_ > this.maxDistance) {
             b0 = this.chunks.remove(p_215476_1_);
          } else {
             b0 = this.chunks.put(p_215476_1_, (byte)p_215476_3_);
          }
-
          this.onLevelChange(p_215476_1_, b0, p_215476_3_);
+         this.lock.writeLock().unlock();
       }
 
       protected void onLevelChange(long p_215495_1_, int p_215495_3_, int p_215495_4_) {
@@ -317,19 +352,28 @@ public abstract class TicketManager {
       }
 
       private boolean havePlayer(long p_215496_1_) {
-         ObjectSet<ServerPlayerEntity> objectset = TicketManager.this.playersPerChunk.get(p_215496_1_);
+         this.lock.readLock().lock();
+         Set<ServerPlayerEntity> objectset = TicketManager.this.playersPerChunk.get(p_215496_1_);
+         this.lock.readLock().unlock();
          return objectset != null && !objectset.isEmpty();
       }
 
       public void runAllUpdates() {
+         this.lock.writeLock().lock();
          this.runUpdates(Integer.MAX_VALUE);
+         this.lock.writeLock().unlock();
       }
    }
+   // Velox end
 
+   // Velox start: PlayerChunkTracker threadsafe.
+   // Reason: Invoked by EntityTracker
+   // Comment: The vanilla version seems partially threadsafe. WTF?
    class PlayerTicketTracker extends TicketManager.PlayerChunkTracker {
       private int viewDistance;
       private final Long2IntMap queueLevels = Long2IntMaps.synchronize(new Long2IntOpenHashMap());
-      private final LongSet toUpdate = new LongOpenHashSet();
+      private final LongSet toUpdate = LongSets.synchronize(new LongOpenHashSet());
+      private final ReadWriteLock toUpdateLock = new ReentrantReadWriteLock();
 
       protected PlayerTicketTracker(int p_i50682_2_) {
          super(p_i50682_2_);
@@ -338,7 +382,9 @@ public abstract class TicketManager {
       }
 
       protected void onLevelChange(long p_215495_1_, int p_215495_3_, int p_215495_4_) {
+         this.toUpdateLock.writeLock().lock();
          this.toUpdate.add(p_215495_1_);
+         this.toUpdateLock.writeLock().unlock();
       }
 
       public void updateViewDistance(int p_215508_1_) {
@@ -381,6 +427,7 @@ public abstract class TicketManager {
       }
 
       public void runAllUpdates() {
+         this.toUpdateLock.writeLock().lock();
          super.runAllUpdates();
          if (!this.toUpdate.isEmpty()) {
             LongIterator longiterator = this.toUpdate.iterator();
@@ -406,11 +453,12 @@ public abstract class TicketManager {
 
             this.toUpdate.clear();
          }
-
+         this.toUpdateLock.writeLock().unlock();
       }
 
       private boolean haveTicketFor(int p_215505_1_) {
          return p_215505_1_ <= this.viewDistance - 2;
       }
    }
+   // Velox end
 }
