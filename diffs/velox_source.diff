diff --git a/src/main/java/me/mikex86/velox/chunk/ChunkLoadStatePrinter.java b/src/main/java/me/mikex86/velox/chunk/ChunkLoadStatePrinter.java
new file mode 100644
index 0000000..7641dab
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/ChunkLoadStatePrinter.java
@@ -0,0 +1,62 @@
+package me.mikex86.velox.chunk;
+
+import me.mikex86.velox.tick.TickRegionManager;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.*;
+
+import javax.imageio.ImageIO;
+import java.awt.*;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * A debug utility to print chunk load states onto an image saved in the folder "chunks_states".
+ */
+public class ChunkLoadStatePrinter {
+
+    public static void printChunkLoadState(TickRegionManager manager, Chunk currentlyUnloading) {
+        int xStart = -2000, zStart = -2000;
+        int xEnd = 2000, zEnd = 2000;
+        BufferedImage image = new BufferedImage(xEnd - xStart, zEnd - zStart, BufferedImage.TYPE_4BYTE_ABGR);
+        for (int x = xStart; x < xEnd; x++) {
+            for (int z = zStart; z < zEnd; z++) {
+
+                int rgb;
+                ChunkPos pos = currentlyUnloading.getPos();
+                if (pos.x == x && pos.z == z) {
+                    rgb = Color.MAGENTA.getRGB();
+                } else {
+                    Chunk chunk = manager.getChunk(x, z);
+                    if (chunk == null) {
+                        rgb = Color.BLACK.getRGB();
+                    } else {
+                        boolean loaded = chunk.isLoaded();
+                        if (loaded)
+                            rgb = Color.GREEN.getRGB();
+                        else
+                            rgb = Color.RED.getRGB();
+                    }
+                }
+                image.setRGB(x - xStart, z - zStart, rgb);
+            }
+        }
+        try {
+            ImageIO.write(image, "PNG", getNextFile());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static File getNextFile() {
+        File file;
+        int counter = 0;
+        do {
+            file = new File("chunk_states/state_" + counter + ".png");
+            file.getParentFile().mkdirs();
+            counter++;
+        } while (file.exists());
+        return file;
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/chunk/ConcurrentChunkProvider.java b/src/main/java/me/mikex86/velox/chunk/ConcurrentChunkProvider.java
new file mode 100644
index 0000000..84b4b32
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/ConcurrentChunkProvider.java
@@ -0,0 +1,184 @@
+package me.mikex86.velox.chunk;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+
+import com.google.common.cache.CacheBuilder;
+import me.mikex86.velox.utils.ArrayUtils;
+import me.mikex86.velox.utils.PeriodicInvoker;
+import me.mikex86.velox.utils.cache.LossyLongChunkCache;
+import me.mikex86.velox.utils.cache.guava.AccessCountingCache;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.server.ServerChunkProvider;
+import net.minecraft.world.server.ServerWorld;
+
+import com.mojang.datafixers.DataFixer;
+
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.IChunk;
+import net.minecraft.world.chunk.listener.IChunkStatusListener;
+import net.minecraft.world.gen.ChunkGenerator;
+import net.minecraft.world.gen.feature.template.TemplateManager;
+import net.minecraft.world.storage.DimensionSavedDataManager;
+
+import net.minecraft.world.storage.SaveFormat.LevelSave;
+
+public class ConcurrentChunkProvider extends ServerChunkProvider {
+
+    // TODO: MAKE CACHES CONFIGURABLE
+
+    /**
+     * A fast, lossy, l1 cache.
+     * Index collisions are fairly likely to occur, in which case we just miss.
+     * Point is, this cache misses all the time.
+     * Hash collisions are also not handled.
+     * Good that the packed chunk pos long format does not produce these collisions.
+     */
+    private final LossyLongChunkCache l1Cache = new LossyLongChunkCache(256);
+
+    /**
+     * A bigger, slower (~ 10 times slower than L1), more sophisticated cache.
+     * (Still better than fallback, ~10 times slower than L2)
+     */
+    private final AccessCountingCache<Long, IChunk> l2Cache = AccessCountingCache.wrap(CacheBuilder.newBuilder()
+            .maximumSize(2048)
+            .expireAfterAccess(3, TimeUnit.MINUTES)
+            .build());
+
+    public ConcurrentChunkProvider(ServerWorld worldIn, LevelSave worldDirectory, DataFixer dataFixer,
+                                   TemplateManager templateManagerIn, Executor executorIn, ChunkGenerator chunkGeneratorIn, int viewDistance,
+                                   boolean spawnHostiles, IChunkStatusListener p_i51537_8_, Supplier<DimensionSavedDataManager> p_i51537_9_) {
+        super(worldIn, worldDirectory, dataFixer, templateManagerIn, executorIn, chunkGeneratorIn, viewDistance, spawnHostiles, p_i51537_8_, p_i51537_9_);
+        Thread cacheCleaner = new Thread(new PeriodicInvoker(this.l2Cache::cleanUp, 1000, TimeUnit.MILLISECONDS), "ChunkCacheCleaner");
+        cacheCleaner.setDaemon(true);
+        cacheCleaner.start();
+
+        Thread printStatsThread = new Thread(new PeriodicInvoker(this::printCacheStats, 20_000, TimeUnit.MILLISECONDS));
+        printStatsThread.setDaemon(true);
+        printStatsThread.start();
+    }
+
+    private long l1Time;
+    private long l2Time;
+    private long l1Hits;
+    private long l2Hits;
+    private long l1Accesses;
+    private long l2Accesses;
+    private long fallbackAccesses;
+    private long nPostLookupsPerformed;
+    private long totalAccesses;
+    private long postLookupTime;
+    private long fallbackTime;
+
+    @Override
+    protected IChunk lookupChunkCache(long packedChunkPos, ChunkStatus requiredStatus, boolean load) {
+        totalAccesses++;
+        IChunk chunk;
+        // Query L1 cache
+        {
+            long start = System.nanoTime();
+            chunk = this.l1Cache.get(packedChunkPos);
+            long end = System.nanoTime();
+            l1Time += (end - start);
+            l1Accesses++;
+            if (chunk != null)
+                l1Hits++;
+        }
+
+        if (chunk == null) {
+            long start = System.nanoTime();
+            chunk = this.l2Cache.getIfPresent(packedChunkPos);
+            long end = System.nanoTime();
+            l2Time += (end - start);
+            l2Accesses++;
+            if (chunk != null)
+                l2Hits++;
+        }
+
+        if (chunk == null) {
+            return null; // All caches have missed
+        }
+
+        long postLookupStart = System.nanoTime();
+        // We don't want to somehow mix the status into the cache key
+        // so we have to do this terribleness to miss if the required
+        // status is not sufficient or the cached value a previous status
+        // that is no longer valid.
+        // These instances need to be GCd as fast as possible.
+        // We therefore explicitly evict these instance from all caches
+        if (!chunk.getStatus().isAtLeast(requiredStatus)) {
+            return null;
+        }
+        if (requiredStatus == ChunkStatus.FULL && !(chunk instanceof Chunk)) {
+            this.cacheEvict(packedChunkPos, chunk);
+            return null;
+        }
+        long postLookupEnd = System.nanoTime();
+        postLookupTime += (postLookupEnd - postLookupStart);
+        nPostLookupsPerformed++;
+        return chunk;
+    }
+
+    @Override
+    protected IChunk fallbackLookup(int chunkX, int chunkZ, ChunkStatus requiredStatus, boolean load) {
+        long start = System.nanoTime();
+        IChunk chunk = super.fallbackLookup(chunkX, chunkZ, requiredStatus, load);
+        long end = System.nanoTime();
+        fallbackTime += (end - start);
+        fallbackAccesses++;
+        return chunk;
+    }
+
+    private void cacheEvict(long key, IChunk chunk) {
+        this.l1Cache.invalidate(key, chunk);
+        this.l2Cache.invalidate(key);
+    }
+
+    private int populateCacheCalls = 0;
+
+    @Override
+    protected void populateChunkCache(int chunkX, int chunkZ, IChunk chunk) {
+        long key = ChunkPos.asLong(chunkX, chunkZ);
+
+        // Populate L2 cache
+        this.l2Cache.put(key, chunk);
+
+        // Populate L1 cache with the most popular values of L2
+        // every 16 cache population calls
+        if (this.populateCacheCalls++ % 16 == 0) {
+            int capacity = this.l1Cache.getCapacity();
+            Long[] keysBoxed = new Long[capacity];
+            IChunk[] values = new IChunk[capacity];
+            this.l2Cache.retrieveMostAccessedValues(keysBoxed, values);
+            long[] keys = ArrayUtils.unbox(keysBoxed);
+            this.l1Cache.populate(keys, values);
+        }
+    }
+
+    @Override
+    protected void invalidateCaches() {
+        this.l1Cache.clear();
+        this.l2Cache.invalidateAll();
+    }
+
+    private void printCacheStats() {
+        if (totalAccesses == 0)
+            return;
+        synchronized (ConcurrentChunkProvider.class) {
+            System.out.println(this.world.getProviderName());
+            System.out.println("---------------------------------------------");
+            System.out.println(String.format("L1 hit rate: %.2f%%", (this.l1Hits / (double) this.totalAccesses) * 100));
+            System.out.println(String.format("L2 hit rate: %.2f%%", (this.l2Hits / (double) this.totalAccesses) * 100));
+            System.out.println(String.format("Fallback rate: %.2f%%", (this.fallbackAccesses / (double) this.totalAccesses) * 100));
+            System.out.println("---------------------------------------------");
+            System.out.println(String.format("L1 avg access time: %.2f ns", (this.l1Time / (double) this.l1Accesses)));
+            System.out.println(String.format("L2 avg access time: %.2f ns", (this.l2Time / (double) this.l2Accesses)));
+            System.out.println(String.format("Post lookup avg time: %.2f ns", (this.postLookupTime / (double) this.nPostLookupsPerformed)));
+            System.out.println(String.format("Fallback avg access time: %.2f ns", (this.fallbackTime / (double) this.fallbackAccesses)));
+            System.out.println("---------------------------------------------");
+            System.out.flush();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/mikex86/velox/tick/MadMaxTickManager.java b/src/main/java/me/mikex86/velox/tick/MadMaxTickManager.java
new file mode 100644
index 0000000..dcea303
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/MadMaxTickManager.java
@@ -0,0 +1,45 @@
+package me.mikex86.velox.tick;
+
+import com.google.common.collect.Lists;
+import me.mikex86.velox.utils.Streamer;
+import net.minecraft.entity.Entity;
+
+import java.util.Collection;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+import java.util.function.Consumer;
+
+/**
+ * A tick model that provokes thread safety errors by just streaming all entities in optimal batch sizes on all cores.
+ * This is horrendously unsafe
+ */
+public class MadMaxTickManager {
+
+    /**
+     * Whether mad max mode is enabled
+     * Debug/Development feature only.
+     */
+    public static boolean MAD_MAX_MODE = false;
+
+    private static final int nThreads = Runtime.getRuntime().availableProcessors();
+    private static final ExecutorService service = MAD_MAX_MODE ? Executors.newFixedThreadPool(nThreads, new ThreadFactory() {
+        private int nThreads = 0;
+        @Override
+        public Thread newThread(Runnable runnable) {
+            Thread thread = new Thread(runnable, "MadMaxTickWorker-" + nThreads++);
+            thread.setDaemon(true);
+            return thread;
+        }
+    }) : null;
+
+    public static void tickMadMax(Collection<Entity> entities, Consumer<Entity> action) {
+        entities = Lists.newArrayList(entities);
+        try {
+            Streamer.streamBatched(service, nThreads, entities, action);
+        } catch (InterruptedException | ExecutionException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/TickRegion.java b/src/main/java/me/mikex86/velox/tick/TickRegion.java
new file mode 100644
index 0000000..a900813
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/TickRegion.java
@@ -0,0 +1,154 @@
+package me.mikex86.velox.tick;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+
+import java.util.*;
+import java.util.function.Consumer;
+
+public class TickRegion {
+
+    private final Map<ChunkPos, Chunk> chunkMap = Maps.newHashMap();
+    private final List<Entity> entityTickList = Lists.newArrayList();
+
+    public boolean addChunk(Chunk chunk) {
+        return this.chunkMap.put(chunk.getPos(), chunk) == null;
+    }
+
+    public boolean removeChunk(Chunk chunk) {
+        return this.chunkMap.remove(chunk.getPos()) != null;
+    }
+
+    public void clearEntityTickList() {
+        this.entityTickList.clear();
+    }
+
+    public void addToEntityTickList(Entity entity) {
+        this.entityTickList.add(entity);
+    }
+
+    public void applyTaskToEntityTickList(Consumer<Entity> entityTask) {
+        for (Entity entity : this.entityTickList) {
+            entityTask.accept(entity);
+        }
+    }
+
+    public boolean containsOrBorders(Chunk chunk) {
+        ChunkPos chunkPos = chunk.getPos();
+        for (Chunk regionChunk : this.chunkMap.values()) {
+            ChunkPos regionChunkPos = regionChunk.getPos();
+            int xDif = Math.abs(regionChunkPos.x - chunkPos.x);
+            int zDif = Math.abs(regionChunkPos.z - chunkPos.z);
+
+            // the distance can either be 0 or 1 on both xDif and zDif for "chunk" to either
+            // be at the same position as "regionChunkPos" or border it.
+            if (Math.max(xDif, zDif) <= 1) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isEmpty() {
+        return this.chunkMap.isEmpty();
+    }
+
+    public void merge(TickRegion srcRegion) {
+        this.chunkMap.putAll(srcRegion.chunkMap);
+    }
+
+    @Override
+    public String toString() {
+        return "Region{" +
+                "numChunks=" + this.chunkMap.size() +
+                '}';
+    }
+
+    public Collection<Chunk> getChunks() {
+        return chunkMap.values();
+    }
+
+    List<Chunk> floodFillFromChunkUntilChunk(Chunk startChunk, Chunk endChunk) {
+        List<Chunk> floodFilledChunks = Lists.newArrayList();
+        Set<Chunk> visited = Sets.newHashSet();
+
+        Queue<Chunk> chunkFloodQueue = Lists.newLinkedList();
+        chunkFloodQueue.add(startChunk);
+
+        while (!chunkFloodQueue.isEmpty()) {
+            Chunk chunk = chunkFloodQueue.remove();
+            if (floodFilledChunks.contains(chunk))
+                System.err.println("Wuiuiui");
+            else
+                floodFilledChunks.add(chunk);
+
+            visited.add(chunk);
+            if (chunk == endChunk) {
+                break;
+            }
+            getNeighbors(false, chunkFloodQueue, visited, chunk);
+        }
+
+        return floodFilledChunks;
+    }
+
+//    List<Chunk> floodFillFromChunk(Chunk firstChunk) {
+//        List<Chunk> floodFilledChunks = Lists.newLinkedList();
+//
+//        Set<Chunk> chunkFloodSet = Sets.newHashSet();
+//        chunkFloodSet.add(firstChunk);
+//
+//        while (!chunkFloodSet.isEmpty()) {
+//            Chunk chunk = chunkFloodSet.iterator().next();
+//            floodFilledChunks.add(chunk);
+//            getNeighbors(chunkFloodSet, chunk);
+//        }
+//
+//        return floodFilledChunks;
+//    }
+
+    void getNeighbors(boolean addNulls, Collection<Chunk> dst, Collection<Chunk> visited, Chunk chunk) {
+        ChunkPos pos = chunk.getPos();
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x - 1, pos.z);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x + 1, pos.z);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x, pos.z - 1);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x, pos.z + 1);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+    }
+
+    public Chunk getChunk(int blockX, int blockZ) {
+        ChunkPos chunkPos = new ChunkPos(blockX >> 4, blockZ >> 4);
+        return this.chunkMap.get(chunkPos);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/TickRegionManager.java b/src/main/java/me/mikex86/velox/tick/TickRegionManager.java
new file mode 100644
index 0000000..30fdda3
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/TickRegionManager.java
@@ -0,0 +1,284 @@
+package me.mikex86.velox.tick;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.server.ChunkManager;
+import net.minecraft.world.server.ServerChunkProvider;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.function.Consumer;
+
+/**
+ * Creates and destroys regions when chunks are loaded/unloaded.
+ * <p>
+ * Delegates tick list building and the scheduling of tasks on those tick lists to the individual regions.
+ */
+public class TickRegionManager {
+
+    private static final int nThreads = Runtime.getRuntime().availableProcessors();
+
+    // TODO: This is only static because multiple TickRegionManager instances can exist that should not have a service on their own claiming every core
+    // TODO: Config options
+    private static final ExecutorService service = new ThreadPoolExecutor(nThreads, nThreads,
+            0L, TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<>(),
+            new ThreadFactory() {
+
+                private int nThreads = 0;
+
+                @Override
+                public Thread newThread(Runnable runnable) {
+                    Thread thread = new Thread(runnable, "TickWorker-" + nThreads);
+                    thread.setDaemon(true);
+                    nThreads++;
+                    return thread;
+                }
+            });
+
+    /**
+     * List containing all existing regions
+     */
+    private final List<TickRegion> regionList = Lists.newArrayList();
+
+    /**
+     * Maps the position of chunks to the TickRegion they are part of
+     */
+    private final Map<ChunkPos, TickRegion> tickRegionMap = Maps.newHashMap();
+
+    /**
+     * A lock to ensure thread safe access to the TickRegionManager state
+     */
+    private final ReadWriteLock lock = new ReentrantReadWriteLock();
+
+    /**
+     * Invoked when a chunk is either loaded or unloaded.
+     * The method will rebuild regions accordingly.
+     *
+     * @param chunk        the chunk that is getting loaded/unloaded
+     * @param newLoadState the new load state of the chunk. true, if the chunk is getting loaded, false if the chunk is getting unloaded.
+     */
+    public void informChunkLoadStateChange(Chunk chunk, boolean newLoadState) {
+        long start = System.currentTimeMillis();
+        this.lock.writeLock().lock();
+        try {
+            TickRegion chunkDstRegion = this.findRegion(chunk);
+            if (chunkDstRegion == null) {
+                chunkDstRegion = createRegion();
+            }
+            if (newLoadState) {
+                boolean modified = addChunkToRegion(chunkDstRegion, chunk);
+                if (!modified) {
+                    throw new IllegalStateException("Chunk was already contained in it's region before it was even loaded. This should never happen");
+                }
+                // Merge bordering regions:
+                // Checks if "chunk" borders any region that is not its current region.
+                // Removes the other region after adding its
+                // chunks to the region of "chunk"
+                for (Iterator<TickRegion> iterator = this.regionList.iterator(); iterator.hasNext(); ) {
+                    TickRegion region = iterator.next();
+                    if (region == chunkDstRegion) continue;
+                    if (region.containsOrBorders(chunk)) {
+                        mergeRegion(chunkDstRegion, region);
+                        iterator.remove();
+                    }
+                }
+            } else {
+                boolean modified = chunkDstRegion.removeChunk(chunk);
+                if (!modified) {
+                    throw new IllegalStateException("Chunk was already contained in it's region before it was even loaded. This should never happen");
+                }
+                if (chunkDstRegion.isEmpty()) {
+                    removeRegion(chunkDstRegion);
+                } else {
+                    checkRegionSplit(chunkDstRegion, chunk);
+                }
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+        long end = System.currentTimeMillis();
+//        System.out.println("informChunkLoadStateChange(" + newLoadState + ") took: " + (end - start) + " ms; " + this);
+    }
+
+    // not thread safe
+    private void checkRegionSplit(TickRegion region, Chunk unloadedChunk) {
+        ChunkManager chunkManager = ((ServerChunkProvider) unloadedChunk.getWorld().getChunkProvider()).chunkManager;
+        // Split the region if it is not continuous.
+        // Check for non continuity by checking if you can travel between
+        // the neighboring chunks of the chunk that has just been unloaded.
+        // We will create max. 4 regions in the worst case.
+
+        Collection<Chunk> allChunks = region.getChunks();
+
+        List<Chunk> neighbors = Lists.newArrayListWithCapacity(4);
+        region.getNeighbors(true, neighbors, Lists.newArrayList(), unloadedChunk);
+
+        assert neighbors.size() == 4;
+
+        for (int i = 0; i < neighbors.size() - 1; i++) {
+            Chunk neighbor1 = neighbors.get(i);
+            Chunk neighbor2 = neighbors.get(i + 1);
+            if (neighbor1 == null || neighbor2 == null)
+                continue;
+            List<Chunk> chunks = region.floodFillFromChunkUntilChunk(neighbor1, neighbor2);
+            Chunk lastChunk = chunks.get(chunks.size() - 1);
+            if (lastChunk != neighbor2) {
+                // we have not reached the neighboring chunk, the neighbors are in different regions
+                // if that is the case, "chunks" contains all chunks part of that region, because the flood fill didn't early stop.
+                if (!chunks.equals(allChunks)) {
+
+                    // Create new region with just the "chunks" list.
+                    // "chunks" may contain chunks that are pending unload.
+                    // In the worst case scenario, they are all pending unload, eg. on teleport.
+                    // In that case chunks will unload in basically random order resulting in catastrophically
+                    // high region complexity for the short time until those regions are deleted.
+                    // In that case, we don't want to even create a region, thus the initial null value of "newRegion".
+
+                    TickRegion newRegion = null;
+                    for (Chunk chunk : chunks) {
+                        if (chunkManager.chunksToUnload.containsKey(chunk.getPos().asLong())) {
+                            // Don't add this chunk to the new region, it is pending unload.
+                            // We are not yet removing it from the old region: When the chunk
+                            // is actually unloaded, #informChunkLoadStateChange will be invoked anyways.
+                            // Ticks might still be performed in those chunks. If we were to remove these from the region now,
+                            // these ticks could simply not be performed.
+                            continue;
+                        }
+                        // Create the region only then, when we know that at least one
+                        // chunk actually gets added to it.
+                        if (newRegion == null) {
+                            newRegion = createRegion();
+                        }
+                        newRegion.addChunk(chunk);
+                        region.removeChunk(chunk);
+                        if (region.isEmpty()) {
+                            removeRegion(region);
+                        }
+                        this.tickRegionMap.put(chunk.getPos(), newRegion);
+                    }
+                }
+            }
+        }
+    }
+
+    public void buildEntityTickList(Iterator<Entity> entityIt) {
+        this.lock.writeLock().lock();
+        try {
+            for (TickRegion region : this.regionList) {
+                region.clearEntityTickList();
+            }
+            while (entityIt.hasNext()) {
+                Entity entity = entityIt.next();
+                BlockPos bp = entity.getPosition();
+                TickRegion region = this.lookupRegion(bp.getX(), bp.getZ());
+                if (region == null) {
+                    // TODO: use a dummy region for these maybe existent edge cases?
+                    System.err.println("Could not find region for entity: " + entity);
+                } else {
+                    region.addToEntityTickList(entity);
+                }
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+    }
+
+    public void applyEntityTask(Consumer<Entity> entityTask) {
+        this.lock.readLock().lock();
+        try {
+            CountDownLatch latch = new CountDownLatch(this.regionList.size());
+            for (TickRegion region : this.regionList) {
+                service.submit(() -> {
+                    try {
+                        region.applyTaskToEntityTickList(entityTask);
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    } finally {
+                        latch.countDown();
+                    }
+                });
+            }
+            latch.await();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        } finally {
+            this.lock.readLock().unlock();
+        }
+    }
+
+
+    // not thread safe
+    private TickRegion lookupRegion(int blockX, int blockZ) {
+        ChunkPos chunkPos = new ChunkPos(blockX >> 4, blockZ >> 4);
+        return this.tickRegionMap.get(chunkPos);
+    }
+
+    // not thread safe
+    private boolean addChunkToRegion(TickRegion region, Chunk chunk) {
+        this.tickRegionMap.put(chunk.getPos(), region);
+        return region.addChunk(chunk);
+    }
+
+    /**
+     * Merges the two regions.
+     *
+     * @param dstRegion the region to merge into
+     * @param srcRegion the region whose chunks should be merged into the other region
+     */
+    // not thread safe
+    private void mergeRegion(TickRegion dstRegion, TickRegion srcRegion) {
+        dstRegion.merge(srcRegion);
+        Collection<Chunk> chunks = srcRegion.getChunks();
+        for (Chunk chunk : chunks) {
+            this.tickRegionMap.put(chunk.getPos(), dstRegion);
+        }
+    }
+
+    // not thread safe
+    private void removeRegion(TickRegion region) {
+        Collection<Chunk> chunks = region.getChunks();
+        for (Chunk chunk : chunks) {
+            this.tickRegionMap.remove(chunk.getPos());
+        }
+        this.regionList.remove(region);
+    }
+
+    // not thread safe
+    private TickRegion createRegion() {
+        TickRegion region = new TickRegion();
+        this.regionList.add(region);
+        return region;
+    }
+
+    // not thread safe
+    private TickRegion findRegion(Chunk chunk) {
+        for (TickRegion region : this.regionList) {
+            if (region.containsOrBorders(chunk)) {
+                return region;
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public String toString() {
+        return "RegionManager{" +
+                "numRegions=" + this.regionList.size() + ", " +
+                "regionList=" + this.regionList +
+                '}';
+    }
+
+    public Chunk getChunk(int x, int z) {
+        TickRegion region = this.lookupRegion(x, z);
+        if (region == null)
+            return null;
+        return region.getChunk(x, z);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/ArrayUtils.java b/src/main/java/me/mikex86/velox/utils/ArrayUtils.java
new file mode 100644
index 0000000..e6fdbb6
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/ArrayUtils.java
@@ -0,0 +1,23 @@
+package me.mikex86.velox.utils;
+
+public class ArrayUtils {
+
+    public static int[] unbox(Integer[] boxed) {
+        int[] unboxed = new int[boxed.length];
+        for (int i = 0; i < boxed.length; i++) {
+            Integer integer = boxed[i];
+            unboxed[i] = integer == null ? 0 : integer;
+        }
+        return unboxed;
+    }
+
+    public static long[] unbox(Long[] boxed) {
+        long[] unboxed = new long[boxed.length];
+        for (int i = 0; i < boxed.length; i++) {
+            Long aLong = boxed[i];
+            unboxed[i] = aLong == null ? 0 : aLong;
+        }
+        return unboxed;
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/utils/IteratorUtils.java b/src/main/java/me/mikex86/velox/utils/IteratorUtils.java
new file mode 100644
index 0000000..bc77dd0
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/IteratorUtils.java
@@ -0,0 +1,17 @@
+package me.mikex86.velox.utils;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class IteratorUtils {
+
+    public static <T> List<T> collect(Iterator<T> iterator) {
+        List<T> values = new ArrayList<>();
+        while (iterator.hasNext()) {
+            values.add(iterator.next());
+        }
+        return values;
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/utils/MathUtils.java b/src/main/java/me/mikex86/velox/utils/MathUtils.java
new file mode 100644
index 0000000..c457e20
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/MathUtils.java
@@ -0,0 +1,28 @@
+package me.mikex86.velox.utils;
+
+import static java.lang.Math.floorDiv;
+
+public class MathUtils {
+
+    /**
+     * Uses crazy standford magic to round up to the next power of two.
+     * For zero, it will return back zero again. This is a small anomaly of the function
+     * for performance reasons.
+     * @param n a given number
+     * @return the next power of two after (or equal to) n
+     */
+    public static int npot(int n) {
+        n--;
+        n |= n >> 1;
+        n |= n >> 2;
+        n |= n >> 4;
+        n |= n >> 8;
+        n |= n >> 16;
+        n++;
+        return n;
+    }
+
+    public static long floorMod(long x, long y) {
+        return x - floorDiv(x, y) * y;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/PeriodicInvoker.java b/src/main/java/me/mikex86/velox/utils/PeriodicInvoker.java
new file mode 100644
index 0000000..4b2fcc7
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/PeriodicInvoker.java
@@ -0,0 +1,28 @@
+package me.mikex86.velox.utils;
+
+import java.util.concurrent.TimeUnit;
+
+public class PeriodicInvoker implements Runnable {
+
+    private final Runnable runnable;
+    private final long time;
+    private final TimeUnit timeUnit;
+
+    public PeriodicInvoker(Runnable runnable, long time, TimeUnit timeUnit) {
+        this.runnable = runnable;
+        this.time = time;
+        this.timeUnit = timeUnit;
+    }
+
+    @Override
+    public void run() {
+        try {
+            while (true) {
+                this.runnable.run();
+                Thread.sleep(this.timeUnit.toMillis(this.time));
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/StreamUtils.java b/src/main/java/me/mikex86/velox/utils/StreamUtils.java
new file mode 100644
index 0000000..1bbc2d6
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/StreamUtils.java
@@ -0,0 +1,12 @@
+package me.mikex86.velox.utils;
+
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class StreamUtils {
+
+    public static <T> Stream<T> prefetch(Stream<T> stream) {
+        return stream.collect(Collectors.toList()).stream();
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/utils/Streamer.java b/src/main/java/me/mikex86/velox/utils/Streamer.java
new file mode 100644
index 0000000..73cb54c
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/Streamer.java
@@ -0,0 +1,108 @@
+package me.mikex86.velox.utils;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+public class Streamer {
+
+    /**
+     * Applies a function to stream elements in batches and returns the results. This method does not mutate the stream! (how would it?)
+     *
+     * @param executor  the executor to run the functions async on
+     * @param stream    the stream to retrieve elements from
+     * @param function  the function to apply
+     * @param batchSize the size of a batch that should be processed as one completable future. The result can only be retrieved when all elements of a batch are applied
+     * @param <T>       the type of elements
+     * @param <R>       the output type of the apply function
+     * @return the futures of the batches
+     */
+    public static <T, R> List<CompletableFuture<List<R>>> applyAsync(Executor executor, Stream<T> stream, Function<T, R> function, int batchSize) {
+        List<List<T>> batches = getBatches(stream, batchSize);
+        List<CompletableFuture<List<R>>> futures = new ArrayList<>();
+        for (List<T> batch : batches) {
+            futures.add(CompletableFuture.supplyAsync(() -> {
+                List<R> results = new ArrayList<>();
+                for (T t : batch) {
+                    results.add(function.apply(t));
+                }
+                return results;
+            }, executor));
+        }
+        return futures;
+    }
+
+    /**
+     * Performs {@link #applyAsync(Executor, Stream, Function, int)} and waits for the futures to complete
+     *
+     * @throws ExecutionException   if the execution completed exceptionally
+     * @throws InterruptedException if the execution thread was interrupted
+     * @see #applyAsync(Executor, Stream, Function, int)
+     */
+    public static <T, R> void applyAsyncWait(Executor executor, Stream<T> stream, Function<T, R> function, int batchSize) throws ExecutionException, InterruptedException {
+        List<CompletableFuture<List<R>>> futures = applyAsync(executor, stream, function, batchSize);
+        for (CompletableFuture<List<R>> future : futures) {
+            future.get();
+        }
+    }
+
+    /**
+     * Splits a given stream into batches. The last batch may not be of size #batchSize
+     *
+     * @param stream    the stream to split
+     * @param batchSize number of elements of each batch
+     * @param <T>       the type of element
+     * @return the list of batches
+     */
+    public static <T> List<List<T>> getBatches(Stream<T> stream, int batchSize) {
+        AtomicInteger i = new AtomicInteger(0);
+        List<List<T>> batches = new ArrayList<>();
+        stream.forEachOrdered(e -> {
+            int ig = i.get();
+            int batchIndex = ig / batchSize;
+            if (batchIndex == batches.size()) {
+                batches.add(new ArrayList<>());
+            }
+            batches.get(batchIndex).add(e);
+            i.incrementAndGet();
+        });
+        return batches;
+    }
+
+    public static <T> void streamBatched(Executor executor, int nBatches, Collection<T> values, Consumer<T> consumer) throws InterruptedException, ExecutionException {
+        int batchSize = roundUp(values.size(), nBatches);
+        Iterator<T> iterator = values.iterator();
+        T[] batch = (T[]) new Object[batchSize];
+        int i = 0;
+        CountDownLatch entityLatch = new CountDownLatch(values.size());
+        AtomicBoolean earlyAbort = new AtomicBoolean(false);
+
+        while (iterator.hasNext()) {
+            T next = iterator.next();
+            batch[i] = next;
+            i++;
+            // if batch is fully filled or no next value is available (partial batch), schedule a task processing that batch
+            if (i == batchSize || !iterator.hasNext()) {
+                T[] batchCopy = Arrays.copyOf(batch, i);
+                executor.execute(() -> {
+                    for (T value : batchCopy) {
+                        if (!earlyAbort.get()) {
+                            consumer.accept(value);
+                        }
+                        entityLatch.countDown();
+                    }
+                });
+                i = 0;
+            }
+        }
+        entityLatch.await();
+    }
+
+    private static int roundUp(int num, int divisor) {
+        return (num + divisor - 1) / divisor;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/cache/LossyLongChunkCache.java b/src/main/java/me/mikex86/velox/utils/cache/LossyLongChunkCache.java
new file mode 100644
index 0000000..7250cfe
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/cache/LossyLongChunkCache.java
@@ -0,0 +1,129 @@
+package me.mikex86.velox.utils.cache;
+
+import it.unimi.dsi.fastutil.HashCommon;
+import me.mikex86.velox.utils.MathUtils;
+import net.minecraft.world.chunk.IChunk;
+
+import java.util.Arrays;
+
+/**
+ * Implements a chunk cache with a 64-bit key.
+ * Index collisions of hashes are fairly likely.
+ * Hash collisions are also not handled.
+ * Thread-safety is achieved via copy on write
+ */
+public class LossyLongChunkCache {
+
+    private final int capacity;
+
+    /**
+     * Bit mask used to calculate the index from a key.
+     */
+    private final long mask;
+
+    /**
+     * The state of the cache.
+     * This instance is swapped as a whole when the cache is mutated.
+     * This copy on write operation constitutes thread-safety
+     */
+    private CacheState cacheState;
+
+    private final Object mutex = new Object();
+
+    /**
+     * @param capacity the capacity of the cache. Should be a power of two. Next biggest will be used
+     */
+    public LossyLongChunkCache(int capacity) {
+        capacity = MathUtils.npot(capacity);
+        this.capacity = capacity;
+        this.mask = capacity - 1;
+        this.cacheState = new CacheState();
+    }
+
+    public IChunk get(long key) {
+        int index = this.index(key);
+        CacheState cacheState = this.cacheState;
+        if (cacheState.keys[index] != key) {
+            return null;
+        }
+        IChunk value = cacheState.values[index];
+        cacheState.lossyAccessCounters[index]++; // Fuck thread safety here...
+        return value;
+    }
+
+    private int index(long key) {
+        return (int) (HashCommon.mix(key) & this.mask);
+    }
+
+    public void clear() {
+        this.cacheState = new CacheState();
+    }
+
+    public int getCapacity() {
+        return capacity;
+    }
+
+    public void populate(long[] keys, IChunk[] values) {
+        assert keys.length == capacity;
+        assert values.length == capacity;
+        synchronized (this.mutex) {
+            CacheState cacheState = new CacheState();
+            for (int i = 0; i < keys.length; i++) {
+                long key = keys[i];
+                if (key == 0) continue;
+                int index = this.index(key);
+                cacheState.keys[index] = key;
+                cacheState.values[index] = values[i];
+                cacheState.lossyAccessCounters[index] = 0;
+            }
+            this.cacheState = cacheState;
+        }
+    }
+
+    public void invalidate(long key, IChunk chunk) {
+        synchronized (this.mutex) {
+            int index = index(key);
+            CacheState cacheState = this.cacheState;
+            if (cacheState.values[index] == chunk) {
+                cacheState = cacheState.copy();
+                cacheState.keys[index] = 0;
+                cacheState.values[index] = null;
+                cacheState.lossyAccessCounters[index] = 0;
+                this.cacheState = cacheState;
+            }
+        }
+    }
+
+    private class CacheState {
+
+        /**
+         * Roughly keeps track of the number of accesses each chunk of the cache has.
+         * We ignore thread-safety. If the counter is slightly off, so be it.
+         */
+        private final long[] lossyAccessCounters;
+
+        private final long[] keys;
+
+        private final IChunk[] values;
+
+        public CacheState() {
+            this.lossyAccessCounters = new long[capacity];
+            this.keys = new long[capacity];
+            this.values = new IChunk[capacity];
+        }
+
+        public CacheState(long[] lossyAccessCounters, long[] keys, IChunk[] values) {
+            this.lossyAccessCounters = lossyAccessCounters;
+            this.keys = keys;
+            this.values = values;
+        }
+
+        public CacheState copy() {
+            return new CacheState(
+                    Arrays.copyOf(this.lossyAccessCounters, this.lossyAccessCounters.length),
+                    Arrays.copyOf(this.keys, this.keys.length),
+                    Arrays.copyOf(this.values, this.values.length)
+            );
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/cache/guava/AccessCountingCache.java b/src/main/java/me/mikex86/velox/utils/cache/guava/AccessCountingCache.java
new file mode 100644
index 0000000..038e345
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/cache/guava/AccessCountingCache.java
@@ -0,0 +1,95 @@
+package me.mikex86.velox.utils.cache.guava;
+
+import com.google.common.cache.Cache;
+import com.google.common.cache.ForwardingCache;
+
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.Locale;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+public class AccessCountingCache<K, V> extends ForwardingCache<K, V> {
+
+    private final Cache<K, V> delegate;
+    private final Map<Object, AtomicInteger> accessCounts = new WeakHashMap<>();
+    private final ReadWriteLock lock = new ReentrantReadWriteLock();
+
+    public AccessCountingCache(Cache<K, V> delegate) {
+        this.delegate = delegate;
+    }
+
+    public static <K, V> AccessCountingCache<K, V> wrap(Cache<K, V> cache) {
+        return new AccessCountingCache<>(cache);
+    }
+
+    @Override
+    public V get(K key, Callable<? extends V> valueLoader) throws ExecutionException {
+        this.lock.readLock().lock();
+        AtomicInteger integer = this.accessCounts.get(key);
+        this.lock.readLock().unlock();
+        if (integer == null) {
+            integer = new AtomicInteger(0);
+            this.lock.writeLock().lock();
+            this.accessCounts.put(key, integer);
+            this.lock.writeLock().unlock();
+        }
+        integer.incrementAndGet();
+        return super.get(key, valueLoader);
+    }
+
+    @Nullable
+    @Override
+    public V getIfPresent(Object key) {
+        this.lock.readLock().lock();
+        AtomicInteger integer = this.accessCounts.get(key);
+        this.lock.readLock().unlock();
+        if (integer == null) {
+            integer = new AtomicInteger(0);
+            this.lock.writeLock().lock();
+            this.accessCounts.put(key, integer);
+            this.lock.writeLock().unlock();
+        }
+        integer.incrementAndGet();
+        return super.getIfPresent(key);
+    }
+
+    public void retrieveMostAccessedValues(K[] keys, V[] values) {
+        int nValues = keys.length;
+        int[] counters = new int[nValues];
+        for (Map.Entry<K, V> entry : this.delegate.asMap().entrySet()) {
+            K key = entry.getKey();
+            V value = entry.getValue();
+            this.lock.readLock().lock();
+            AtomicInteger atomicCounter = this.accessCounts.get(key);
+            this.lock.readLock().unlock();
+            int counter = atomicCounter == null ? 0 : atomicCounter.get();
+            for (int i = 0; i < nValues; i++) {
+                if (counter >= counters[i]) {
+                    // Move everything back by one
+                    for (int j = nValues - 2; j >= i; j--) {
+                        counters[j + 1] = counters[j];
+                        keys[j + 1] = keys[j];
+                        values[j + 1] = values[j];
+                    }
+                    counters[i] = counter;
+                    keys[i] = key;
+                    values[i] = value;
+                    break;
+                }
+            }
+        }
+        int x = 0;
+    }
+
+    @Override
+    protected Cache<K, V> delegate() {
+        return this.delegate;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/lock/AbstractLock.java b/src/main/java/me/mikex86/velox/utils/lock/AbstractLock.java
new file mode 100644
index 0000000..8931022
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/lock/AbstractLock.java
@@ -0,0 +1,42 @@
+package me.mikex86.velox.utils.lock;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+
+public abstract class AbstractLock implements Lock {
+
+    @Override
+    public abstract void lock();
+
+    @Override
+    public void lockInterruptibly() {
+        lock();
+    }
+
+    @Override
+    public boolean tryLock() {
+        throw new UnsupportedOperationException("tryLock() not implemented");
+    }
+
+
+    @Override
+    public boolean tryLock(long time, TimeUnit unit) {
+        long nanos = unit.toNanos(time);
+        long start = System.nanoTime();
+        while (System.nanoTime() - start < nanos) {
+            if (tryLock()) {
+                return true;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public abstract void unlock();
+
+    @Override
+    public Condition newCondition() {
+        throw new UnsupportedOperationException("newCondition() not implemented");
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/lock/DummyLock.java b/src/main/java/me/mikex86/velox/utils/lock/DummyLock.java
new file mode 100644
index 0000000..1f35585
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/lock/DummyLock.java
@@ -0,0 +1,38 @@
+package me.mikex86.velox.utils.lock;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+
+public class DummyLock implements Lock {
+
+    @Override
+    public void lock() {
+
+    }
+
+    @Override
+    public void lockInterruptibly() throws InterruptedException {
+
+    }
+
+    @Override
+    public boolean tryLock() {
+        return false;
+    }
+
+    @Override
+    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
+        return false;
+    }
+
+    @Override
+    public void unlock() {
+
+    }
+
+    @Override
+    public Condition newCondition() {
+        return null;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/lock/DummyReadWriteLock.java b/src/main/java/me/mikex86/velox/utils/lock/DummyReadWriteLock.java
new file mode 100644
index 0000000..0f4225a
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/lock/DummyReadWriteLock.java
@@ -0,0 +1,20 @@
+package me.mikex86.velox.utils.lock;
+
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+
+public class DummyReadWriteLock implements ReadWriteLock {
+
+    private final Lock lock = new DummyLock();
+
+    @Override
+    public Lock readLock() {
+        return lock;
+    }
+
+    @Override
+    public Lock writeLock() {
+        return lock;
+    }
+
+}
diff --git a/build/mcp_diff_src/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index e1cb326..aa72ace 100644
--- a/build/mcp_diff_src/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -97,7 +97,9 @@ public class DedicatedServer extends MinecraftServer implements IServer {
       thread.setDaemon(true);
       thread.setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler(LOGGER));
       thread.start();
-      LOGGER.info("Starting minecraft server version " + SharedConstants.getVersion().getName());
+      // Velox start: Change start log
+      LOGGER.info("Starting Velox server version " + SharedConstants.getVersion().getName());
+      // Velox end
       if (Runtime.getRuntime().maxMemory() / 1024L / 1024L < 512L) {
          LOGGER.warn("To start the server with more ram, launch it as \"java -Xmx1024M -Xms1024M -jar minecraft_server.jar\"");
       }
@@ -131,8 +133,9 @@ public class DedicatedServer extends MinecraftServer implements IServer {
       }
 
       this.func_244801_P();
-      LOGGER.info("Starting Minecraft server on {}:{}", this.getServerHostname().isEmpty() ? "*" : this.getServerHostname(), this.getServerPort());
-
+      // Velox start: Change start log 2
+      LOGGER.info("Starting Velox server on {}:{}", this.getServerHostname().isEmpty() ? "*" : this.getServerHostname(), this.getServerPort());
+      // Velox end
       try {
          this.getNetworkSystem().addEndpoint(inetaddress, this.getServerPort());
       } catch (IOException ioexception) {
diff --git a/build/mcp_diff_src/net/minecraft/util/ClassInheritanceMultiMap.java b/src/main/java/net/minecraft/util/ClassInheritanceMultiMap.java
index 71dfac2..af686a6 100644
--- a/build/mcp_diff_src/net/minecraft/util/ClassInheritanceMultiMap.java
+++ b/src/main/java/net/minecraft/util/ClassInheritanceMultiMap.java
@@ -11,12 +11,19 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.stream.Collectors;
 
 public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
    private final Map<Class<?>, List<T>> map = Maps.newHashMap();
    private final Class<T> baseClass;
    private final List<T> values = Lists.newArrayList();
+   // Velox start: ClassInheritanceMultiMap lock
+   private final ReadWriteLock lock = new ReentrantReadWriteLock();
+   // Velox end
 
    public ClassInheritanceMultiMap(Class<T> baseClassIn) {
       this.baseClass = baseClassIn;
@@ -24,28 +31,40 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
    }
 
    public boolean add(T p_add_1_) {
-      boolean flag = false;
-
-      for(Entry<Class<?>, List<T>> entry : this.map.entrySet()) {
-         if (entry.getKey().isInstance(p_add_1_)) {
-            flag |= entry.getValue().add(p_add_1_);
+      // Velox start: ClassInheritanceMultiMap#add threadsafe
+      try {
+         this.lock.writeLock().lock();
+         boolean flag = false;
+         for (Entry<Class<?>, List<T>> entry : this.map.entrySet()) {
+            if (entry.getKey().isInstance(p_add_1_)) {
+               flag |= entry.getValue().add(p_add_1_);
+            }
          }
+         return flag;
+      } finally {
+         this.lock.writeLock().unlock();
       }
-
-      return flag;
+      // Velox end
    }
 
    public boolean remove(Object p_remove_1_) {
-      boolean flag = false;
+      // Velox start: ClassInheritanceMultiMap#remove threadsafe
+      try {
+         this.lock.writeLock().lock();
+         boolean flag = false;
 
-      for(Entry<Class<?>, List<T>> entry : this.map.entrySet()) {
-         if (entry.getKey().isInstance(p_remove_1_)) {
-            List<T> list = entry.getValue();
-            flag |= list.remove(p_remove_1_);
+         for (Entry<Class<?>, List<T>> entry : this.map.entrySet()) {
+            if (entry.getKey().isInstance(p_remove_1_)) {
+               List<T> list = entry.getValue();
+               flag |= list.remove(p_remove_1_);
+            }
          }
-      }
 
-      return flag;
+         return flag;
+      } finally {
+         this.lock.writeLock().unlock();
+      }
+      // Velox end
    }
 
    public boolean contains(Object p_contains_1_) {
@@ -53,25 +72,64 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
    }
 
    public <S> Collection<S> getByClass(Class<S> p_219790_1_) {
-      if (!this.baseClass.isAssignableFrom(p_219790_1_)) {
-         throw new IllegalArgumentException("Don't know how to search for " + p_219790_1_);
-      } else {
-         List<T> list = this.map.computeIfAbsent(p_219790_1_, (p_219791_1_) -> {
-            return this.values.stream().filter(p_219791_1_::isInstance).collect(Collectors.toList());
-         });
-         return (Collection<S>) Collections.unmodifiableCollection(list);
+      // Velox start: ClassInheritanceMultiMap#getByClass threadsafe
+      try {
+         this.lock.writeLock().lock();
+         if (!this.baseClass.isAssignableFrom(p_219790_1_)) {
+            throw new IllegalArgumentException("Don't know how to search for " + p_219790_1_);
+         } else {
+            List<T> classList = this.map.get(p_219790_1_);
+            if (classList == null) {
+               classList = buildClassList(p_219790_1_);
+               this.map.put(p_219790_1_, classList);
+            }
+            return (Collection<S>) Lists.newArrayList(classList);
+         }
+      } finally {
+         this.lock.writeLock().unlock();
       }
+      // Velox end
    }
 
+   // Velox start: ClassInheritanceMultiMap#buildClassList
+   private <S> List<T> buildClassList(Class<S> clazz) {
+      List<T> values = this.func_241289_a_();
+      List<T> classList = Lists.newArrayList();
+      for (T value : values) {
+         if (clazz.isInstance(value)) {
+            classList.add(value);
+         }
+      }
+      return classList;
+   }
+   // Velox end
+
    public Iterator<T> iterator() {
-      return (Iterator<T>)(this.values.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(this.values.iterator()));
+      // Velox start: ClassInheritanceMultiMap#iterator threadsafe
+      List<T> values = func_241289_a_();
+      return (Iterator<T>) (values.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(values.iterator()));
+      // Velox end
    }
 
    public List<T> func_241289_a_() {
-      return ImmutableList.copyOf(this.values);
+      // Velox start: ClassInheritanceMultiMap#func_241289_a_ threadsafe
+      try {
+         this.lock.readLock().lock();
+         return ImmutableList.copyOf(this.values);
+      } finally {
+         this.lock.readLock().unlock();
+      }
+      // Velox end
    }
 
    public int size() {
-      return this.values.size();
+      // Velox start: ClassInheritanceMultiMap#size threadsafe
+      try {
+         this.lock.readLock().lock();
+         return this.values.size();
+      } finally {
+         this.lock.readLock().unlock();
+      }
+      // Velox end
    }
 }
diff --git a/build/mcp_diff_src/net/minecraft/util/palette/PalettedContainer.java b/src/main/java/net/minecraft/util/palette/PalettedContainer.java
index 7217e61..462ec3a 100644
--- a/build/mcp_diff_src/net/minecraft/util/palette/PalettedContainer.java
+++ b/src/main/java/net/minecraft/util/palette/PalettedContainer.java
@@ -35,17 +35,9 @@ public class PalettedContainer<T> implements IResizeCallback<T> {
    private final ReentrantLock lock = new ReentrantLock();
 
    public void lock() {
-      if (this.lock.isLocked() && !this.lock.isHeldByCurrentThread()) {
-         String s = Thread.getAllStackTraces().keySet().stream().filter(Objects::nonNull).map((p_210458_0_) -> {
-            return p_210458_0_.getName() + ": \n\tat " + (String)Arrays.stream(p_210458_0_.getStackTrace()).map(Object::toString).collect(Collectors.joining("\n\tat "));
-         }).collect(Collectors.joining("\n"));
-         CrashReport crashreport = new CrashReport("Writing into PalettedContainer from multiple threads", new IllegalStateException());
-         CrashReportCategory crashreportcategory = crashreport.makeCategory("Thread dumps");
-         crashreportcategory.addDetail("Thread dumps", s);
-         throw new ReportedException(crashreport);
-      } else {
-         this.lock.lock();
-      }
+      // Velox start: Make PalettedContainer threadsafe
+      this.lock.lock();
+      // Velox end
    }
 
    public void unlock() {
diff --git a/build/mcp_diff_src/net/minecraft/village/PointOfInterestManager.java b/src/main/java/net/minecraft/village/PointOfInterestManager.java
index faed79c..bd97e9f 100644
--- a/build/mcp_diff_src/net/minecraft/village/PointOfInterestManager.java
+++ b/src/main/java/net/minecraft/village/PointOfInterestManager.java
@@ -18,6 +18,8 @@ import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
+
+import me.mikex86.velox.utils.StreamUtils;
 import net.minecraft.block.BlockState;
 import net.minecraft.util.SectionDistanceGraph;
 import net.minecraft.util.Util;
@@ -40,77 +42,155 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
    }
 
    public void add(BlockPos pos, PointOfInterestType poiType) {
-      this.func_235995_e_(SectionPos.from(pos).asLong()).add(pos, poiType);
+      // Velox start: PointOfInterestManager#add threadsafe
+      this.lock.lock();
+      try {
+         this.func_235995_e_(SectionPos.from(pos).asLong()).add(pos, poiType);
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    public void remove(BlockPos pos) {
-      this.func_235995_e_(SectionPos.from(pos).asLong()).remove(pos);
+      // Velox start: PointOfInterestManager#remove threadsafe
+      try {
+         this.lock.lock();
+         this.func_235995_e_(SectionPos.from(pos).asLong()).remove(pos);
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    public long getCountInRange(Predicate<PointOfInterestType> p_219145_1_, BlockPos pos, int distance, PointOfInterestManager.Status status) {
-      return this.func_219146_b(p_219145_1_, pos, distance, status).count();
+       // Velox start: PointOfInterestManager#getCountInRange threadsafe
+       this.lock.lock();
+       try {
+          return this.func_219146_b(p_219145_1_, pos, distance, status).count();
+       } finally {
+          this.lock.unlock();
+       }
+       // Velox end
    }
 
    public boolean hasTypeAtPosition(PointOfInterestType type, BlockPos pos) {
-      Optional<PointOfInterestType> optional = this.func_235995_e_(SectionPos.from(pos).asLong()).getType(pos);
-      return optional.isPresent() && optional.get().equals(type);
+      // Velox start: PointOfInterestManager#func_235995_e_ threadsafe
+      this.lock.lock();
+      try {
+         Optional<PointOfInterestType> optional = this.func_235995_e_(SectionPos.from(pos).asLong()).getType(pos);
+         return optional.isPresent() && optional.get().equals(type);
+      } finally {
+         this.lock.unlock();
+      }
    }
 
    public Stream<PointOfInterest> getInSquare(Predicate<PointOfInterestType> typePredicate, BlockPos pos, int distance, PointOfInterestManager.Status status) {
-      int i = Math.floorDiv(distance, 16) + 1;
-      return ChunkPos.getAllInBox(new ChunkPos(pos), i).flatMap((p_226350_3_) -> {
-         return this.getInChunk(typePredicate, p_226350_3_, status);
-      }).filter((p_242322_2_) -> {
-         BlockPos blockpos = p_242322_2_.getPos();
-         return Math.abs(blockpos.getX() - pos.getX()) <= distance && Math.abs(blockpos.getZ() - pos.getZ()) <= distance;
-      });
+      // Velox start: PointOfInterestManager#getInSquare threadsafe
+      // Comment: Prefetching all values that would be returned by the stream and re-streaming these values.
+      // This avoids the problem of many short synchronizations as multiple streams on this global object
+      // advance to the next element.
+      // This way we only lock for the short period of time where we prefetch the values.
+      this.lock.lock();
+      try {
+         int i = Math.floorDiv(distance, 16) + 1;
+         Stream<PointOfInterest> stream = ChunkPos.getAllInBox(new ChunkPos(pos), i).flatMap((p_226350_3_) -> {
+            return this.getInChunk(typePredicate, p_226350_3_, status);
+         }).filter((p_242322_2_) -> {
+            BlockPos blockpos = p_242322_2_.getPos();
+            return Math.abs(blockpos.getX() - pos.getX()) <= distance && Math.abs(blockpos.getZ() - pos.getZ()) <= distance;
+         });
+         return StreamUtils.prefetch(stream);
+      } finally {
+          this.lock.unlock();
+      }
+      // Velox end
    }
 
    public Stream<PointOfInterest> func_219146_b(Predicate<PointOfInterestType> typePredicate, BlockPos pos, int distance, PointOfInterestManager.Status status) {
-      int i = distance * distance;
-      return this.getInSquare(typePredicate, pos, distance, status).filter((p_226349_2_) -> {
-         return p_226349_2_.getPos().distanceSq(pos) <= (double)i;
-      });
+      // Velox start: PointOfInterestManager#func_219146_b (Velox deobf: "PointOfInterestManager#getInSqrtDistance") threadsafe
+      // Comment: Prefetching all values that would be returned by the stream and re-streaming these values.
+      // This avoids the problem of many short synchronizations as multiple streams on this global object
+      // advance to the next element.
+      // This way we only lock for the short period of time where we prefetch the values.
+      this.lock.lock();
+      try {
+         int i = distance * distance;
+         Stream<PointOfInterest> stream = this.getInSquare(typePredicate, pos, distance, status).filter((p_226349_2_) -> {
+            return p_226349_2_.getPos().distanceSq(pos) <= (double) i;
+         });
+         return StreamUtils.prefetch(stream);
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    public Stream<PointOfInterest> getInChunk(Predicate<PointOfInterestType> p_219137_1_, ChunkPos posChunk, PointOfInterestManager.Status status) {
-      return IntStream.range(0, 16).boxed().map((p_219149_2_) -> {
-         return this.func_219113_d(SectionPos.from(posChunk, p_219149_2_).asLong());
-      }).filter(Optional::isPresent).flatMap((p_241393_2_) -> {
-         return p_241393_2_.get().getRecords(p_219137_1_, status);
-      });
+       // Velox start: PointOfInterestManager#getInChunk threadsafe
+       // Comment: Prefetching all values that would be returned by the stream and re-streaming these values.
+       // This avoids the problem of many short synchronizations as multiple streams on this global object
+       // advance to the next element.
+       // This way we only lock for the short period of time where we prefetch the values.
+       this.lock.lock();
+       try {
+          Stream<PointOfInterest> stream = IntStream.range(0, 16).boxed().map((p_219149_2_) -> {
+             return this.func_219113_d(SectionPos.from(posChunk, p_219149_2_).asLong());
+          }).filter(Optional::isPresent).flatMap((p_241393_2_) -> {
+             return p_241393_2_.get().getRecords(p_219137_1_, status);
+          });
+          return StreamUtils.prefetch(stream);
+       } finally {
+          this.lock.unlock();
+       }
+       // Velox end
    }
 
    public Stream<BlockPos> findAll(Predicate<PointOfInterestType> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int distance, PointOfInterestManager.Status status) {
-      return this.func_219146_b(typePredicate, pos, distance, status).map(PointOfInterest::getPos).filter(posPredicate);
+       // Velox comment: func_219146_b is threadsafe, subsequent stream operations are safe on the prefetched values
+       return this.func_219146_b(typePredicate, pos, distance, status).map(PointOfInterest::getPos).filter(posPredicate);
    }
 
    public Stream<BlockPos> func_242324_b(Predicate<PointOfInterestType> p_242324_1_, Predicate<BlockPos> posPredicate, BlockPos p_242324_3_, int distance, PointOfInterestManager.Status status) {
+      // Velox comment: findAll is threadsafe, subsequent stream operations are safe on the prefetched values
       return this.findAll(p_242324_1_, posPredicate, p_242324_3_, distance, status).sorted(Comparator.comparingDouble((p_242323_1_) -> {
          return p_242323_1_.distanceSq(p_242324_3_);
       }));
    }
 
    public Optional<BlockPos> find(Predicate<PointOfInterestType> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int distance, PointOfInterestManager.Status status) {
+      // Velox comment: findAll is threadsafe, subsequent stream operations are safe on the prefetched values
       return this.findAll(typePredicate, posPredicate, pos, distance, status).findFirst();
    }
 
    public Optional<BlockPos> func_234148_d_(Predicate<PointOfInterestType> typePredicate, BlockPos pos, int distance, PointOfInterestManager.Status status) {
+      // Velox comment: func_219146_b is threadsafe, subsequent stream operations are safe on the prefetched values
       return this.func_219146_b(typePredicate, pos, distance, status).map(PointOfInterest::getPos).min(Comparator.comparingDouble((p_219160_1_) -> {
          return p_219160_1_.distanceSq(pos);
       }));
    }
 
    public Optional<BlockPos> take(Predicate<PointOfInterestType> typePredicate, Predicate<BlockPos> posPredicate, BlockPos pos, int distance) {
-      return this.func_219146_b(typePredicate, pos, distance, PointOfInterestManager.Status.HAS_SPACE).filter((p_219129_1_) -> {
-         return posPredicate.test(p_219129_1_.getPos());
-      }).findFirst().map((p_219152_0_) -> {
-         p_219152_0_.claim();
-         return p_219152_0_.getPos();
-      });
+      // Velox start: PointOfInterestManager#take threadsafe
+      this.lock.lock();
+      try {
+         // Theoretically, we would not need to prefetch here because the entire stream is consumed while the readLock is active
+         Stream<PointOfInterest> stream = this.func_219146_b(typePredicate, pos, distance, Status.HAS_SPACE).filter((p_219129_1_) -> {
+            return posPredicate.test(p_219129_1_.getPos());
+         });
+         return stream.findFirst().map((p_219152_0_) -> {
+            p_219152_0_.claim();
+            return p_219152_0_.getPos();
+         });
+      } finally {
+          this.lock.unlock();
+      }
+      // Velox end
    }
 
    public Optional<BlockPos> getRandom(Predicate<PointOfInterestType> typePredicate, Predicate<BlockPos> posPredicate, PointOfInterestManager.Status status, BlockPos pos, int distance, Random rand) {
+      // Velox comment: #list is already prefetched, this method is not directly exposing state of the PointOfInterestManager.
+      // No need to readLock.
       List<PointOfInterest> list = this.func_219146_b(typePredicate, pos, distance, status).collect(Collectors.toList());
       Collections.shuffle(list, rand);
       return list.stream().filter((p_234143_1_) -> {
@@ -119,89 +199,171 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
    }
 
    public boolean release(BlockPos pos) {
-      return this.func_235995_e_(SectionPos.from(pos).asLong()).release(pos);
+      // Velox start: PointOfInterestManager#release threadsafe
+      // RegionSectionCache#func_235995_e_ is threadsafe
+      PointOfInterestData data = this.func_235995_e_(SectionPos.from(pos).asLong());
+      // PointOfInterestData#release invokes a sketchy runnable "onChange", whose purpose I was not able
+      // to determine. Can this mutate PointOfInterestManager?
+      this.lock.lock();
+      try {
+         return data.release(pos);
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    public boolean exists(BlockPos pos, Predicate<PointOfInterestType> p_219138_2_) {
-      return this.func_219113_d(SectionPos.from(pos).asLong()).map((p_234141_2_) -> {
-         return p_234141_2_.exists(pos, p_219138_2_);
-      }).orElse(false);
+      // Velox start: PointOfInterestManager#exists threadsafe
+      // We're write locking because func_219113_d write locks. Cascading read to write will result in a dead-lock.
+      this.lock.lock();
+      try {
+         return this.func_219113_d(SectionPos.from(pos).asLong()).map((p_234141_2_) -> {
+            return p_234141_2_.exists(pos, p_219138_2_);
+         }).orElse(false);
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    public Optional<PointOfInterestType> getType(BlockPos pos) {
-      PointOfInterestData pointofinterestdata = this.func_235995_e_(SectionPos.from(pos).asLong());
-      return pointofinterestdata.getType(pos);
+      // Velox start: PointOfInterestManager#getType threadsafe
+      this.lock.lock();
+      try {
+         PointOfInterestData pointofinterestdata = this.func_235995_e_(SectionPos.from(pos).asLong());
+         return pointofinterestdata.getType(pos);
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    public int sectionsToVillage(SectionPos sectionPos) {
-      this.distanceTracker.runAllUpdates();
-      return this.distanceTracker.getLevel(sectionPos.asLong());
+      // Velox start: PointOfInterestManager#sectionsToVillage threadsafe
+      this.lock.lock();
+      try {
+         this.distanceTracker.runAllUpdates();
+         return this.distanceTracker.getLevel(sectionPos.asLong());
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    private boolean isVillageCenter(long p_219154_1_) {
-      Optional<PointOfInterestData> optional = this.func_219106_c(p_219154_1_);
-      return optional == null ? false : optional.map((p_234134_0_) -> {
-         return p_234134_0_.getRecords(PointOfInterestType.MATCH_ANY, PointOfInterestManager.Status.IS_OCCUPIED).count() > 0L;
-      }).orElse(false);
+      // Velox start: PointOfInterestManager#isVillageCenter threadsafe
+      this.lock.lock();
+      try {
+         Optional<PointOfInterestData> optional = this.func_219106_c(p_219154_1_);
+         return optional == null ? false : optional.map((p_234134_0_) -> {
+            return p_234134_0_.getRecords(PointOfInterestType.MATCH_ANY, PointOfInterestManager.Status.IS_OCCUPIED).count() > 0L;
+         }).orElse(false);
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    public void tick(BooleanSupplier p_219115_1_) {
-      super.tick(p_219115_1_);
-      this.distanceTracker.runAllUpdates();
+      // Velox start: PointOfInterestManager#tick threadsafe
+      this.lock.lock();
+      try {
+         super.tick(p_219115_1_);
+         this.distanceTracker.runAllUpdates();
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    protected void markDirty(long sectionPosIn) {
-      super.markDirty(sectionPosIn);
-      this.distanceTracker.updateSourceLevel(sectionPosIn, this.distanceTracker.getSourceLevel(sectionPosIn), false);
+      // Velox start: PointOfInterestManager#markDirty threadsafe
+      this.lock.lock();
+      try {
+         super.markDirty(sectionPosIn);
+         this.distanceTracker.updateSourceLevel(sectionPosIn, this.distanceTracker.getSourceLevel(sectionPosIn), false);
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    protected void onSectionLoad(long p_219111_1_) {
-      this.distanceTracker.updateSourceLevel(p_219111_1_, this.distanceTracker.getSourceLevel(p_219111_1_), false);
+      // Velox start PointOfInterestManager#onSectionLoad threadsafe
+      this.lock.lock();
+      try {
+         this.distanceTracker.updateSourceLevel(p_219111_1_, this.distanceTracker.getSourceLevel(p_219111_1_), false);
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    public void checkConsistencyWithBlocks(ChunkPos pos, ChunkSection section) {
-      SectionPos sectionpos = SectionPos.from(pos, section.getYLocation() >> 4);
-      Util.acceptOrElse(this.func_219113_d(sectionpos.asLong()), (p_234138_3_) -> {
-         p_234138_3_.refresh((p_234145_3_) -> {
+      // Velox start: checkConsistencyWithBlocks threadsafe
+      this.lock.lock();
+      try {
+         SectionPos sectionpos = SectionPos.from(pos, section.getYLocation() >> 4);
+         Util.acceptOrElse(this.func_219113_d(sectionpos.asLong()), (p_234138_3_) -> {
+            p_234138_3_.refresh((p_234145_3_) -> {
+               if (hasAnyPOI(section)) {
+                  this.updateFromSelection(section, sectionpos, p_234145_3_);
+               }
+
+            });
+         }, () -> {
             if (hasAnyPOI(section)) {
-               this.updateFromSelection(section, sectionpos, p_234145_3_);
+               PointOfInterestData pointofinterestdata = this.func_235995_e_(sectionpos.asLong());
+               this.updateFromSelection(section, sectionpos, pointofinterestdata::add);
             }
 
          });
-      }, () -> {
-         if (hasAnyPOI(section)) {
-            PointOfInterestData pointofinterestdata = this.func_235995_e_(sectionpos.asLong());
-            this.updateFromSelection(section, sectionpos, pointofinterestdata::add);
-         }
-
-      });
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    private static boolean hasAnyPOI(ChunkSection section) {
+      // Velox comment: ChunkSection is already threadsafe
       return section.isValidPOIState(PointOfInterestType.BLOCKS_OF_INTEREST::contains);
    }
 
    private void updateFromSelection(ChunkSection section, SectionPos sectionPos, BiConsumer<BlockPos, PointOfInterestType> posToTypeConsumer) {
-      sectionPos.allBlocksWithin().forEach((p_234139_2_) -> {
-         BlockState blockstate = section.getBlockState(SectionPos.mask(p_234139_2_.getX()), SectionPos.mask(p_234139_2_.getY()), SectionPos.mask(p_234139_2_.getZ()));
-         PointOfInterestType.forState(blockstate).ifPresent((p_234142_2_) -> {
-            posToTypeConsumer.accept(p_234139_2_, p_234142_2_);
+      // Velox start: PointOfInterestManager#updateFromSelection threadsafe
+      this.lock.lock();
+      try {
+         sectionPos.allBlocksWithin().forEach((p_234139_2_) -> {
+            BlockState blockstate = section.getBlockState(SectionPos.mask(p_234139_2_.getX()), SectionPos.mask(p_234139_2_.getY()), SectionPos.mask(p_234139_2_.getZ()));
+            PointOfInterestType.forState(blockstate).ifPresent((p_234142_2_) -> {
+               posToTypeConsumer.accept(p_234139_2_, p_234142_2_);
+            });
          });
-      });
+      } finally {
+         this.lock.unlock();
+      }
+      // Velox end
    }
 
    public void ensureLoadedAndValid(IWorldReader worldReader, BlockPos pos, int coordinateOffset) {
-      SectionPos.func_229421_b_(new ChunkPos(pos), Math.floorDiv(coordinateOffset, 16)).map((p_234147_1_) -> {
-         return Pair.of(p_234147_1_, this.func_219113_d(p_234147_1_.asLong()));
-      }).filter((p_234146_0_) -> {
-         return !p_234146_0_.getSecond().map(PointOfInterestData::isValid).orElse(false);
-      }).map((p_234140_0_) -> {
-         return p_234140_0_.getFirst().asChunkPos();
-      }).filter((p_234144_1_) -> {
-         return this.loadedChunks.add(p_234144_1_.asLong());
-      }).forEach((p_234136_1_) -> {
-         worldReader.getChunk(p_234136_1_.x, p_234136_1_.z, ChunkStatus.EMPTY);
-      });
+      // Velox start: PointOfInterestManager#ensureLoadedAndValid writeLock
+      this.lock.lock();
+      try {
+         SectionPos.func_229421_b_(new ChunkPos(pos), Math.floorDiv(coordinateOffset, 16)).map((p_234147_1_) -> {
+            return Pair.of(p_234147_1_, this.func_219113_d(p_234147_1_.asLong()));
+         }).filter((p_234146_0_) -> {
+            return !p_234146_0_.getSecond().map(PointOfInterestData::isValid).orElse(false);
+         }).map((p_234140_0_) -> {
+            return p_234140_0_.getFirst().asChunkPos();
+         }).filter((p_234144_1_) -> {
+            return this.loadedChunks.add(p_234144_1_.asLong());
+         }).forEach((p_234136_1_) -> {
+            worldReader.getChunk(p_234136_1_.x, p_234136_1_.z, ChunkStatus.EMPTY);
+         });
+      } finally {
+         this.lock.unlock();
+      }
    }
 
    final class DistanceGraph extends SectionDistanceGraph {
diff --git a/build/mcp_diff_src/net/minecraft/world/World.java b/src/main/java/net/minecraft/world/World.java
index a53a1a5..c7f85fe 100644
--- a/build/mcp_diff_src/net/minecraft/world/World.java
+++ b/src/main/java/net/minecraft/world/World.java
@@ -7,10 +7,13 @@ import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.tick.TickRegionManager;
 import net.minecraft.block.AbstractFireBlock;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockState;
@@ -70,10 +73,12 @@ public abstract class World implements IWorld, AutoCloseable {
    public static final RegistryKey<World> THE_NETHER = RegistryKey.getOrCreateKey(Registry.WORLD_KEY, new ResourceLocation("the_nether"));
    public static final RegistryKey<World> THE_END = RegistryKey.getOrCreateKey(Registry.WORLD_KEY, new ResourceLocation("the_end"));
    private static final Direction[] FACING_VALUES = Direction.values();
-   public final List<TileEntity> loadedTileEntityList = Lists.newArrayList();
-   public final List<TileEntity> tickableTileEntities = Lists.newArrayList();
-   protected final List<TileEntity> addedTileEntityList = Lists.newArrayList();
-   protected final List<TileEntity> tileEntitiesToBeRemoved = Lists.newArrayList();
+   // Velox start: make tile entity lists threadsafe
+   public final List<TileEntity> loadedTileEntityList = new CopyOnWriteArrayList<>();
+   public final List<TileEntity> tickableTileEntities = new CopyOnWriteArrayList<>();
+   protected final List<TileEntity> addedTileEntityList = new CopyOnWriteArrayList<>();
+   protected final List<TileEntity> tileEntitiesToBeRemoved = new CopyOnWriteArrayList<>();
+   // Velox end
    private final Thread mainThread;
    private final boolean isDebug;
    private int skylightSubtracted;
@@ -93,6 +98,10 @@ public abstract class World implements IWorld, AutoCloseable {
    private final BiomeManager biomeManager;
    private final RegistryKey<World> dimension;
 
+   // Velox start: TickRegionManager instance per world
+   public final TickRegionManager tickRegionManager = new TickRegionManager();
+   // Velox end
+
    protected World(ISpawnWorldInfo worldInfo, RegistryKey<World> dimension, final DimensionType dimensionType, Supplier<IProfiler> profiler, boolean isRemote, boolean isDebug, long seed) {
       this.profiler = profiler;
       this.worldInfo = worldInfo;
@@ -527,9 +536,9 @@ public abstract class World implements IWorld, AutoCloseable {
    public TileEntity getTileEntity(BlockPos pos) {
       if (isOutsideBuildHeight(pos)) {
          return null;
-      } else if (!this.isRemote && Thread.currentThread() != this.mainThread) {
-         return null;
+         // Velox start: remove getTileEntity mainThread check
       } else {
+         // Velox end
          TileEntity tileentity = null;
          if (this.processingLoadedTiles) {
             tileentity = this.getPendingTileEntityAt(pos);
diff --git a/build/mcp_diff_src/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index a5ea695..7d3fc9f 100644
--- a/build/mcp_diff_src/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -573,6 +573,9 @@ public class Chunk implements IChunk {
    }
 
    public void setLoaded(boolean loaded) {
+      // Velox start: inform tick region manager of chunk load state change
+      this.world.tickRegionManager.informChunkLoadStateChange(this, loaded);
+      // Velox end
       this.loaded = loaded;
    }
 
@@ -795,4 +798,10 @@ public class Chunk implements IChunk {
       QUEUED,
       CHECK;
    }
+
+   // Velox start: Accessor for Chunk#loaded
+   public boolean isLoaded() {
+      return loaded;
+   }
+   // Velox end
 }
diff --git a/build/mcp_diff_src/net/minecraft/world/chunk/storage/RegionSectionCache.java b/src/main/java/net/minecraft/world/chunk/storage/RegionSectionCache.java
index 61a0bd8..50f7311 100644
--- a/build/mcp_diff_src/net/minecraft/world/chunk/storage/RegionSectionCache.java
+++ b/src/main/java/net/minecraft/world/chunk/storage/RegionSectionCache.java
@@ -15,9 +15,12 @@ import java.io.File;
 import java.io.IOException;
 import java.util.Map;
 import java.util.Optional;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import javax.annotation.Nullable;
+
 import net.minecraft.nbt.CompoundNBT;
 import net.minecraft.nbt.INBT;
 import net.minecraft.nbt.NBTDynamicOps;
@@ -39,6 +42,9 @@ public class RegionSectionCache<R> implements AutoCloseable {
    private final Function<Runnable, R> field_219124_f;
    private final DataFixer field_219125_g;
    private final DefaultTypeReferences field_219126_h;
+   // Velox start: RegionSectionCache lock
+   protected final Lock lock = new ReentrantLock();
+   // Velox end
 
    public RegionSectionCache(File p_i231897_1_, Function<Runnable, Codec<R>> p_i231897_2_, Function<Runnable, R> p_i231897_3_, DataFixer p_i231897_4_, DefaultTypeReferences p_i231897_5_, boolean p_i231897_6_) {
       this.field_235988_e_ = p_i231897_2_;
@@ -62,23 +68,30 @@ public class RegionSectionCache<R> implements AutoCloseable {
    }
 
    protected Optional<R> func_219113_d(long p_219113_1_) {
-      SectionPos sectionpos = SectionPos.from(p_219113_1_);
-      if (this.func_219114_b(sectionpos)) {
-         return Optional.empty();
-      } else {
-         Optional<R> optional = this.func_219106_c(p_219113_1_);
-         if (optional != null) {
-            return optional;
+      // Velox start: RegionSectionCache#func_219113_d threadsafe
+      this.lock.lock();
+      try {
+         SectionPos sectionpos = SectionPos.from(p_219113_1_);
+         if (this.func_219114_b(sectionpos)) {
+            return Optional.empty();
          } else {
-            this.func_219107_b(sectionpos.asChunkPos());
-            optional = this.func_219106_c(p_219113_1_);
-            if (optional == null) {
-               throw (IllegalStateException)Util.pauseDevMode(new IllegalStateException());
-            } else {
+            Optional<R> optional = this.func_219106_c(p_219113_1_);
+            if (optional != null) {
                return optional;
+            } else {
+               this.func_219107_b(sectionpos.asChunkPos());
+               optional = this.func_219106_c(p_219113_1_);
+               if (optional == null) {
+                  throw (IllegalStateException) Util.pauseDevMode(new IllegalStateException());
+               } else {
+                  return optional;
+               }
             }
          }
+      } finally {
+         this.lock.unlock();
       }
+      // Velox end
    }
 
    protected boolean func_219114_b(SectionPos p_219114_1_) {
@@ -86,15 +99,21 @@ public class RegionSectionCache<R> implements AutoCloseable {
    }
 
    protected R func_235995_e_(long p_235995_1_) {
-      Optional<R> optional = this.func_219113_d(p_235995_1_);
-      if (optional.isPresent()) {
-         return optional.get();
-      } else {
-         R r = this.field_219124_f.apply(() -> {
-            this.markDirty(p_235995_1_);
-         });
-         this.data.put(p_235995_1_, Optional.of(r));
-         return r;
+      // Velox start: RegionSectionCache#func_235995_e_ writeLock
+      this.lock.lock();
+      try {
+         Optional<R> optional = this.func_219113_d(p_235995_1_);
+         if (optional.isPresent()) {
+            return optional.get();
+         } else {
+            R r = this.field_219124_f.apply(() -> {
+               this.markDirty(p_235995_1_);
+            });
+            this.data.put(p_235995_1_, Optional.of(r));
+            return r;
+         }
+      } finally {
+         this.lock.unlock();
       }
    }
 
@@ -194,6 +213,8 @@ public class RegionSectionCache<R> implements AutoCloseable {
    }
 
    public void saveIfDirty(ChunkPos p_219112_1_) {
+      // Velox comment: Minecraft thread-safety should already ensure that this is
+      // never called unsafely, right Mojang?
       if (!this.dirtySections.isEmpty()) {
          for(int i = 0; i < 16; ++i) {
             long j = SectionPos.from(p_219112_1_, i).asLong();
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ChunkManager.java b/src/main/java/net/minecraft/world/server/ChunkManager.java
index 7b0aa0e..cd33e5e 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ChunkManager.java
+++ b/src/main/java/net/minecraft/world/server/ChunkManager.java
@@ -9,12 +9,7 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import java.io.File;
 import java.io.IOException;
@@ -30,6 +25,8 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.function.BooleanSupplier;
 import java.util.function.IntFunction;
 import java.util.function.IntSupplier;
@@ -37,6 +34,8 @@ import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.utils.IteratorUtils;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ReportedException;
@@ -97,7 +96,12 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    public static final int MAX_LOADED_LEVEL = 33 + ChunkStatus.maxDistance();
    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> loadedChunks = new Long2ObjectLinkedOpenHashMap<>();
    private volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> immutableLoadedChunks = this.loadedChunks.clone();
-   private final Long2ObjectLinkedOpenHashMap<ChunkHolder> chunksToUnload = new Long2ObjectLinkedOpenHashMap<>();
+   // Velox start: Lock for immutableLoadedChunks
+   private final ReadWriteLock immutableLoadedChunksLock = new ReentrantReadWriteLock();
+   // Velox end
+   // Velox start: Make ChunkManager#chunksToUnload public
+   public final Long2ObjectLinkedOpenHashMap<ChunkHolder> chunksToUnload = new Long2ObjectLinkedOpenHashMap<>();
+   // Velox end
    private final LongSet loadedPositions = new LongOpenHashSet();
    private final ServerWorld world;
    private final ServerWorldLightManager lightManager;
@@ -117,6 +121,9 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    private final File dimensionDirectory;
    private final PlayerGenerationTracker playerGenerationTracker = new PlayerGenerationTracker();
    private final Int2ObjectMap<ChunkManager.EntityTracker> entities = new Int2ObjectOpenHashMap<>();
+   // Velox start: ChunkManager#entityTrackerLock
+   private final ReadWriteLock entityTrackerLock = new ReentrantReadWriteLock();
+   // Velox end
    private final Long2ByteMap field_241087_z_ = new Long2ByteOpenHashMap();
    private final Queue<Runnable> saveTasks = Queues.newConcurrentLinkedQueue();
    private int viewDistance;
@@ -182,7 +189,12 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 
    @Nullable
    protected ChunkHolder func_219219_b(long chunkPosIn) {
-      return this.immutableLoadedChunks.get(chunkPosIn);
+      // Velox start: func_219219_b threadsafe
+      this.immutableLoadedChunksLock.readLock().lock();
+      ChunkHolder chunkHolder = this.immutableLoadedChunks.get(chunkPosIn);
+      this.immutableLoadedChunksLock.readLock().unlock();
+      return chunkHolder;
+      // Velox end
    }
 
    protected IntSupplier func_219191_c(long chunkPosIn) {
@@ -319,7 +331,12 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 
    protected void save(boolean flush) {
       if (flush) {
-         List<ChunkHolder> list = this.immutableLoadedChunks.values().stream().filter(ChunkHolder::isAccessible).peek(ChunkHolder::updateAccessible).collect(Collectors.toList());
+         // Velox start: immutableLoadedChunks values stream thread-safe
+         List<ChunkHolder> list;
+         this.immutableLoadedChunksLock.readLock().lock();
+         list = this.immutableLoadedChunks.values().stream().filter(ChunkHolder::isAccessible).peek(ChunkHolder::updateAccessible).collect(Collectors.toList());
+         this.immutableLoadedChunksLock.readLock().unlock();
+         // Velox end
          MutableBoolean mutableboolean = new MutableBoolean();
 
          do {
@@ -345,14 +362,21 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
          this.func_227079_i_();
          LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", (Object)this.dimensionDirectory.getName());
       } else {
-         this.immutableLoadedChunks.values().stream().filter(ChunkHolder::isAccessible).forEach((p_222965_1_) -> {
-            IChunk ichunk = p_222965_1_.func_219302_f().getNow((IChunk)null);
-            if (ichunk instanceof ChunkPrimerWrapper || ichunk instanceof Chunk) {
-               this.chunkSave(ichunk);
-               p_222965_1_.updateAccessible();
-            }
+         // Velox start: immutableLoadedChunks value stream threadsafe
+         this.immutableLoadedChunksLock.readLock().lock();
+         try {
+            this.immutableLoadedChunks.values().stream().filter(ChunkHolder::isAccessible).forEach((p_222965_1_) -> {
+               IChunk ichunk = p_222965_1_.func_219302_f().getNow((IChunk) null);
+               if (ichunk instanceof ChunkPrimerWrapper || ichunk instanceof Chunk) {
+                  this.chunkSave(ichunk);
+                  p_222965_1_.updateAccessible();
+               }
 
-         });
+            });
+         } finally {
+            this.immutableLoadedChunksLock.readLock().unlock();
+         }
+         // Velox end
       }
 
    }
@@ -426,7 +450,11 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
       if (!this.immutableLoadedChunksDirty) {
          return false;
       } else {
+         // Velox start: immutableLoadedChunks refresh threadsafe
+         this.immutableLoadedChunksLock.writeLock().lock();
          this.immutableLoadedChunks = this.loadedChunks.clone();
+         this.immutableLoadedChunksLock.writeLock().unlock();
+         // Velox end
          this.immutableLoadedChunksDirty = false;
          return true;
       }
@@ -754,7 +782,12 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    }
 
    public int getLoadedChunkCount() {
-      return this.immutableLoadedChunks.size();
+      // Velox start: getLoadedChunkCount threadsafe
+      this.immutableLoadedChunksLock.readLock().lock();
+      int size = this.immutableLoadedChunks.size();
+      this.immutableLoadedChunksLock.readLock().unlock();
+      return size;
+      // Velox end
    }
 
    protected ChunkManager.ProxyTicketManager getTicketManager() {
@@ -762,13 +795,23 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    }
 
    protected Iterable<ChunkHolder> getLoadedChunksIterable() {
-      return Iterables.unmodifiableIterable(this.immutableLoadedChunks.values());
+      // Velox start: getLoadedChunksIterable threadsafe + prefetch
+      this.immutableLoadedChunksLock.readLock().lock();
+      Iterable<ChunkHolder> chunkHolders = Iterables.unmodifiableIterable(Lists.newArrayList(this.immutableLoadedChunks.values()));
+      this.immutableLoadedChunksLock.readLock().unlock();
+      return chunkHolders;
+      // Velox end
    }
 
    void func_225406_a(Writer p_225406_1_) throws IOException {
       CSVWriter csvwriter = CSVWriter.func_225428_a().func_225423_a("x").func_225423_a("z").func_225423_a("level").func_225423_a("in_memory").func_225423_a("status").func_225423_a("full_status").func_225423_a("accessible_ready").func_225423_a("ticking_ready").func_225423_a("entity_ticking_ready").func_225423_a("ticket").func_225423_a("spawning").func_225423_a("entity_count").func_225423_a("block_entity_count").func_225422_a(p_225406_1_);
 
-      for(Entry<ChunkHolder> entry : this.immutableLoadedChunks.long2ObjectEntrySet()) {
+      // Velox start: immutableLoadedChunks entry set iteration threadsafe + prefetch
+      this.immutableLoadedChunksLock.readLock().lock();
+      List<Entry<ChunkHolder>> entrySet = IteratorUtils.collect(this.immutableLoadedChunks.long2ObjectEntrySet().iterator());
+      this.immutableLoadedChunksLock.readLock().unlock();
+      for(Entry<ChunkHolder> entry : entrySet) {
+         // Velox end
          ChunkPos chunkpos = new ChunkPos(entry.getLongKey());
          ChunkHolder chunkholder = entry.getValue();
          Optional<IChunk> optional = Optional.ofNullable(chunkholder.func_219287_e());
@@ -852,82 +895,88 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    }
 
    public void updatePlayerPosition(ServerPlayerEntity player) {
-      for(ChunkManager.EntityTracker chunkmanager$entitytracker : this.entities.values()) {
-         if (chunkmanager$entitytracker.entity == player) {
-            chunkmanager$entitytracker.updateTrackingState(this.world.getPlayers());
-         } else {
-            chunkmanager$entitytracker.updateTrackingState(player);
+      // Velox start: ChunkManager#updatePlayerPosition threadsafe
+      this.entityTrackerLock.writeLock().lock();
+      try {
+         for (ChunkManager.EntityTracker chunkmanager$entitytracker : this.entities.values()) {
+            if (chunkmanager$entitytracker.entity == player) {
+               chunkmanager$entitytracker.updateTrackingState(this.world.getPlayers());
+            } else {
+               chunkmanager$entitytracker.updateTrackingState(player);
+            }
          }
-      }
 
-      int l1 = MathHelper.floor(player.getPosX()) >> 4;
-      int i2 = MathHelper.floor(player.getPosZ()) >> 4;
-      SectionPos sectionpos = player.getManagedSectionPos();
-      SectionPos sectionpos1 = SectionPos.from(player);
-      long i = sectionpos.asChunkPos().asLong();
-      long j = sectionpos1.asChunkPos().asLong();
-      boolean flag = this.playerGenerationTracker.canGeneratePlayer(player);
-      boolean flag1 = this.cannotGenerateChunks(player);
-      boolean flag2 = sectionpos.asLong() != sectionpos1.asLong();
-      if (flag2 || flag != flag1) {
-         this.func_223489_c(player);
-         if (!flag) {
-            this.ticketManager.removePlayer(sectionpos, player);
-         }
+         int l1 = MathHelper.floor(player.getPosX()) >> 4;
+         int i2 = MathHelper.floor(player.getPosZ()) >> 4;
+         SectionPos sectionpos = player.getManagedSectionPos();
+         SectionPos sectionpos1 = SectionPos.from(player);
+         long i = sectionpos.asChunkPos().asLong();
+         long j = sectionpos1.asChunkPos().asLong();
+         boolean flag = this.playerGenerationTracker.canGeneratePlayer(player);
+         boolean flag1 = this.cannotGenerateChunks(player);
+         boolean flag2 = sectionpos.asLong() != sectionpos1.asLong();
+         if (flag2 || flag != flag1) {
+            this.func_223489_c(player);
+            if (!flag) {
+               this.ticketManager.removePlayer(sectionpos, player);
+            }
 
-         if (!flag1) {
-            this.ticketManager.updatePlayerPosition(sectionpos1, player);
-         }
+            if (!flag1) {
+               this.ticketManager.updatePlayerPosition(sectionpos1, player);
+            }
 
-         if (!flag && flag1) {
-            this.playerGenerationTracker.disableGeneration(player);
-         }
+            if (!flag && flag1) {
+               this.playerGenerationTracker.disableGeneration(player);
+            }
 
-         if (flag && !flag1) {
-            this.playerGenerationTracker.enableGeneration(player);
-         }
+            if (flag && !flag1) {
+               this.playerGenerationTracker.enableGeneration(player);
+            }
 
-         if (i != j) {
-            this.playerGenerationTracker.updatePlayerPosition(i, j, player);
+            if (i != j) {
+               this.playerGenerationTracker.updatePlayerPosition(i, j, player);
+            }
          }
-      }
 
-      int k = sectionpos.getSectionX();
-      int l = sectionpos.getSectionZ();
-      if (Math.abs(k - l1) <= this.viewDistance * 2 && Math.abs(l - i2) <= this.viewDistance * 2) {
-         int k2 = Math.min(l1, k) - this.viewDistance;
-         int i3 = Math.min(i2, l) - this.viewDistance;
-         int j3 = Math.max(l1, k) + this.viewDistance;
-         int k3 = Math.max(i2, l) + this.viewDistance;
-
-         for(int l3 = k2; l3 <= j3; ++l3) {
-            for(int k1 = i3; k1 <= k3; ++k1) {
-               ChunkPos chunkpos1 = new ChunkPos(l3, k1);
-               boolean flag5 = getChunkDistance(chunkpos1, k, l) <= this.viewDistance;
-               boolean flag6 = getChunkDistance(chunkpos1, l1, i2) <= this.viewDistance;
-               this.setChunkLoadedAtClient(player, chunkpos1, new IPacket[2], flag5, flag6);
+         int k = sectionpos.getSectionX();
+         int l = sectionpos.getSectionZ();
+         if (Math.abs(k - l1) <= this.viewDistance * 2 && Math.abs(l - i2) <= this.viewDistance * 2) {
+            int k2 = Math.min(l1, k) - this.viewDistance;
+            int i3 = Math.min(i2, l) - this.viewDistance;
+            int j3 = Math.max(l1, k) + this.viewDistance;
+            int k3 = Math.max(i2, l) + this.viewDistance;
+
+            for (int l3 = k2; l3 <= j3; ++l3) {
+               for (int k1 = i3; k1 <= k3; ++k1) {
+                  ChunkPos chunkpos1 = new ChunkPos(l3, k1);
+                  boolean flag5 = getChunkDistance(chunkpos1, k, l) <= this.viewDistance;
+                  boolean flag6 = getChunkDistance(chunkpos1, l1, i2) <= this.viewDistance;
+                  this.setChunkLoadedAtClient(player, chunkpos1, new IPacket[2], flag5, flag6);
+               }
             }
-         }
-      } else {
-         for(int i1 = k - this.viewDistance; i1 <= k + this.viewDistance; ++i1) {
-            for(int j1 = l - this.viewDistance; j1 <= l + this.viewDistance; ++j1) {
-               ChunkPos chunkpos = new ChunkPos(i1, j1);
-               boolean flag3 = true;
-               boolean flag4 = false;
-               this.setChunkLoadedAtClient(player, chunkpos, new IPacket[2], true, false);
+         } else {
+            for (int i1 = k - this.viewDistance; i1 <= k + this.viewDistance; ++i1) {
+               for (int j1 = l - this.viewDistance; j1 <= l + this.viewDistance; ++j1) {
+                  ChunkPos chunkpos = new ChunkPos(i1, j1);
+                  boolean flag3 = true;
+                  boolean flag4 = false;
+                  this.setChunkLoadedAtClient(player, chunkpos, new IPacket[2], true, false);
+               }
             }
-         }
 
-         for(int j2 = l1 - this.viewDistance; j2 <= l1 + this.viewDistance; ++j2) {
-            for(int l2 = i2 - this.viewDistance; l2 <= i2 + this.viewDistance; ++l2) {
-               ChunkPos chunkpos2 = new ChunkPos(j2, l2);
-               boolean flag7 = false;
-               boolean flag8 = true;
-               this.setChunkLoadedAtClient(player, chunkpos2, new IPacket[2], false, true);
+            for (int j2 = l1 - this.viewDistance; j2 <= l1 + this.viewDistance; ++j2) {
+               for (int l2 = i2 - this.viewDistance; l2 <= i2 + this.viewDistance; ++l2) {
+                  ChunkPos chunkpos2 = new ChunkPos(j2, l2);
+                  boolean flag7 = false;
+                  boolean flag8 = true;
+                  this.setChunkLoadedAtClient(player, chunkpos2, new IPacket[2], false, true);
+               }
             }
          }
+      } finally {
+         this.entityTrackerLock.writeLock().unlock();
       }
-
+      // Velox end
    }
 
    public Stream<ServerPlayerEntity> getTrackingPlayers(ChunkPos pos, boolean boundaryOnly) {
@@ -942,78 +991,101 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    }
 
    protected void track(Entity entityIn) {
-      if (!(entityIn instanceof EnderDragonPartEntity)) {
-         EntityType<?> entitytype = entityIn.getType();
-         int i = entitytype.func_233602_m_() * 16;
-         int j = entitytype.getUpdateFrequency();
-         if (this.entities.containsKey(entityIn.getEntityId())) {
-            throw (IllegalStateException)Util.pauseDevMode(new IllegalStateException("Entity is already tracked!"));
-         } else {
-            ChunkManager.EntityTracker chunkmanager$entitytracker = new ChunkManager.EntityTracker(entityIn, i, j, entitytype.shouldSendVelocityUpdates());
-            this.entities.put(entityIn.getEntityId(), chunkmanager$entitytracker);
-            chunkmanager$entitytracker.updateTrackingState(this.world.getPlayers());
-            if (entityIn instanceof ServerPlayerEntity) {
-               ServerPlayerEntity serverplayerentity = (ServerPlayerEntity)entityIn;
-               this.setPlayerTracking(serverplayerentity, true);
-
-               for(ChunkManager.EntityTracker chunkmanager$entitytracker1 : this.entities.values()) {
-                  if (chunkmanager$entitytracker1.entity != serverplayerentity) {
-                     chunkmanager$entitytracker1.updateTrackingState(serverplayerentity);
+      // Velox start: ChunkManager#track threadsafe
+      this.entityTrackerLock.writeLock().lock();
+      try {
+         if (!(entityIn instanceof EnderDragonPartEntity)) {
+            EntityType<?> entitytype = entityIn.getType();
+            int i = entitytype.func_233602_m_() * 16;
+            int j = entitytype.getUpdateFrequency();
+            if (this.entities.containsKey(entityIn.getEntityId())) {
+               throw (IllegalStateException) Util.pauseDevMode(new IllegalStateException("Entity is already tracked!"));
+            } else {
+               ChunkManager.EntityTracker chunkmanager$entitytracker = new ChunkManager.EntityTracker(entityIn, i, j, entitytype.shouldSendVelocityUpdates());
+               this.entities.put(entityIn.getEntityId(), chunkmanager$entitytracker);
+               chunkmanager$entitytracker.updateTrackingState(this.world.getPlayers());
+               if (entityIn instanceof ServerPlayerEntity) {
+                  ServerPlayerEntity serverplayerentity = (ServerPlayerEntity) entityIn;
+                  this.setPlayerTracking(serverplayerentity, true);
+
+                  for (ChunkManager.EntityTracker chunkmanager$entitytracker1 : this.entities.values()) {
+                     if (chunkmanager$entitytracker1.entity != serverplayerentity) {
+                        chunkmanager$entitytracker1.updateTrackingState(serverplayerentity);
+                     }
                   }
                }
-            }
 
+            }
          }
+      } finally {
+         this.entityTrackerLock.writeLock().unlock();
       }
+      // Velox end
    }
 
    protected void untrack(Entity entity) {
-      if (entity instanceof ServerPlayerEntity) {
-         ServerPlayerEntity serverplayerentity = (ServerPlayerEntity)entity;
-         this.setPlayerTracking(serverplayerentity, false);
+      // Velox start: ChunkManager#untrack threadsafe
+      this.entityTrackerLock.writeLock().lock();
+      try {
+         if (entity instanceof ServerPlayerEntity) {
+            ServerPlayerEntity serverplayerentity = (ServerPlayerEntity) entity;
+            this.setPlayerTracking(serverplayerentity, false);
 
-         for(ChunkManager.EntityTracker chunkmanager$entitytracker : this.entities.values()) {
-            chunkmanager$entitytracker.removeTracker(serverplayerentity);
+            for (ChunkManager.EntityTracker chunkmanager$entitytracker : this.entities.values()) {
+               chunkmanager$entitytracker.removeTracker(serverplayerentity);
+            }
          }
-      }
 
-      ChunkManager.EntityTracker chunkmanager$entitytracker1 = this.entities.remove(entity.getEntityId());
-      if (chunkmanager$entitytracker1 != null) {
-         chunkmanager$entitytracker1.removeAllTrackers();
+         ChunkManager.EntityTracker chunkmanager$entitytracker1 = this.entities.remove(entity.getEntityId());
+         if (chunkmanager$entitytracker1 != null) {
+            chunkmanager$entitytracker1.removeAllTrackers();
+         }
+      } finally {
+         this.entityTrackerLock.writeLock().unlock();
       }
-
+      // Velox end
    }
 
    protected void tickEntityTracker() {
-      List<ServerPlayerEntity> list = Lists.newArrayList();
-      List<ServerPlayerEntity> list1 = this.world.getPlayers();
+      // Velox start: ChunkManager#tickEntityTracker threadsafe
+      this.entityTrackerLock.writeLock().lock();
+      try {
+         List<ServerPlayerEntity> list = Lists.newArrayList();
+         List<ServerPlayerEntity> list1 = this.world.getPlayers();
+
+         for (ChunkManager.EntityTracker chunkmanager$entitytracker : this.entities.values()) {
+            SectionPos sectionpos = chunkmanager$entitytracker.pos;
+            SectionPos sectionpos1 = SectionPos.from(chunkmanager$entitytracker.entity);
+            if (!Objects.equals(sectionpos, sectionpos1)) {
+               chunkmanager$entitytracker.updateTrackingState(list1);
+               Entity entity = chunkmanager$entitytracker.entity;
+               if (entity instanceof ServerPlayerEntity) {
+                  list.add((ServerPlayerEntity) entity);
+               }
 
-      for(ChunkManager.EntityTracker chunkmanager$entitytracker : this.entities.values()) {
-         SectionPos sectionpos = chunkmanager$entitytracker.pos;
-         SectionPos sectionpos1 = SectionPos.from(chunkmanager$entitytracker.entity);
-         if (!Objects.equals(sectionpos, sectionpos1)) {
-            chunkmanager$entitytracker.updateTrackingState(list1);
-            Entity entity = chunkmanager$entitytracker.entity;
-            if (entity instanceof ServerPlayerEntity) {
-               list.add((ServerPlayerEntity)entity);
+               chunkmanager$entitytracker.pos = sectionpos1;
             }
 
-            chunkmanager$entitytracker.pos = sectionpos1;
+            chunkmanager$entitytracker.entry.tick();
          }
 
-         chunkmanager$entitytracker.entry.tick();
-      }
-
-      if (!list.isEmpty()) {
-         for(ChunkManager.EntityTracker chunkmanager$entitytracker1 : this.entities.values()) {
-            chunkmanager$entitytracker1.updateTrackingState(list);
+         if (!list.isEmpty()) {
+            for (ChunkManager.EntityTracker chunkmanager$entitytracker1 : this.entities.values()) {
+               chunkmanager$entitytracker1.updateTrackingState(list);
+            }
          }
+      } finally {
+         this.entityTrackerLock.writeLock().unlock();
       }
-
+      // Velox end
    }
 
    protected void sendToAllTracking(Entity entity, IPacket<?> p_219222_2_) {
+      // Velox start: ChunkManager#sendToAllTracking threadsafe
+      this.entityTrackerLock.readLock().lock();
       ChunkManager.EntityTracker chunkmanager$entitytracker = this.entities.get(entity.getEntityId());
+      this.entityTrackerLock.readLock().unlock();
+      // Velox end
       if (chunkmanager$entitytracker != null) {
          chunkmanager$entitytracker.sendToAllTracking(p_219222_2_);
       }
@@ -1021,7 +1093,11 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    }
 
    protected void sendToTrackingAndSelf(Entity entity, IPacket<?> p_219225_2_) {
+      // Velox start: ChunkManager#sendToTrackingAndSelf threadsafe
+      this.entityTrackerLock.readLock().lock();
       ChunkManager.EntityTracker chunkmanager$entitytracker = this.entities.get(entity.getEntityId());
+      this.entityTrackerLock.readLock().unlock();
+      // Velox end
       if (chunkmanager$entitytracker != null) {
          chunkmanager$entitytracker.sendToTrackingAndSelf(p_219225_2_);
       }
@@ -1083,6 +1159,9 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
       private final int range;
       private SectionPos pos;
       private final Set<ServerPlayerEntity> trackingPlayers = Sets.newHashSet();
+      // Velox start: EntityTracker#lock
+      private final ReadWriteLock lock = new ReentrantReadWriteLock();
+      // Velox end
 
       public EntityTracker(Entity entity, int p_i50468_3_, int updateFrequency, boolean sendVelocityUpdates) {
          this.entry = new TrackedEntity(ChunkManager.this.world, entity, updateFrequency, sendVelocityUpdates, this::sendToAllTracking);
@@ -1104,10 +1183,14 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
       }
 
       public void sendToAllTracking(IPacket<?> p_219391_1_) {
-         for(ServerPlayerEntity serverplayerentity : this.trackingPlayers) {
+         // Velox start: EntityTracker#sendToAllTracking threadsafe
+         this.lock.readLock().lock();
+         List<ServerPlayerEntity> trackingPlayers = Lists.newArrayList(this.trackingPlayers);
+         this.lock.readLock().unlock();
+         for(ServerPlayerEntity serverplayerentity : trackingPlayers) {
             serverplayerentity.connection.sendPacket(p_219391_1_);
          }
-
+         // Velox end
       }
 
       public void sendToTrackingAndSelf(IPacket<?> p_219392_1_) {
@@ -1119,42 +1202,54 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
       }
 
       public void removeAllTrackers() {
+         // Velox start: EntityTracker#removeAllTrackers threadsafe
+         this.lock.writeLock().lock();
          for(ServerPlayerEntity serverplayerentity : this.trackingPlayers) {
             this.entry.untrack(serverplayerentity);
          }
-
+         this.lock.writeLock().unlock();
+         // Velox end
       }
 
       public void removeTracker(ServerPlayerEntity player) {
+         // Velox start: EntityTracker#removeTracker threadsafe
+         this.lock.writeLock().lock();
          if (this.trackingPlayers.remove(player)) {
             this.entry.untrack(player);
          }
-
+         this.lock.writeLock().unlock();
+         // Velox end
       }
 
       public void updateTrackingState(ServerPlayerEntity player) {
-         if (player != this.entity) {
-            Vector3d vector3d = player.getPositionVec().subtract(this.entry.getDecodedPosition());
-            int i = Math.min(this.func_229843_b_(), (ChunkManager.this.viewDistance - 1) * 16);
-            boolean flag = vector3d.x >= (double)(-i) && vector3d.x <= (double)i && vector3d.z >= (double)(-i) && vector3d.z <= (double)i && this.entity.isSpectatedByPlayer(player);
-            if (flag) {
-               boolean flag1 = this.entity.forceSpawn;
-               if (!flag1) {
-                  ChunkPos chunkpos = new ChunkPos(this.entity.chunkCoordX, this.entity.chunkCoordZ);
-                  ChunkHolder chunkholder = ChunkManager.this.func_219219_b(chunkpos.asLong());
-                  if (chunkholder != null && chunkholder.getChunkIfComplete() != null) {
-                     flag1 = ChunkManager.func_219215_b(chunkpos, player, false) <= ChunkManager.this.viewDistance;
+         // Velox start: EntityTracker#updateTrackingState threadsafe
+         this.lock.writeLock().lock();
+         try {
+            if (player != this.entity) {
+               Vector3d vector3d = player.getPositionVec().subtract(this.entry.getDecodedPosition());
+               int i = Math.min(this.func_229843_b_(), (ChunkManager.this.viewDistance - 1) * 16);
+               boolean flag = vector3d.x >= (double) (-i) && vector3d.x <= (double) i && vector3d.z >= (double) (-i) && vector3d.z <= (double) i && this.entity.isSpectatedByPlayer(player);
+               if (flag) {
+                  boolean flag1 = this.entity.forceSpawn;
+                  if (!flag1) {
+                     ChunkPos chunkpos = new ChunkPos(this.entity.chunkCoordX, this.entity.chunkCoordZ);
+                     ChunkHolder chunkholder = ChunkManager.this.func_219219_b(chunkpos.asLong());
+                     if (chunkholder != null && chunkholder.getChunkIfComplete() != null) {
+                        flag1 = ChunkManager.func_219215_b(chunkpos, player, false) <= ChunkManager.this.viewDistance;
+                     }
                   }
-               }
 
-               if (flag1 && this.trackingPlayers.add(player)) {
-                  this.entry.track(player);
+                  if (flag1 && this.trackingPlayers.add(player)) {
+                     this.entry.track(player);
+                  }
+               } else if (this.trackingPlayers.remove(player)) {
+                  this.entry.untrack(player);
                }
-            } else if (this.trackingPlayers.remove(player)) {
-               this.entry.untrack(player);
             }
-
+         } finally {
+            this.lock.writeLock().unlock();
          }
+         // Velox end
       }
 
       private int func_241091_a_(int p_241091_1_) {
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerChunkProvider.java b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
index 41500e3..38f967d 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerChunkProvider.java
+++ b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
@@ -6,7 +6,6 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
@@ -50,7 +49,9 @@ public class ServerChunkProvider extends AbstractChunkProvider {
    private static final List<ChunkStatus> field_217239_c = ChunkStatus.getAll();
    private final TicketManager ticketManager;
    private final ChunkGenerator generator;
-   private final ServerWorld world;
+   // Velox start: Make ServerChunkProvider#world protected
+   protected final ServerWorld world;
+   // Velox end
    private final Thread mainThread;
    private final ServerWorldLightManager lightManager;
    private final ServerChunkProvider.ChunkExecutor executor;
@@ -59,9 +60,7 @@ public class ServerChunkProvider extends AbstractChunkProvider {
    private long lastGameTime;
    private boolean spawnHostiles = true;
    private boolean spawnPassives = true;
-   private final long[] recentPositions = new long[4];
-   private final ChunkStatus[] recentStatuses = new ChunkStatus[4];
-   private final IChunk[] recentChunks = new IChunk[4];
+   // Velox deletion: delete Minecraft's own chunk cache because of thread safety concerns
    @Nullable
    private WorldEntitySpawner.EntityDensityManager field_241097_p_;
 
@@ -77,7 +76,8 @@ public class ServerChunkProvider extends AbstractChunkProvider {
       this.chunkManager = new ChunkManager(p_i232603_1_, p_i232603_2_, p_i232603_3_, p_i232603_4_, p_i232603_5_, this.executor, this, this.getChunkGenerator(), p_i232603_9_, p_i232603_10_, p_i232603_7_, p_i232603_8_);
       this.lightManager = this.chunkManager.getLightManager();
       this.ticketManager = this.chunkManager.getTicketManager();
-      this.invalidateCaches();
+      // Velox deletion: don't invalidate the cache during initialization. Method invoked before the super class
+      // that implements the cache is initialized
    }
 
    public ServerWorldLightManager getLightManager() {
@@ -93,97 +93,99 @@ public class ServerChunkProvider extends AbstractChunkProvider {
       return this.chunkManager.func_219174_c();
    }
 
-   private void func_225315_a(long p_225315_1_, IChunk p_225315_3_, ChunkStatus p_225315_4_) {
-      for(int i = 3; i > 0; --i) {
-         this.recentPositions[i] = this.recentPositions[i - 1];
-         this.recentStatuses[i] = this.recentStatuses[i - 1];
-         this.recentChunks[i] = this.recentChunks[i - 1];
-      }
-
-      this.recentPositions[0] = p_225315_1_;
-      this.recentStatuses[0] = p_225315_4_;
-      this.recentChunks[0] = p_225315_3_;
-   }
-
    @Nullable
    public IChunk getChunk(int chunkX, int chunkZ, ChunkStatus requiredStatus, boolean load) {
-      if (Thread.currentThread() != this.mainThread) {
-         return CompletableFuture.supplyAsync(() -> {
-            return this.getChunk(chunkX, chunkZ, requiredStatus, load);
-         }, this.executor).join();
-      } else {
-         IProfiler iprofiler = this.world.getProfiler();
-         iprofiler.func_230035_c_("getChunk");
-         long i = ChunkPos.asLong(chunkX, chunkZ);
-
-         for(int j = 0; j < 4; ++j) {
-            if (i == this.recentPositions[j] && requiredStatus == this.recentStatuses[j]) {
-               IChunk ichunk = this.recentChunks[j];
-               if (ichunk != null || !load) {
-                  return ichunk;
-               }
-            }
-         }
+      // Velox start: Remove getChunk mainThread check
+      IProfiler iprofiler = this.world.getProfiler();
+      iprofiler.func_230035_c_("getChunk");
+      long i = ChunkPos.asLong(chunkX, chunkZ);
 
-         iprofiler.func_230035_c_("getChunkCacheMiss");
-         CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.func_217233_c(chunkX, chunkZ, requiredStatus, load);
-         this.executor.driveUntil(completablefuture::isDone);
-         IChunk ichunk1 = completablefuture.join().map((p_222874_0_) -> {
-            return p_222874_0_;
-         }, (p_222870_1_) -> {
-            if (load) {
-               throw (IllegalStateException)Util.pauseDevMode(new IllegalStateException("Chunk not there when requested: " + p_222870_1_));
-            } else {
-               return null;
-            }
-         });
-         this.func_225315_a(i, ichunk1, requiredStatus);
-         return ichunk1;
+      // Velox start: Call chunk cache lookup
+      IChunk chunk = lookupChunkCache(i, requiredStatus, load);
+      if (chunk != null) {
+         return chunk;
       }
+      // Velox end
+
+      iprofiler.func_230035_c_("getChunkCacheMiss");
+
+      chunk = this.fallbackLookup(chunkX, chunkZ, requiredStatus, load);
+      // Velox start: Call populateChunkCache
+      if (chunk != null)
+         populateChunkCache(chunkX, chunkZ, chunk);
+      // Velox end
+      return chunk;
+      // Velox end
+   }
+
+   // Velox start: create fallbackLookup which can be overridden to implement a chunk cache
+   protected IChunk fallbackLookup(int chunkX, int chunkZ, ChunkStatus requiredStatus, boolean load) {
+      CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.func_217233_c(chunkX, chunkZ, requiredStatus, load);
+      this.executor.driveUntil(completablefuture::isDone);
+      return completablefuture.join().map((p_222874_0_) -> {
+         return p_222874_0_;
+      }, (p_222870_1_) -> {
+         if (load) {
+            throw (IllegalStateException)Util.pauseDevMode(new IllegalStateException("Chunk not there when requested: " + p_222870_1_));
+         } else {
+            return null;
+         }
+      });
+   }
+   // Velox end
+
+   // Velox start: create lookupChunkCache which can be overridden to implement a chunk cache
+   protected IChunk lookupChunkCache(long packedChunkPos, ChunkStatus requiredStatus, boolean load) {
+      return null;
    }
+   // Velox end
 
    @Nullable
    public Chunk getChunkNow(int chunkX, int chunkZ) {
-      if (Thread.currentThread() != this.mainThread) {
-         return null;
-      } else {
-         this.world.getProfiler().func_230035_c_("getChunkNow");
-         long i = ChunkPos.asLong(chunkX, chunkZ);
+      // Velox start: Remove getChunkNow mainThread check
+      this.world.getProfiler().func_230035_c_("getChunkNow");
+      long i = ChunkPos.asLong(chunkX, chunkZ);
 
-         for(int j = 0; j < 4; ++j) {
-            if (i == this.recentPositions[j] && this.recentStatuses[j] == ChunkStatus.FULL) {
-               IChunk ichunk = this.recentChunks[j];
-               return ichunk instanceof Chunk ? (Chunk)ichunk : null;
-            }
-         }
+      // Velox start: Call chunk cache lookup
+      IChunk chunk = lookupChunkCache(i, ChunkStatus.FULL, true);
+      if (chunk != null) {
+         return chunk instanceof Chunk ? (Chunk) chunk : null;
+      }
+      // Velox end
 
-         ChunkHolder chunkholder = this.func_217213_a(i);
-         if (chunkholder == null) {
+      ChunkHolder chunkholder = this.func_217213_a(i);
+      if (chunkholder == null) {
+         return null;
+      } else {
+         Either<IChunk, ChunkHolder.IChunkLoadingError> either = chunkholder.func_225410_b(ChunkStatus.FULL).getNow((Either<IChunk, ChunkHolder.IChunkLoadingError>)null);
+         if (either == null) {
             return null;
          } else {
-            Either<IChunk, ChunkHolder.IChunkLoadingError> either = chunkholder.func_225410_b(ChunkStatus.FULL).getNow((Either<IChunk, ChunkHolder.IChunkLoadingError>)null);
-            if (either == null) {
-               return null;
-            } else {
-               IChunk ichunk1 = either.left().orElse((IChunk)null);
-               if (ichunk1 != null) {
-                  this.func_225315_a(i, ichunk1, ChunkStatus.FULL);
-                  if (ichunk1 instanceof Chunk) {
-                     return (Chunk)ichunk1;
-                  }
+            IChunk ichunk1 = either.left().orElse((IChunk)null);
+            if (ichunk1 != null) {
+               if (ichunk1 instanceof Chunk) {
+                  // Velox start: Call populateChunkCache
+                  populateChunkCache(chunkX, chunkZ, ichunk1);
+                  // Velox end
+                  return (Chunk)ichunk1;
                }
-
-               return null;
             }
+
+            return null;
          }
       }
+      // Velox end
+   }
+
+   // Velox start: create populateChunkCache which can be implemented to create a chunk cache
+   protected void populateChunkCache(int chunkX, int chunkZ, IChunk chunk) {
    }
+   // velox end
 
-   private void invalidateCaches() {
-      Arrays.fill(this.recentPositions, ChunkPos.SENTINEL);
-      Arrays.fill(this.recentStatuses, (Object)null);
-      Arrays.fill(this.recentChunks, (Object)null);
+   // Velox start: make protected for own chunk cache implementation
+   protected void invalidateCaches() {
    }
+   // Velox end
 
    @OnlyIn(Dist.CLIENT)
    public CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> func_217232_b(int chunkX, int chunkZ, ChunkStatus requiredStatus, boolean load) {
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerTickList.java b/src/main/java/net/minecraft/world/server/ServerTickList.java
index bebc123..1898cca 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerTickList.java
+++ b/src/main/java/net/minecraft/world/server/ServerTickList.java
@@ -10,10 +10,13 @@ import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
 import net.minecraft.block.BlockState;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
@@ -37,6 +40,9 @@ public class ServerTickList<T> implements ITickList<T> {
    private final Queue<NextTickListEntry<T>> pendingTickListEntriesThisTick = Queues.newArrayDeque();
    private final List<NextTickListEntry<T>> entriesRunThisTick = Lists.newArrayList();
    private final Consumer<NextTickListEntry<T>> tickFunction;
+   // Velox start: ServerTickList#lock
+   private final ReadWriteLock lock = new ReentrantReadWriteLock();
+   // Velox end
 
    public ServerTickList(ServerWorld p_i231625_1_, Predicate<T> p_i231625_2_, Function<T, ResourceLocation> p_i231625_3_, Consumer<NextTickListEntry<T>> p_i231625_4_) {
       this.filter = p_i231625_2_;
@@ -46,55 +52,62 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    public void tick() {
-      int i = this.pendingTickListEntriesTreeSet.size();
-      if (i != this.pendingTickListEntriesHashSet.size()) {
-         throw new IllegalStateException("TickNextTick list out of synch");
-      } else {
-         if (i > 65536) {
-            i = 65536;
-         }
+      // Velox start: ServerTickList#tick threadsafe
+      this.lock.writeLock().lock();
+      try {
+         int i = this.pendingTickListEntriesTreeSet.size();
+         if (i != this.pendingTickListEntriesHashSet.size()) {
+            throw new IllegalStateException("TickNextTick list out of synch");
+         } else {
+            if (i > 65536) {
+               i = 65536;
+            }
 
-         ServerChunkProvider serverchunkprovider = this.world.getChunkProvider();
-         Iterator<NextTickListEntry<T>> iterator = this.pendingTickListEntriesTreeSet.iterator();
-         this.world.getProfiler().startSection("cleaning");
+            ServerChunkProvider serverchunkprovider = this.world.getChunkProvider();
+            Iterator<NextTickListEntry<T>> iterator = this.pendingTickListEntriesTreeSet.iterator();
+            this.world.getProfiler().startSection("cleaning");
 
-         while(i > 0 && iterator.hasNext()) {
-            NextTickListEntry<T> nextticklistentry = iterator.next();
-            if (nextticklistentry.field_235017_b_ > this.world.getGameTime()) {
-               break;
-            }
+            while (i > 0 && iterator.hasNext()) {
+               NextTickListEntry<T> nextticklistentry = iterator.next();
+               if (nextticklistentry.field_235017_b_ > this.world.getGameTime()) {
+                  break;
+               }
 
-            if (serverchunkprovider.canTick(nextticklistentry.position)) {
-               iterator.remove();
-               this.pendingTickListEntriesHashSet.remove(nextticklistentry);
-               this.pendingTickListEntriesThisTick.add(nextticklistentry);
-               --i;
+               if (serverchunkprovider.canTick(nextticklistentry.position)) {
+                  iterator.remove();
+                  this.pendingTickListEntriesHashSet.remove(nextticklistentry);
+                  this.pendingTickListEntriesThisTick.add(nextticklistentry);
+                  --i;
+               }
             }
-         }
 
-         this.world.getProfiler().endStartSection("ticking");
-
-         NextTickListEntry<T> nextticklistentry1;
-         while((nextticklistentry1 = this.pendingTickListEntriesThisTick.poll()) != null) {
-            if (serverchunkprovider.canTick(nextticklistentry1.position)) {
-               try {
-                  this.entriesRunThisTick.add(nextticklistentry1);
-                  this.tickFunction.accept(nextticklistentry1);
-               } catch (Throwable throwable) {
-                  CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception while ticking");
-                  CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being ticked");
-                  CrashReportCategory.addBlockInfo(crashreportcategory, nextticklistentry1.position, (BlockState)null);
-                  throw new ReportedException(crashreport);
+            this.world.getProfiler().endStartSection("ticking");
+
+            NextTickListEntry<T> nextticklistentry1;
+            while ((nextticklistentry1 = this.pendingTickListEntriesThisTick.poll()) != null) {
+               if (serverchunkprovider.canTick(nextticklistentry1.position)) {
+                  try {
+                     this.entriesRunThisTick.add(nextticklistentry1);
+                     this.tickFunction.accept(nextticklistentry1);
+                  } catch (Throwable throwable) {
+                     CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception while ticking");
+                     CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being ticked");
+                     CrashReportCategory.addBlockInfo(crashreportcategory, nextticklistentry1.position, (BlockState) null);
+                     throw new ReportedException(crashreport);
+                  }
+               } else {
+                  this.scheduleTick(nextticklistentry1.position, nextticklistentry1.getTarget(), 0);
                }
-            } else {
-               this.scheduleTick(nextticklistentry1.position, nextticklistentry1.getTarget(), 0);
             }
-         }
 
-         this.world.getProfiler().endSection();
-         this.entriesRunThisTick.clear();
-         this.pendingTickListEntriesThisTick.clear();
+            this.world.getProfiler().endSection();
+            this.entriesRunThisTick.clear();
+            this.pendingTickListEntriesThisTick.clear();
+         }
+      } finally {
+         this.lock.writeLock().unlock();
       }
+      // Velox end
    }
 
    public boolean isTickPending(BlockPos pos, T obj) {
@@ -110,17 +123,24 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    public List<NextTickListEntry<T>> getPending(MutableBoundingBox p_205366_1_, boolean remove, boolean skipCompleted) {
-      List<NextTickListEntry<T>> list = this.getEntries((List<NextTickListEntry<T>>)null, this.pendingTickListEntriesTreeSet, p_205366_1_, remove);
-      if (remove && list != null) {
-         this.pendingTickListEntriesHashSet.removeAll(list);
-      }
+      // Velox start: ServerTickList#getPending threadsafe
+      try {
+         this.lock.writeLock().lock();
+         List<NextTickListEntry<T>> list = this.getEntries((List<NextTickListEntry<T>>) null, this.pendingTickListEntriesTreeSet, p_205366_1_, remove);
+         if (remove && list != null) {
+            this.pendingTickListEntriesHashSet.removeAll(list);
+         }
 
-      list = this.getEntries(list, this.pendingTickListEntriesThisTick, p_205366_1_, remove);
-      if (!skipCompleted) {
-         list = this.getEntries(list, this.entriesRunThisTick, p_205366_1_, remove);
-      }
+         list = this.getEntries(list, this.pendingTickListEntriesThisTick, p_205366_1_, remove);
+         if (!skipCompleted) {
+            list = this.getEntries(list, this.entriesRunThisTick, p_205366_1_, remove);
+         }
 
-      return list == null ? Collections.emptyList() : list;
+         return list == null ? Collections.emptyList() : list;
+      } finally {
+         this.lock.writeLock().unlock();
+      }
+      // Velox end
    }
 
    @Nullable
@@ -180,7 +200,12 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    public boolean isTickScheduled(BlockPos pos, T itemIn) {
-      return this.pendingTickListEntriesHashSet.contains(new NextTickListEntry(pos, itemIn));
+      // Velox start: ServerTickList#isTickScheduled threadsafe
+      this.lock.readLock().lock();
+      boolean contains = this.pendingTickListEntriesHashSet.contains(new NextTickListEntry(pos, itemIn));
+      this.lock.readLock().unlock();
+      // Velox end
+      return contains;
    }
 
    public void scheduleTick(BlockPos pos, T itemIn, int scheduledTime, TickPriority priority) {
@@ -191,14 +216,22 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    private void addEntry(NextTickListEntry<T> p_219504_1_) {
+      // Velox start: ServerTickList#addEntry threadsafe
+      this.lock.writeLock().lock();
       if (!this.pendingTickListEntriesHashSet.contains(p_219504_1_)) {
          this.pendingTickListEntriesHashSet.add(p_219504_1_);
          this.pendingTickListEntriesTreeSet.add(p_219504_1_);
       }
-
+      this.lock.writeLock().unlock();
+      // Velox end
    }
 
    public int func_225420_a() {
-      return this.pendingTickListEntriesHashSet.size();
+      // Velox start: ServerTickList#func_225420_a threadsafe
+      this.lock.readLock().lock();
+      int size = this.pendingTickListEntriesHashSet.size();
+      this.lock.readLock().unlock();
+      // Velox end
+      return size;
    }
 }
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerWorld.java b/src/main/java/net/minecraft/world/server/ServerWorld.java
index 4913be6..8e9a2c1 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerWorld.java
+++ b/src/main/java/net/minecraft/world/server/ServerWorld.java
@@ -12,7 +12,6 @@ import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.longs.LongSets;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
-import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
 import java.io.IOException;
 import java.io.Writer;
@@ -35,6 +34,9 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.chunk.ConcurrentChunkProvider;
+import me.mikex86.velox.tick.MadMaxTickManager;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockEventData;
 import net.minecraft.block.BlockState;
@@ -180,9 +182,11 @@ public class ServerWorld extends World implements ISeedReader {
       this.server = p_i241885_1_;
       this.field_241104_N_ = p_i241885_12_;
       this.field_241103_E_ = p_i241885_4_;
-      this.field_241102_C_ = new ServerChunkProvider(this, p_i241885_3_, p_i241885_1_.getDataFixer(), p_i241885_1_.getTemplateManager(), p_i241885_2_, p_i241885_8_, p_i241885_1_.getPlayerList().getViewDistance(), p_i241885_1_.func_230540_aS_(), p_i241885_7_, () -> {
+      // Velox start: Use Concurrent Chunk Provider instead of ServerChunkProvider
+      this.field_241102_C_ = new ConcurrentChunkProvider(this, p_i241885_3_, p_i241885_1_.getDataFixer(), p_i241885_1_.getTemplateManager(), p_i241885_2_, p_i241885_8_, p_i241885_1_.getPlayerList().getViewDistance(), p_i241885_1_.func_230540_aS_(), p_i241885_7_, () -> {
          return p_i241885_1_.func_241755_D_().getSavedData();
       });
+      // Velox end
       this.worldTeleporter = new Teleporter(this);
       this.calculateInitialSkylight();
       this.calculateInitialWeather();
@@ -344,75 +348,105 @@ public class ServerWorld extends World implements ISeedReader {
       }
 
       if (flag3 || this.updateEntityTick++ < 300) {
-         if (this.field_241105_O_ != null) {
-            this.field_241105_O_.tick();
-         }
-
-         this.tickingEntities = true;
-         ObjectIterator<Entry<Entity>> objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();
+         // Velox start: Call Velox tick entities method
+         this.tickEntitiesVelox();
+         // Velox end
+      }
 
-         label164:
-         while(true) {
-            Entity entity1;
-            while(true) {
-               if (!objectiterator.hasNext()) {
-                  this.tickingEntities = false;
+      iprofiler.endSection();
+   }
 
-                  Entity entity;
-                  while((entity = this.entitiesToAdd.poll()) != null) {
-                     this.onEntityAdded(entity);
-                  }
+   // Velox start: Velox tick entities method
+   private void tickEntitiesVelox() {
+      IProfiler profiler = this.getProfiler();
+      if (this.field_241105_O_ != null) {
+         this.field_241105_O_.tick();
+      }
 
-                  this.tickBlockEntities();
-                  break label164;
-               }
+      this.tickingEntities = true;
 
-               Entry<Entity> entry = objectiterator.next();
-               entity1 = entry.getValue();
-               Entity entity2 = entity1.getRidingEntity();
-               if (!this.server.func_230537_U_() && (entity1 instanceof AnimalEntity || entity1 instanceof WaterMobEntity)) {
-                  entity1.remove();
-               }
 
-               if (!this.server.func_230538_V_() && entity1 instanceof INPC) {
-                  entity1.remove();
-               }
+      // check entities for removal
+      {
+         Stream<Entry<Entity>> entityStream = this.entitiesById.int2ObjectEntrySet().stream();
+         entityStream.forEach(entry -> {
+            Entity entity = entry.getValue();
 
-               iprofiler.startSection("checkDespawn");
-               if (!entity1.removed) {
-                  entity1.checkDespawn();
-               }
+            // Marks all animals for removal, if spawning of animals is disabled
+            if (!this.server.func_230537_U_() && (entity instanceof AnimalEntity || entity instanceof WaterMobEntity)) {
+               entity.remove();
+            }
 
-               iprofiler.endSection();
-               if (entity2 == null) {
-                  break;
-               }
+            // Marks all NPCs for removal, if spawning of NPCs is disabled
+            if (!this.server.func_230538_V_() && entity instanceof INPC) {
+               entity.remove();
+            }
 
-               if (entity2.removed || !entity2.isPassenger(entity1)) {
-                  entity1.stopRiding();
-                  break;
-               }
+            profiler.startSection("checkDespawn");
+            // check if the entity should be de-spawned, if it isn't marked to get removed already
+            if (!entity.removed) {
+               entity.checkDespawn();
             }
+            profiler.endSection();
 
-            iprofiler.startSection("tick");
-            if (!entity1.removed && !(entity1 instanceof EnderDragonPartEntity)) {
-               this.guardEntityTick(this::updateEntity, entity1);
+            // riding entity of the entity marked for removal should stop riding remove-marked entity (if a riding entity is present)
+            Entity ridingEntity = entity.getRidingEntity();
+            if (ridingEntity != null && (ridingEntity.removed || !ridingEntity.isPassenger(entity))) {
+               entity.stopRiding();
             }
+         });
+      }
+      // tick entities
+      {
+         if (MadMaxTickManager.MAD_MAX_MODE) {
+            MadMaxTickManager.tickMadMax(this.entitiesById.values(), this::tickEntity);
+         } else {
+            // build tick list
+            this.tickRegionManager.buildEntityTickList(this.entitiesById.values().iterator());
 
-            iprofiler.endSection();
-            iprofiler.startSection("remove");
-            if (entity1.removed) {
-               this.removeFromChunk(entity1);
-               objectiterator.remove();
-               this.onEntityRemoved(entity1);
+            // tick entities
+            this.tickRegionManager.applyEntityTask(this::tickEntity);
+         }
+      }
+      // remove all entities marked for removal from the entity lists (server global, chunk local, invoke listeners etc...)
+      {
+         Stream<Entry<Entity>> entityStream = this.entitiesById.int2ObjectEntrySet().stream();
+         entityStream.forEach(entry -> {
+            Entity entity = entry.getValue();
+            profiler.startSection("remove");
+            if (entity.removed) {
+               this.removeFromChunk(entity);
+               this.onEntityRemoved(entity);
             }
+            profiler.endSection();
+         });
+         this.entitiesById.int2ObjectEntrySet().removeIf(e -> e.getValue().removed);
+      }
+      this.tickingEntities = false;
 
-            iprofiler.endSection();
+      // Add pending entities
+      {
+         Entity entity;
+         while ((entity = this.entitiesToAdd.poll()) != null) {
+            this.onEntityAdded(entity);
          }
       }
 
-      iprofiler.endSection();
+      // tick block entities
+      this.tickBlockEntities();
+   }
+   // Velox end
+
+   // Velox start: individual entity tick method
+   private void tickEntity(Entity entity) {
+      IProfiler profiler = this.getProfiler();
+      profiler.startSection("tick");
+      if (!entity.removed && !(entity instanceof EnderDragonPartEntity)) {
+         this.guardEntityTick(this::updateEntity, entity);
+      }
+      profiler.endSection();
    }
+   // Velox end
 
    protected void func_241126_b_() {
       if (this.field_241107_Q_) {
diff --git a/build/mcp_diff_src/net/minecraft/world/server/TicketManager.java b/src/main/java/net/minecraft/world/server/TicketManager.java
index 45afd47..619bb5c 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/TicketManager.java
+++ b/src/main/java/net/minecraft/world/server/TicketManager.java
@@ -20,7 +20,10 @@ import it.unimi.dsi.fastutil.objects.ObjectSet;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import javax.annotation.Nullable;
+
 import net.minecraft.entity.player.ServerPlayerEntity;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.concurrent.ITaskExecutor;
@@ -48,6 +51,9 @@ public abstract class TicketManager {
    private final LongSet chunkPositions = new LongOpenHashSet();
    private final Executor field_219388_p;
    private long currentTime;
+   // Velox start: TicketManager#lock
+   private final ReadWriteLock lock = new ReentrantReadWriteLock();
+   // Velox end
 
    protected TicketManager(Executor p_i50707_1_, Executor p_i50707_2_) {
       ITaskExecutor<Runnable> itaskexecutor = ITaskExecutor.inline("player ticket throttler", p_i50707_2_::execute);
@@ -59,22 +65,28 @@ public abstract class TicketManager {
    }
 
    protected void tick() {
-      ++this.currentTime;
-      ObjectIterator<Entry<SortedArraySet<Ticket<?>>>> objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
-
-      while(objectiterator.hasNext()) {
-         Entry<SortedArraySet<Ticket<?>>> entry = objectiterator.next();
-         if (entry.getValue().removeIf((p_219370_1_) -> {
-            return p_219370_1_.isExpired(this.currentTime);
-         })) {
-            this.ticketTracker.updateSourceLevel(entry.getLongKey(), getLevel(entry.getValue()), false);
-         }
+      // Velox start: TicketManager#tick threadsafe
+      this.lock.writeLock().lock();
+      try {
+         ++this.currentTime;
+         ObjectIterator<Entry<SortedArraySet<Ticket<?>>>> objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
+
+         while (objectiterator.hasNext()) {
+            Entry<SortedArraySet<Ticket<?>>> entry = objectiterator.next();
+            if (entry.getValue().removeIf((p_219370_1_) -> {
+               return p_219370_1_.isExpired(this.currentTime);
+            })) {
+               this.ticketTracker.updateSourceLevel(entry.getLongKey(), getLevel(entry.getValue()), false);
+            }
 
-         if (entry.getValue().isEmpty()) {
-            objectiterator.remove();
+            if (entry.getValue().isEmpty()) {
+               objectiterator.remove();
+            }
          }
+      } finally {
+        this.lock.writeLock().unlock();
       }
-
+      // Velox end
    }
 
    private static int getLevel(SortedArraySet<Ticket<?>> p_229844_0_) {
@@ -90,71 +102,91 @@ public abstract class TicketManager {
    protected abstract ChunkHolder setChunkLevel(long chunkPosIn, int newLevel, @Nullable ChunkHolder holder, int oldLevel);
 
    public boolean processUpdates(ChunkManager chunkManager) {
-      this.playerChunkTracker.processAllUpdates();
-      this.playerTicketTracker.processAllUpdates();
-      int i = Integer.MAX_VALUE - this.ticketTracker.func_215493_a(Integer.MAX_VALUE);
-      boolean flag = i != 0;
-      if (flag) {
-      }
-
-      if (!this.chunkHolders.isEmpty()) {
-         this.chunkHolders.forEach((p_219343_1_) -> {
-            p_219343_1_.processUpdates(chunkManager);
-         });
-         this.chunkHolders.clear();
-         return true;
-      } else {
-         if (!this.chunkPositions.isEmpty()) {
-            LongIterator longiterator = this.chunkPositions.iterator();
+      // Velox start: TicketManager#processUpdates threadsafe
+      this.lock.writeLock().lock();
+      try {
+         this.playerChunkTracker.processAllUpdates();
+         this.playerTicketTracker.processAllUpdates();
+         int i = Integer.MAX_VALUE - this.ticketTracker.func_215493_a(Integer.MAX_VALUE);
+         boolean flag = i != 0;
+         if (flag) {
+         }
 
-            while(longiterator.hasNext()) {
-               long j = longiterator.nextLong();
-               if (this.getTicketSet(j).stream().anyMatch((p_219369_0_) -> {
-                  return p_219369_0_.getType() == TicketType.PLAYER;
-               })) {
-                  ChunkHolder chunkholder = chunkManager.func_219220_a(j);
-                  if (chunkholder == null) {
-                     throw new IllegalStateException();
-                  }
+         if (!this.chunkHolders.isEmpty()) {
+            this.chunkHolders.forEach((p_219343_1_) -> {
+               p_219343_1_.processUpdates(chunkManager);
+            });
+            this.chunkHolders.clear();
+            return true;
+         } else {
+            if (!this.chunkPositions.isEmpty()) {
+               LongIterator longiterator = this.chunkPositions.iterator();
+
+               while (longiterator.hasNext()) {
+                  long j = longiterator.nextLong();
+                  if (this.getTicketSet(j).stream().anyMatch((p_219369_0_) -> {
+                     return p_219369_0_.getType() == TicketType.PLAYER;
+                  })) {
+                     ChunkHolder chunkholder = chunkManager.func_219220_a(j);
+                     if (chunkholder == null) {
+                        throw new IllegalStateException();
+                     }
 
-                  CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> completablefuture = chunkholder.getEntityTickingFuture();
-                  completablefuture.thenAccept((p_219363_3_) -> {
-                     this.field_219388_p.execute(() -> {
-                        this.field_219386_n.enqueue(ChunkTaskPriorityQueueSorter.func_219073_a(() -> {
-                        }, j, false));
+                     CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> completablefuture = chunkholder.getEntityTickingFuture();
+                     completablefuture.thenAccept((p_219363_3_) -> {
+                        this.field_219388_p.execute(() -> {
+                           this.field_219386_n.enqueue(ChunkTaskPriorityQueueSorter.func_219073_a(() -> {
+                           }, j, false));
+                        });
                      });
-                  });
+                  }
                }
+
+               this.chunkPositions.clear();
             }
 
-            this.chunkPositions.clear();
+            return flag;
          }
-
-         return flag;
+      } finally {
+         this.lock.writeLock().unlock();
       }
+      // Velox end
    }
 
    private void register(long chunkPosIn, Ticket<?> ticketIn) {
-      SortedArraySet<Ticket<?>> sortedarrayset = this.getTicketSet(chunkPosIn);
-      int i = getLevel(sortedarrayset);
-      Ticket<?> ticket = sortedarrayset.func_226175_a_(ticketIn);
-      ticket.setTimestamp(this.currentTime);
-      if (ticketIn.getLevel() < i) {
-         this.ticketTracker.updateSourceLevel(chunkPosIn, ticketIn.getLevel(), true);
+      // Velox start: TicketManager#register threadsafe
+      this.lock.writeLock().lock();
+      try {
+         SortedArraySet<Ticket<?>> sortedarrayset = this.getTicketSet(chunkPosIn);
+         int i = getLevel(sortedarrayset);
+         Ticket<?> ticket = sortedarrayset.func_226175_a_(ticketIn);
+         ticket.setTimestamp(this.currentTime);
+         if (ticketIn.getLevel() < i) {
+            this.ticketTracker.updateSourceLevel(chunkPosIn, ticketIn.getLevel(), true);
+         }
+      } finally {
+         this.lock.writeLock().unlock();
       }
-
+      // Velox end
    }
 
    private void release(long chunkPosIn, Ticket<?> ticketIn) {
-      SortedArraySet<Ticket<?>> sortedarrayset = this.getTicketSet(chunkPosIn);
-      if (sortedarrayset.remove(ticketIn)) {
-      }
+      // Velox start: TicketManager#release threadsafe
+      this.lock.writeLock().lock();
+      try {
+         SortedArraySet<Ticket<?>> sortedarrayset = this.getTicketSet(chunkPosIn);
+         if (sortedarrayset.remove(ticketIn)) {
+         }
 
-      if (sortedarrayset.isEmpty()) {
-         this.tickets.remove(chunkPosIn);
-      }
+         if (sortedarrayset.isEmpty()) {
+            this.tickets.remove(chunkPosIn);
+         }
 
-      this.ticketTracker.updateSourceLevel(chunkPosIn, getLevel(sortedarrayset), false);
+         this.ticketTracker.updateSourceLevel(chunkPosIn, getLevel(sortedarrayset), false);
+      } finally {
+         this.lock.writeLock().unlock();
+      }
+      // Velox end
    }
 
    public <T> void registerWithLevel(TicketType<T> type, ChunkPos pos, int level, T value) {
@@ -176,9 +208,17 @@ public abstract class TicketManager {
    }
 
    private SortedArraySet<Ticket<?>> getTicketSet(long p_229848_1_) {
-      return this.tickets.computeIfAbsent(p_229848_1_, (p_229851_0_) -> {
-         return SortedArraySet.newSet(4);
-      });
+      // Velox start: TicketManager#getTicketSet threadsafe
+      this.lock.writeLock().lock();
+      try {
+         // Make sure the return value of this does not leave a writeLocked scope
+         return this.tickets.computeIfAbsent(p_229848_1_, (p_229851_0_) -> {
+            return SortedArraySet.newSet(4);
+         });
+      } finally {
+         this.lock.writeLock().unlock();
+      }
+      // Velox end
    }
 
    protected void forceChunk(ChunkPos pos, boolean add) {
@@ -192,36 +232,55 @@ public abstract class TicketManager {
    }
 
    public void updatePlayerPosition(SectionPos sectionPosIn, ServerPlayerEntity player) {
-      long i = sectionPosIn.asChunkPos().asLong();
-      this.playersByChunkPos.computeIfAbsent(i, (p_219361_0_) -> {
-         return new ObjectOpenHashSet();
-      }).add(player);
-      this.playerChunkTracker.updateSourceLevel(i, 0, true);
-      this.playerTicketTracker.updateSourceLevel(i, 0, true);
+      // Velox start: TicketManager#updatePlayerPosition threadsafe
+      this.lock.writeLock().lock();
+      try {
+         long i = sectionPosIn.asChunkPos().asLong();
+         this.playersByChunkPos.computeIfAbsent(i, (p_219361_0_) -> {
+            return new ObjectOpenHashSet();
+         }).add(player);
+         this.playerChunkTracker.updateSourceLevel(i, 0, true);
+         this.playerTicketTracker.updateSourceLevel(i, 0, true);
+      } finally {
+         this.lock.writeLock().unlock();
+      }
+      // Velox end
    }
 
    public void removePlayer(SectionPos sectionPosIn, ServerPlayerEntity player) {
-      long i = sectionPosIn.asChunkPos().asLong();
-      ObjectSet<ServerPlayerEntity> objectset = this.playersByChunkPos.get(i);
-      objectset.remove(player);
-      if (objectset.isEmpty()) {
-         this.playersByChunkPos.remove(i);
-         this.playerChunkTracker.updateSourceLevel(i, Integer.MAX_VALUE, false);
-         this.playerTicketTracker.updateSourceLevel(i, Integer.MAX_VALUE, false);
+      // Velox start: TicketManager#removePlayer threadsafe
+      this.lock.writeLock().lock();
+      try {
+         long i = sectionPosIn.asChunkPos().asLong();
+         ObjectSet<ServerPlayerEntity> objectset = this.playersByChunkPos.get(i);
+         objectset.remove(player);
+         if (objectset.isEmpty()) {
+            this.playersByChunkPos.remove(i);
+            this.playerChunkTracker.updateSourceLevel(i, Integer.MAX_VALUE, false);
+            this.playerTicketTracker.updateSourceLevel(i, Integer.MAX_VALUE, false);
+         }
+      } finally {
+         this.lock.writeLock().unlock();
       }
-
+      // Velox end
    }
 
    protected String func_225413_c(long p_225413_1_) {
-      SortedArraySet<Ticket<?>> sortedarrayset = this.tickets.get(p_225413_1_);
-      String s;
-      if (sortedarrayset != null && !sortedarrayset.isEmpty()) {
-         s = sortedarrayset.getSmallest().toString();
-      } else {
-         s = "no_ticket";
+      // Velox start: TicketManager#func_225413_c threadsafe
+      this.lock.readLock().lock();
+      try {
+         SortedArraySet<Ticket<?>> sortedarrayset = this.tickets.get(p_225413_1_);
+         String s;
+         if (sortedarrayset != null && !sortedarrayset.isEmpty()) {
+            s = sortedarrayset.getSmallest().toString();
+         } else {
+            s = "no_ticket";
+         }
+         return s;
+      } finally {
+         this.lock.readLock().unlock();
       }
-
-      return s;
+      // Velox end
    }
 
    protected void setViewDistance(int viewDistance) {
@@ -317,8 +376,11 @@ public abstract class TicketManager {
       }
 
       private boolean hasPlayerInChunk(long chunkPosIn) {
+         lock.readLock().lock();
          ObjectSet<ServerPlayerEntity> objectset = TicketManager.this.playersByChunkPos.get(chunkPosIn);
-         return objectset != null && !objectset.isEmpty();
+         boolean hasPlayerInChunk = objectset != null && !objectset.isEmpty();
+         lock.readLock().unlock();
+         return hasPlayerInChunk;
       }
 
       public void processAllUpdates() {
