diff --git a/src/main/java/me/mikex86/velox/chunk/ChunkLoadStatePrinter.java b/src/main/java/me/mikex86/velox/chunk/ChunkLoadStatePrinter.java
new file mode 100644
index 0000000..0988453
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/ChunkLoadStatePrinter.java
@@ -0,0 +1,62 @@
+package me.mikex86.velox.chunk;
+
+import me.mikex86.velox.tick.TickRegionManager;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.*;
+
+import javax.imageio.ImageIO;
+import java.awt.*;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * A debug utility to print chunk load states onto an image saved in the folder "chunks_states".
+ */
+public class ChunkLoadStatePrinter {
+
+    public static void printChunkLoadState(TickRegionManager manager, Chunk currentlyUnloading) {
+        int xStart = -2000, zStart = -2000;
+        int xEnd = 2000, zEnd = 2000;
+        BufferedImage image = new BufferedImage(xEnd - xStart, zEnd - zStart, BufferedImage.TYPE_4BYTE_ABGR);
+        for (int x = xStart; x < xEnd; x++) {
+            for (int z = zStart; z < zEnd; z++) {
+
+                int rgb;
+                ChunkPos pos = currentlyUnloading.getPos();
+                if (pos.x == x && pos.z == z) {
+                    rgb = Color.MAGENTA.getRGB();
+                } else {
+                    Chunk chunk = manager.getChunk(x, z);
+                    if (chunk == null) {
+                        rgb = Color.BLACK.getRGB();
+                    } else {
+                        boolean loaded = chunk.loaded;
+                        if (loaded)
+                            rgb = Color.GREEN.getRGB();
+                        else
+                            rgb = Color.RED.getRGB();
+                    }
+                }
+                image.setRGB(x - xStart, z - zStart, rgb);
+            }
+        }
+        try {
+            ImageIO.write(image, "PNG", getNextFile());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static File getNextFile() {
+        File file;
+        int counter = 0;
+        do {
+            file = new File("chunk_states/state_" + counter + ".png");
+            file.getParentFile().mkdirs();
+            counter++;
+        } while (file.exists());
+        return file;
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/chunk/ConcurrentChunkProvider.java b/src/main/java/me/mikex86/velox/chunk/ConcurrentChunkProvider.java
new file mode 100644
index 0000000..f4f0ae1
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/ConcurrentChunkProvider.java
@@ -0,0 +1,54 @@
+package me.mikex86.velox.chunk;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+
+import com.google.common.cache.CacheBuilder;
+import me.mikex86.velox.chunk.cache.IChunkCache;
+import me.mikex86.velox.chunk.cache.TwoTierChunkCache;
+import me.mikex86.velox.utils.ArrayUtils;
+import me.mikex86.velox.utils.PeriodicInvoker;
+import me.mikex86.velox.utils.cache.LossyLongChunkCache;
+import me.mikex86.velox.utils.cache.guava.AccessCountingCache;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.server.ServerChunkProvider;
+import net.minecraft.world.server.ServerWorld;
+
+import com.mojang.datafixers.DataFixer;
+
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.IChunk;
+import net.minecraft.world.chunk.listener.IChunkStatusListener;
+import net.minecraft.world.gen.ChunkGenerator;
+import net.minecraft.world.gen.feature.template.TemplateManager;
+import net.minecraft.world.storage.DimensionSavedDataManager;
+
+import net.minecraft.world.storage.SaveFormat.LevelSave;
+
+public class ConcurrentChunkProvider extends ServerChunkProvider {
+
+    private final IChunkCache chunkCache = new TwoTierChunkCache();
+
+    public ConcurrentChunkProvider(ServerWorld worldIn, LevelSave worldDirectory, DataFixer dataFixer,
+                                   TemplateManager templateManagerIn, Executor executorIn, ChunkGenerator chunkGeneratorIn, int viewDistance,
+                                   boolean spawnHostiles, IChunkStatusListener p_i51537_8_, Supplier<DimensionSavedDataManager> p_i51537_9_) {
+        super(worldIn, worldDirectory, dataFixer, templateManagerIn, executorIn, chunkGeneratorIn, viewDistance, spawnHostiles, p_i51537_8_, p_i51537_9_);
+    }
+
+    @Override
+    protected void clearCache() {
+        // Invoked after every tick. Do nothing here...
+    }
+
+    @Override
+    protected IChunk lookupChunkCache(long packedChunkPos, ChunkStatus requiredStatus, boolean load) {
+        return this.chunkCache.lookupChunkCache(packedChunkPos, requiredStatus, load);
+    }
+
+    @Override
+    protected void populateChunkCache(int chunkX, int chunkZ, IChunk chunk, ChunkStatus requiredStatus, boolean load) {
+
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/chunk/cache/IChunkCache.java b/src/main/java/me/mikex86/velox/chunk/cache/IChunkCache.java
new file mode 100644
index 0000000..a3aa48b
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/cache/IChunkCache.java
@@ -0,0 +1,38 @@
+package me.mikex86.velox.chunk.cache;
+
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.IChunk;
+
+public interface IChunkCache {
+
+    IChunk lookupChunkCache(long packedChunkPos, ChunkStatus requiredStatus, boolean load);
+
+    void populateChunkCache(int chunkX, int chunkZ, IChunk chunk, ChunkStatus requiredStatus, boolean load);
+
+    class ChunkCacheEntry {
+
+        private final IChunk chunk;
+        private final ChunkStatus cachedChunkStatus;
+        private final boolean loaded;
+
+        public ChunkCacheEntry(IChunk chunk, ChunkStatus cachedChunkStatus, boolean loaded) {
+            this.chunk = chunk;
+            this.cachedChunkStatus = cachedChunkStatus;
+            this.loaded = loaded;
+        }
+
+        public boolean isLoaded() {
+            return loaded;
+        }
+
+        public IChunk getChunk() {
+            return chunk;
+        }
+
+        public ChunkStatus getCachedChunkStatus() {
+            return cachedChunkStatus;
+        }
+    }
+
+
+}
diff --git a/src/main/java/me/mikex86/velox/chunk/cache/TwoTierChunkCache.java b/src/main/java/me/mikex86/velox/chunk/cache/TwoTierChunkCache.java
new file mode 100644
index 0000000..a482916
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/chunk/cache/TwoTierChunkCache.java
@@ -0,0 +1,98 @@
+package me.mikex86.velox.chunk.cache;
+
+import com.google.common.cache.CacheBuilder;
+import me.mikex86.velox.utils.ArrayUtils;
+import me.mikex86.velox.utils.PeriodicInvoker;
+import me.mikex86.velox.utils.cache.LossyLongChunkCache;
+import me.mikex86.velox.utils.cache.guava.AccessCountingCache;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.IChunk;
+
+import java.util.concurrent.TimeUnit;
+
+public class TwoTierChunkCache implements IChunkCache {
+
+    // TODO: MAKE CACHES CONFIGURABLE
+
+    /**
+     * A fast, lossy, l1 cache.
+     * Index collisions are fairly likely to occur, in which case we just miss.
+     * Point is, this cache misses all the time.
+     * Hash collisions are also not handled.
+     * Good that the packed chunk pos long format does not produce these collisions.
+     */
+    private final LossyLongChunkCache l1Cache = new LossyLongChunkCache(256);
+
+    /**
+     * A bigger, slower (~ 10 times slower than L1), more sophisticated cache.
+     * (Still better than fallback, ~10 times slower than L2)
+     */
+    private final AccessCountingCache<Long, IChunkCache.ChunkCacheEntry> l2Cache = AccessCountingCache.wrap(CacheBuilder.newBuilder()
+            .maximumSize(2048)
+            .expireAfterAccess(3, TimeUnit.MINUTES)
+            .build());
+
+    public TwoTierChunkCache() {
+        Thread cacheCleaner = new Thread(new PeriodicInvoker(this.l2Cache::cleanUp, 1000, TimeUnit.MILLISECONDS), "ChunkCacheCleaner");
+        cacheCleaner.setDaemon(true);
+        cacheCleaner.start();
+    }
+
+    @Override
+    public IChunk lookupChunkCache(long packedChunkPos, ChunkStatus requiredStatus, boolean load) {
+        IChunkCache.ChunkCacheEntry cacheEntry;
+        // Query L1 cache
+        {
+            cacheEntry = this.l1Cache.get(packedChunkPos);
+        }
+
+        if (cacheEntry == null) {
+            cacheEntry = this.l2Cache.getIfPresent(packedChunkPos);
+        }
+
+        if (cacheEntry == null) {
+            return null; // All caches have missed
+        }
+
+        IChunk chunk = cacheEntry.getChunk();
+        ChunkStatus entryStatus = cacheEntry.getCachedChunkStatus();
+        boolean entryLoaded = cacheEntry.isLoaded();
+
+        if (entryStatus != requiredStatus || entryLoaded != load) {
+            this.cacheEvict(packedChunkPos, chunk); // Cache evict chunk for position when requiredStatus or load state is mismatched
+            return null;
+        }
+
+        return chunk;
+    }
+
+
+    private void cacheEvict(long key, IChunk chunk) {
+        this.l1Cache.invalidate(key, chunk);
+        this.l2Cache.invalidate(key);
+    }
+
+    private int populateCacheCalls = 0;
+
+    @Override
+    public void populateChunkCache(int chunkX, int chunkZ, IChunk chunk, ChunkStatus requiredChunkStatus, boolean load) {
+        long key = ChunkPos.asLong(chunkX, chunkZ);
+
+        // Populate L2 cache
+        this.l2Cache.put(key, new ChunkCacheEntry(chunk, requiredChunkStatus, load));
+
+        // Populate L1 cache with the most popular values of L2
+        // every 16 cache population calls
+        // Fuck thread-safety for this counter...
+        // "Oh no it was 17 times instead of 16 the world will burn"
+        if (this.populateCacheCalls++ % 16 == 0) {
+            int capacity = this.l1Cache.getCapacity();
+            Long[] keysBoxed = new Long[capacity];
+            IChunkCache.ChunkCacheEntry[] values = new IChunkCache.ChunkCacheEntry[capacity];
+            this.l2Cache.retrieveMostAccessedValues(keysBoxed, values);
+            long[] keys = ArrayUtils.unbox(keysBoxed);
+            this.l1Cache.populate(keys, values);
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/MadMaxTickManager.java b/src/main/java/me/mikex86/velox/tick/MadMaxTickManager.java
new file mode 100644
index 0000000..7653d36
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/MadMaxTickManager.java
@@ -0,0 +1,45 @@
+package me.mikex86.velox.tick;
+
+import me.mikex86.velox.utils.CollectionUtils;
+import me.mikex86.velox.utils.Streamer;
+import net.minecraft.entity.Entity;
+
+import java.util.Collection;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+import java.util.function.Consumer;
+
+/**
+ * A tick model that provokes thread safety errors by just streaming all entities in optimal batch sizes on all cores.
+ * This is horrendously unsafe
+ */
+public class MadMaxTickManager {
+
+    /**
+     * Whether mad max mode is enabled
+     * Debug/Development feature only.
+     */
+    public static boolean MAD_MAX_MODE = false;
+
+    private static final int nThreads = Runtime.getRuntime().availableProcessors();
+    private static final ExecutorService service = MAD_MAX_MODE ? Executors.newFixedThreadPool(nThreads, new ThreadFactory() {
+        private int nThreads = 0;
+        @Override
+        public Thread newThread(Runnable runnable) {
+            Thread thread = new Thread(runnable, "MadMaxTickWorker-" + nThreads++);
+            thread.setDaemon(true);
+            return thread;
+        }
+    }) : null;
+
+    public static void tickMadMax(Collection<Entity> entities, Consumer<Entity> action) {
+        entities = CollectionUtils.immutableCopy(entities);
+        try {
+            Streamer.streamBatched(service, nThreads, entities, action);
+        } catch (InterruptedException | ExecutionException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/TickRegion.java b/src/main/java/me/mikex86/velox/tick/TickRegion.java
new file mode 100644
index 0000000..a900813
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/TickRegion.java
@@ -0,0 +1,154 @@
+package me.mikex86.velox.tick;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+
+import java.util.*;
+import java.util.function.Consumer;
+
+public class TickRegion {
+
+    private final Map<ChunkPos, Chunk> chunkMap = Maps.newHashMap();
+    private final List<Entity> entityTickList = Lists.newArrayList();
+
+    public boolean addChunk(Chunk chunk) {
+        return this.chunkMap.put(chunk.getPos(), chunk) == null;
+    }
+
+    public boolean removeChunk(Chunk chunk) {
+        return this.chunkMap.remove(chunk.getPos()) != null;
+    }
+
+    public void clearEntityTickList() {
+        this.entityTickList.clear();
+    }
+
+    public void addToEntityTickList(Entity entity) {
+        this.entityTickList.add(entity);
+    }
+
+    public void applyTaskToEntityTickList(Consumer<Entity> entityTask) {
+        for (Entity entity : this.entityTickList) {
+            entityTask.accept(entity);
+        }
+    }
+
+    public boolean containsOrBorders(Chunk chunk) {
+        ChunkPos chunkPos = chunk.getPos();
+        for (Chunk regionChunk : this.chunkMap.values()) {
+            ChunkPos regionChunkPos = regionChunk.getPos();
+            int xDif = Math.abs(regionChunkPos.x - chunkPos.x);
+            int zDif = Math.abs(regionChunkPos.z - chunkPos.z);
+
+            // the distance can either be 0 or 1 on both xDif and zDif for "chunk" to either
+            // be at the same position as "regionChunkPos" or border it.
+            if (Math.max(xDif, zDif) <= 1) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isEmpty() {
+        return this.chunkMap.isEmpty();
+    }
+
+    public void merge(TickRegion srcRegion) {
+        this.chunkMap.putAll(srcRegion.chunkMap);
+    }
+
+    @Override
+    public String toString() {
+        return "Region{" +
+                "numChunks=" + this.chunkMap.size() +
+                '}';
+    }
+
+    public Collection<Chunk> getChunks() {
+        return chunkMap.values();
+    }
+
+    List<Chunk> floodFillFromChunkUntilChunk(Chunk startChunk, Chunk endChunk) {
+        List<Chunk> floodFilledChunks = Lists.newArrayList();
+        Set<Chunk> visited = Sets.newHashSet();
+
+        Queue<Chunk> chunkFloodQueue = Lists.newLinkedList();
+        chunkFloodQueue.add(startChunk);
+
+        while (!chunkFloodQueue.isEmpty()) {
+            Chunk chunk = chunkFloodQueue.remove();
+            if (floodFilledChunks.contains(chunk))
+                System.err.println("Wuiuiui");
+            else
+                floodFilledChunks.add(chunk);
+
+            visited.add(chunk);
+            if (chunk == endChunk) {
+                break;
+            }
+            getNeighbors(false, chunkFloodQueue, visited, chunk);
+        }
+
+        return floodFilledChunks;
+    }
+
+//    List<Chunk> floodFillFromChunk(Chunk firstChunk) {
+//        List<Chunk> floodFilledChunks = Lists.newLinkedList();
+//
+//        Set<Chunk> chunkFloodSet = Sets.newHashSet();
+//        chunkFloodSet.add(firstChunk);
+//
+//        while (!chunkFloodSet.isEmpty()) {
+//            Chunk chunk = chunkFloodSet.iterator().next();
+//            floodFilledChunks.add(chunk);
+//            getNeighbors(chunkFloodSet, chunk);
+//        }
+//
+//        return floodFilledChunks;
+//    }
+
+    void getNeighbors(boolean addNulls, Collection<Chunk> dst, Collection<Chunk> visited, Chunk chunk) {
+        ChunkPos pos = chunk.getPos();
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x - 1, pos.z);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x + 1, pos.z);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x, pos.z - 1);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+        {
+            ChunkPos neighborPos = new ChunkPos(pos.x, pos.z + 1);
+            Chunk neighbor = this.chunkMap.get(neighborPos);
+            if (neighbor != null || addNulls) {
+                if (!visited.contains(neighbor) && !dst.contains(neighbor))
+                    dst.add(neighbor);
+            }
+        }
+    }
+
+    public Chunk getChunk(int blockX, int blockZ) {
+        ChunkPos chunkPos = new ChunkPos(blockX >> 4, blockZ >> 4);
+        return this.chunkMap.get(chunkPos);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/tick/TickRegionManager.java b/src/main/java/me/mikex86/velox/tick/TickRegionManager.java
new file mode 100644
index 0000000..a2b06d9
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/tick/TickRegionManager.java
@@ -0,0 +1,288 @@
+package me.mikex86.velox.tick;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.server.ChunkManager;
+import net.minecraft.world.server.ServerChunkProvider;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+/**
+ * Creates and destroys regions when chunks are loaded/unloaded.
+ * <p>
+ * Delegates tick list building and the scheduling of tasks on those tick lists to the individual regions.
+ */
+public class TickRegionManager {
+
+    private static final int nThreads = Runtime.getRuntime().availableProcessors();
+
+    // TODO: This is only static because multiple TickRegionManager instances can exist that should not have a service on their own claiming every core
+    // TODO: Config options
+    private static final ExecutorService service = new ThreadPoolExecutor(nThreads, nThreads,
+            0L, TimeUnit.MILLISECONDS,
+            new LinkedBlockingQueue<>(),
+            new ThreadFactory() {
+
+                private int nThreads = 0;
+
+                @Override
+                public Thread newThread(Runnable runnable) {
+                    Thread thread = new Thread(runnable, "TickWorker-" + nThreads);
+                    thread.setDaemon(true);
+                    nThreads++;
+                    return thread;
+                }
+            });
+
+    /**
+     * List containing all existing regions
+     */
+    private final List<TickRegion> regionList = Lists.newArrayList();
+
+    /**
+     * Maps the position of chunks to the TickRegion they are part of
+     */
+    private final Map<ChunkPos, TickRegion> tickRegionMap = Maps.newHashMap();
+
+    /**
+     * A lock to ensure thread safe access to the TickRegionManager state
+     */
+    private final ReadWriteLock lock = new ReentrantReadWriteLock();
+
+    /**
+     * Invoked when a chunk is either loaded or unloaded.
+     * The method will rebuild regions accordingly.
+     *
+     * @param chunk        the chunk that is getting loaded/unloaded
+     * @param newLoadState the new load state of the chunk. true, if the chunk is getting loaded, false if the chunk is getting unloaded.
+     */
+    public void informChunkLoadStateChange(Chunk chunk, boolean newLoadState) {
+        long start = System.currentTimeMillis();
+        this.lock.writeLock().lock();
+        try {
+            TickRegion chunkDstRegion = this.findRegion(chunk);
+            if (chunkDstRegion == null) {
+                chunkDstRegion = createRegion();
+            }
+            if (newLoadState) {
+                boolean modified = addChunkToRegion(chunkDstRegion, chunk);
+                if (!modified) {
+                    throw new IllegalStateException("Chunk was already contained in it's region before it was even loaded. This should never happen");
+                }
+                // Merge bordering regions:
+                // Checks if "chunk" borders any region that is not its current region.
+                // Removes the other region after adding its
+                // chunks to the region of "chunk"
+                for (Iterator<TickRegion> iterator = this.regionList.iterator(); iterator.hasNext(); ) {
+                    TickRegion region = iterator.next();
+                    if (region == chunkDstRegion) continue;
+                    if (region.containsOrBorders(chunk)) {
+                        mergeRegion(chunkDstRegion, region);
+                        iterator.remove();
+                    }
+                }
+            } else {
+                boolean modified = chunkDstRegion.removeChunk(chunk);
+                if (!modified) {
+                    throw new IllegalStateException("Chunk was already contained in it's region before it was even loaded. This should never happen");
+                }
+                if (chunkDstRegion.isEmpty()) {
+                    removeRegion(chunkDstRegion);
+                } else {
+                    checkRegionSplit(chunkDstRegion, chunk);
+                }
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+        long end = System.currentTimeMillis();
+//        System.out.println("informChunkLoadStateChange(" + newLoadState + ") took: " + (end - start) + " ms; " + this);
+    }
+
+    // not thread safe
+    private void checkRegionSplit(TickRegion region, Chunk unloadedChunk) {
+        ChunkManager chunkManager = ((ServerChunkProvider) unloadedChunk.getLevel().getChunkSource()).chunkMap;
+        // Split the region if it is not continuous.
+        // Check for non continuity by checking if you can travel between
+        // the neighboring chunks of the chunk that has just been unloaded.
+        // We will create max. 4 regions in the worst case.
+
+        Collection<Chunk> allChunks = region.getChunks();
+
+        List<Chunk> neighbors = Lists.newArrayListWithCapacity(4);
+        region.getNeighbors(true, neighbors, Lists.newArrayList(), unloadedChunk);
+
+        assert neighbors.size() == 4;
+
+        for (int i = 0; i < neighbors.size() - 1; i++) {
+            Chunk neighbor1 = neighbors.get(i);
+            Chunk neighbor2 = neighbors.get(i + 1);
+            if (neighbor1 == null || neighbor2 == null)
+                continue;
+            List<Chunk> chunks = region.floodFillFromChunkUntilChunk(neighbor1, neighbor2);
+            Chunk lastChunk = chunks.get(chunks.size() - 1);
+            if (lastChunk != neighbor2) {
+                // we have not reached the neighboring chunk, the neighbors are in different regions
+                // if that is the case, "chunks" contains all chunks part of that region, because the flood fill didn't early stop.
+                if (!chunks.equals(allChunks)) {
+
+                    // Create new region with just the "chunks" list.
+                    // "chunks" may contain chunks that are pending unload.
+                    // In the worst case scenario, they are all pending unload, eg. on teleport.
+                    // In that case chunks will unload in basically random order resulting in catastrophically
+                    // high region complexity for the short time until those regions are deleted.
+                    // In that case, we don't want to even create a region, thus the initial null value of "newRegion".
+
+                    TickRegion newRegion = null;
+                    for (Chunk chunk : chunks) {
+                        if (chunkManager.pendingUnloads.containsKey(chunk.getPos().toLong())) {
+                            // Don't add this chunk to the new region, it is pending unload.
+                            // We are not yet removing it from the old region: When the chunk
+                            // is actually unloaded, #informChunkLoadStateChange will be invoked anyways.
+                            // Ticks might still be performed in those chunks. If we were to remove these from the region now,
+                            // these ticks could simply not be performed.
+                            continue;
+                        }
+                        // Create the region only then, when we know that at least one
+                        // chunk actually gets added to it.
+                        if (newRegion == null) {
+                            newRegion = createRegion();
+                        }
+                        newRegion.addChunk(chunk);
+                        region.removeChunk(chunk);
+                        if (region.isEmpty()) {
+                            removeRegion(region);
+                        }
+                        this.tickRegionMap.put(chunk.getPos(), newRegion);
+                    }
+                }
+            }
+        }
+    }
+
+    public void buildEntityTickList(Iterator<Entity> entityIt, Predicate<Entity> tickingPredicate) {
+        this.lock.writeLock().lock();
+        try {
+            for (TickRegion region : this.regionList) {
+                region.clearEntityTickList();
+            }
+            while (entityIt.hasNext()) {
+                Entity entity = entityIt.next();
+                if (!tickingPredicate.test(entity)) {
+                    continue;
+                }
+                BlockPos bp = entity.blockPosition();
+                TickRegion region = this.lookupRegion(bp.getX(), bp.getZ());
+                if (region == null) {
+                    // TODO: use a dummy region for these maybe existent edge cases?
+                    System.err.println("Could not find region for entity: " + entity);
+                } else {
+                    region.addToEntityTickList(entity);
+                }
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+    }
+
+    public void applyEntityTask(Consumer<Entity> entityTask) {
+        this.lock.readLock().lock();
+        try {
+            CountDownLatch latch = new CountDownLatch(this.regionList.size());
+            for (TickRegion region : this.regionList) {
+                service.submit(() -> {
+                    try {
+                        region.applyTaskToEntityTickList(entityTask);
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    } finally {
+                        latch.countDown();
+                    }
+                });
+            }
+            latch.await();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        } finally {
+            this.lock.readLock().unlock();
+        }
+    }
+
+
+    // not thread safe
+    private TickRegion lookupRegion(int blockX, int blockZ) {
+        ChunkPos chunkPos = new ChunkPos(blockX >> 4, blockZ >> 4);
+        return this.tickRegionMap.get(chunkPos);
+    }
+
+    // not thread safe
+    private boolean addChunkToRegion(TickRegion region, Chunk chunk) {
+        this.tickRegionMap.put(chunk.getPos(), region);
+        return region.addChunk(chunk);
+    }
+
+    /**
+     * Merges the two regions.
+     *
+     * @param dstRegion the region to merge into
+     * @param srcRegion the region whose chunks should be merged into the other region
+     */
+    // not thread safe
+    private void mergeRegion(TickRegion dstRegion, TickRegion srcRegion) {
+        dstRegion.merge(srcRegion);
+        Collection<Chunk> chunks = srcRegion.getChunks();
+        for (Chunk chunk : chunks) {
+            this.tickRegionMap.put(chunk.getPos(), dstRegion);
+        }
+    }
+
+    // not thread safe
+    private void removeRegion(TickRegion region) {
+        Collection<Chunk> chunks = region.getChunks();
+        for (Chunk chunk : chunks) {
+            this.tickRegionMap.remove(chunk.getPos());
+        }
+        this.regionList.remove(region);
+    }
+
+    // not thread safe
+    private TickRegion createRegion() {
+        TickRegion region = new TickRegion();
+        this.regionList.add(region);
+        return region;
+    }
+
+    // not thread safe
+    private TickRegion findRegion(Chunk chunk) {
+        for (TickRegion region : this.regionList) {
+            if (region.containsOrBorders(chunk)) {
+                return region;
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public String toString() {
+        return "RegionManager{" +
+                "numRegions=" + this.regionList.size() + ", " +
+                "regionList=" + this.regionList +
+                '}';
+    }
+
+    public Chunk getChunk(int x, int z) {
+        TickRegion region = this.lookupRegion(x, z);
+        if (region == null)
+            return null;
+        return region.getChunk(x, z);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/ArrayUtils.java b/src/main/java/me/mikex86/velox/utils/ArrayUtils.java
new file mode 100644
index 0000000..e6fdbb6
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/ArrayUtils.java
@@ -0,0 +1,23 @@
+package me.mikex86.velox.utils;
+
+public class ArrayUtils {
+
+    public static int[] unbox(Integer[] boxed) {
+        int[] unboxed = new int[boxed.length];
+        for (int i = 0; i < boxed.length; i++) {
+            Integer integer = boxed[i];
+            unboxed[i] = integer == null ? 0 : integer;
+        }
+        return unboxed;
+    }
+
+    public static long[] unbox(Long[] boxed) {
+        long[] unboxed = new long[boxed.length];
+        for (int i = 0; i < boxed.length; i++) {
+            Long aLong = boxed[i];
+            unboxed[i] = aLong == null ? 0 : aLong;
+        }
+        return unboxed;
+    }
+
+}
diff --git a/src/main/java/me/mikex86/velox/utils/CollectionUtils.java b/src/main/java/me/mikex86/velox/utils/CollectionUtils.java
new file mode 100644
index 0000000..9eaca5e
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/CollectionUtils.java
@@ -0,0 +1,34 @@
+package me.mikex86.velox.utils;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import net.minecraft.world.server.ChunkManager;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+public class CollectionUtils {
+
+    public static <T> List<T> collectToList(Iterator<T> iterator) {
+        List<T> values = Lists.newArrayList();
+        while (iterator.hasNext()) {
+            values.add(iterator.next());
+        }
+        return values;
+    }
+
+    public static<T> Iterable<T> prefetchIterable(Iterable<T> iterable) {
+        return collectToList(iterable.iterator());
+    }
+
+    public static<T> Iterator<T> prefetchIterator(Iterator<T> iterable) {
+        return collectToList(iterable).iterator();
+    }
+
+    public static <T> Collection<T> immutableCopy(Collection<T> collection) {
+        return ImmutableList.copyOf(collection);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/MathUtils.java b/src/main/java/me/mikex86/velox/utils/MathUtils.java
new file mode 100644
index 0000000..c457e20
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/MathUtils.java
@@ -0,0 +1,28 @@
+package me.mikex86.velox.utils;
+
+import static java.lang.Math.floorDiv;
+
+public class MathUtils {
+
+    /**
+     * Uses crazy standford magic to round up to the next power of two.
+     * For zero, it will return back zero again. This is a small anomaly of the function
+     * for performance reasons.
+     * @param n a given number
+     * @return the next power of two after (or equal to) n
+     */
+    public static int npot(int n) {
+        n--;
+        n |= n >> 1;
+        n |= n >> 2;
+        n |= n >> 4;
+        n |= n >> 8;
+        n |= n >> 16;
+        n++;
+        return n;
+    }
+
+    public static long floorMod(long x, long y) {
+        return x - floorDiv(x, y) * y;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/PeriodicInvoker.java b/src/main/java/me/mikex86/velox/utils/PeriodicInvoker.java
new file mode 100644
index 0000000..4b2fcc7
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/PeriodicInvoker.java
@@ -0,0 +1,28 @@
+package me.mikex86.velox.utils;
+
+import java.util.concurrent.TimeUnit;
+
+public class PeriodicInvoker implements Runnable {
+
+    private final Runnable runnable;
+    private final long time;
+    private final TimeUnit timeUnit;
+
+    public PeriodicInvoker(Runnable runnable, long time, TimeUnit timeUnit) {
+        this.runnable = runnable;
+        this.time = time;
+        this.timeUnit = timeUnit;
+    }
+
+    @Override
+    public void run() {
+        try {
+            while (true) {
+                this.runnable.run();
+                Thread.sleep(this.timeUnit.toMillis(this.time));
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/StreamUtils.java b/src/main/java/me/mikex86/velox/utils/StreamUtils.java
new file mode 100644
index 0000000..411753c
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/StreamUtils.java
@@ -0,0 +1,18 @@
+package me.mikex86.velox.utils;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class StreamUtils {
+
+    public static <T> Stream<T> prefetch(Stream<T> stream) {
+        return stream.collect(Collectors.toList()).stream();
+    }
+
+    public static <T> Stream<T> prefetchSynchronizedCollection(Collection<T> collection) {
+        T[] array = collection.toArray((T[]) new Object[0]);
+        return Arrays.stream(array);
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/Streamer.java b/src/main/java/me/mikex86/velox/utils/Streamer.java
new file mode 100644
index 0000000..73cb54c
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/Streamer.java
@@ -0,0 +1,108 @@
+package me.mikex86.velox.utils;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+public class Streamer {
+
+    /**
+     * Applies a function to stream elements in batches and returns the results. This method does not mutate the stream! (how would it?)
+     *
+     * @param executor  the executor to run the functions async on
+     * @param stream    the stream to retrieve elements from
+     * @param function  the function to apply
+     * @param batchSize the size of a batch that should be processed as one completable future. The result can only be retrieved when all elements of a batch are applied
+     * @param <T>       the type of elements
+     * @param <R>       the output type of the apply function
+     * @return the futures of the batches
+     */
+    public static <T, R> List<CompletableFuture<List<R>>> applyAsync(Executor executor, Stream<T> stream, Function<T, R> function, int batchSize) {
+        List<List<T>> batches = getBatches(stream, batchSize);
+        List<CompletableFuture<List<R>>> futures = new ArrayList<>();
+        for (List<T> batch : batches) {
+            futures.add(CompletableFuture.supplyAsync(() -> {
+                List<R> results = new ArrayList<>();
+                for (T t : batch) {
+                    results.add(function.apply(t));
+                }
+                return results;
+            }, executor));
+        }
+        return futures;
+    }
+
+    /**
+     * Performs {@link #applyAsync(Executor, Stream, Function, int)} and waits for the futures to complete
+     *
+     * @throws ExecutionException   if the execution completed exceptionally
+     * @throws InterruptedException if the execution thread was interrupted
+     * @see #applyAsync(Executor, Stream, Function, int)
+     */
+    public static <T, R> void applyAsyncWait(Executor executor, Stream<T> stream, Function<T, R> function, int batchSize) throws ExecutionException, InterruptedException {
+        List<CompletableFuture<List<R>>> futures = applyAsync(executor, stream, function, batchSize);
+        for (CompletableFuture<List<R>> future : futures) {
+            future.get();
+        }
+    }
+
+    /**
+     * Splits a given stream into batches. The last batch may not be of size #batchSize
+     *
+     * @param stream    the stream to split
+     * @param batchSize number of elements of each batch
+     * @param <T>       the type of element
+     * @return the list of batches
+     */
+    public static <T> List<List<T>> getBatches(Stream<T> stream, int batchSize) {
+        AtomicInteger i = new AtomicInteger(0);
+        List<List<T>> batches = new ArrayList<>();
+        stream.forEachOrdered(e -> {
+            int ig = i.get();
+            int batchIndex = ig / batchSize;
+            if (batchIndex == batches.size()) {
+                batches.add(new ArrayList<>());
+            }
+            batches.get(batchIndex).add(e);
+            i.incrementAndGet();
+        });
+        return batches;
+    }
+
+    public static <T> void streamBatched(Executor executor, int nBatches, Collection<T> values, Consumer<T> consumer) throws InterruptedException, ExecutionException {
+        int batchSize = roundUp(values.size(), nBatches);
+        Iterator<T> iterator = values.iterator();
+        T[] batch = (T[]) new Object[batchSize];
+        int i = 0;
+        CountDownLatch entityLatch = new CountDownLatch(values.size());
+        AtomicBoolean earlyAbort = new AtomicBoolean(false);
+
+        while (iterator.hasNext()) {
+            T next = iterator.next();
+            batch[i] = next;
+            i++;
+            // if batch is fully filled or no next value is available (partial batch), schedule a task processing that batch
+            if (i == batchSize || !iterator.hasNext()) {
+                T[] batchCopy = Arrays.copyOf(batch, i);
+                executor.execute(() -> {
+                    for (T value : batchCopy) {
+                        if (!earlyAbort.get()) {
+                            consumer.accept(value);
+                        }
+                        entityLatch.countDown();
+                    }
+                });
+                i = 0;
+            }
+        }
+        entityLatch.await();
+    }
+
+    private static int roundUp(int num, int divisor) {
+        return (num + divisor - 1) / divisor;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/cache/LossyLongChunkCache.java b/src/main/java/me/mikex86/velox/utils/cache/LossyLongChunkCache.java
new file mode 100644
index 0000000..f189c37
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/cache/LossyLongChunkCache.java
@@ -0,0 +1,131 @@
+package me.mikex86.velox.utils.cache;
+
+import it.unimi.dsi.fastutil.HashCommon;
+import me.mikex86.velox.chunk.cache.IChunkCache;
+import me.mikex86.velox.utils.MathUtils;
+import net.minecraft.world.chunk.IChunk;
+
+import java.util.Arrays;
+
+/**
+ * Implements a chunk cache with a 64-bit key.
+ * Index collisions of hashes are fairly likely.
+ * Hash collisions are also not handled.
+ * Thread-safety is achieved via copy on write
+ */
+public class LossyLongChunkCache {
+
+    private final int capacity;
+
+    /**
+     * Bit mask used to calculate the index from a key.
+     */
+    private final long mask;
+
+    /**
+     * The state of the cache.
+     * This instance is swapped as a whole when the cache is mutated.
+     * This copy on write operation constitutes thread-safety
+     */
+    private CacheState cacheState;
+
+    private final Object mutex = new Object();
+
+    /**
+     * @param capacity the capacity of the cache. Should be a power of two. Next biggest will be used
+     */
+    public LossyLongChunkCache(int capacity) {
+        capacity = MathUtils.npot(capacity);
+        this.capacity = capacity;
+        this.mask = capacity - 1;
+        this.cacheState = new CacheState();
+    }
+
+    public IChunkCache.ChunkCacheEntry get(long key) {
+        int index = this.index(key);
+        CacheState cacheState = this.cacheState;
+        if (cacheState.keys[index] != key) {
+            return null;
+        }
+        IChunkCache.ChunkCacheEntry value = cacheState.values[index];
+        cacheState.lossyAccessCounters[index]++; // Fuck thread safety here...
+        return value;
+    }
+
+    private int index(long key) {
+        return (int) (HashCommon.mix(key) & this.mask);
+    }
+
+    public void clear() {
+        this.cacheState = new CacheState();
+    }
+
+    public int getCapacity() {
+        return capacity;
+    }
+
+    public void populate(long[] keys, IChunkCache.ChunkCacheEntry[] values) {
+        assert keys.length == capacity;
+        assert values.length == capacity;
+        synchronized (this.mutex) {
+            CacheState cacheState = new CacheState();
+            for (int i = 0; i < keys.length; i++) {
+                long key = keys[i];
+                if (key == 0) continue;
+                int index = this.index(key);
+                cacheState.keys[index] = key;
+                cacheState.values[index] = values[i];
+                cacheState.lossyAccessCounters[index] = 0;
+            }
+            this.cacheState = cacheState;
+        }
+    }
+
+    public void invalidate(long key, IChunk chunk) {
+        synchronized (this.mutex) {
+            int index = index(key);
+            CacheState cacheState = this.cacheState;
+            IChunkCache.ChunkCacheEntry entry = cacheState.values[index];
+            if (entry != null && entry.getChunk() == chunk) {
+                cacheState = cacheState.copy();
+                cacheState.keys[index] = 0;
+                cacheState.values[index] = null;
+                cacheState.lossyAccessCounters[index] = 0;
+                this.cacheState = cacheState;
+            }
+        }
+    }
+
+    private class CacheState {
+
+        /**
+         * Roughly keeps track of the number of accesses each chunk of the cache has.
+         * We ignore thread-safety. If the counter is slightly off, so be it.
+         */
+        private final long[] lossyAccessCounters;
+
+        private final long[] keys;
+
+        private final IChunkCache.ChunkCacheEntry[] values;
+
+        public CacheState() {
+            this.lossyAccessCounters = new long[capacity];
+            this.keys = new long[capacity];
+            this.values = new IChunkCache.ChunkCacheEntry[capacity];
+        }
+
+        public CacheState(long[] lossyAccessCounters, long[] keys, IChunkCache.ChunkCacheEntry[] values) {
+            this.lossyAccessCounters = lossyAccessCounters;
+            this.keys = keys;
+            this.values = values;
+        }
+
+        public CacheState copy() {
+            return new CacheState(
+                    Arrays.copyOf(this.lossyAccessCounters, this.lossyAccessCounters.length),
+                    Arrays.copyOf(this.keys, this.keys.length),
+                    Arrays.copyOf(this.values, this.values.length)
+            );
+        }
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/cache/guava/AccessCountingCache.java b/src/main/java/me/mikex86/velox/utils/cache/guava/AccessCountingCache.java
new file mode 100644
index 0000000..06d28a6
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/cache/guava/AccessCountingCache.java
@@ -0,0 +1,94 @@
+package me.mikex86.velox.utils.cache.guava;
+
+import com.google.common.cache.Cache;
+import com.google.common.cache.ForwardingCache;
+
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.Locale;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+public class AccessCountingCache<K, V> extends ForwardingCache<K, V> {
+
+    private final Cache<K, V> delegate;
+    private final Map<Object, AtomicInteger> accessCounts = new WeakHashMap<>();
+    private final ReadWriteLock lock = new ReentrantReadWriteLock();
+
+    public AccessCountingCache(Cache<K, V> delegate) {
+        this.delegate = delegate;
+    }
+
+    public static <K, V> AccessCountingCache<K, V> wrap(Cache<K, V> cache) {
+        return new AccessCountingCache<>(cache);
+    }
+
+    @Override
+    public V get(K key, Callable<? extends V> valueLoader) throws ExecutionException {
+        this.lock.readLock().lock();
+        AtomicInteger integer = this.accessCounts.get(key);
+        this.lock.readLock().unlock();
+        if (integer == null) {
+            integer = new AtomicInteger(0);
+            this.lock.writeLock().lock();
+            this.accessCounts.put(key, integer);
+            this.lock.writeLock().unlock();
+        }
+        integer.incrementAndGet();
+        return super.get(key, valueLoader);
+    }
+
+    @Nullable
+    @Override
+    public V getIfPresent(Object key) {
+        this.lock.readLock().lock();
+        AtomicInteger integer = this.accessCounts.get(key);
+        this.lock.readLock().unlock();
+        if (integer == null) {
+            integer = new AtomicInteger(0);
+            this.lock.writeLock().lock();
+            this.accessCounts.put(key, integer);
+            this.lock.writeLock().unlock();
+        }
+        integer.incrementAndGet();
+        return super.getIfPresent(key);
+    }
+
+    public void retrieveMostAccessedValues(K[] keys, V[] values) {
+        int nValues = keys.length;
+        int[] counters = new int[nValues];
+        for (Map.Entry<K, V> entry : this.delegate.asMap().entrySet()) {
+            K key = entry.getKey();
+            V value = entry.getValue();
+            this.lock.readLock().lock();
+            AtomicInteger atomicCounter = this.accessCounts.get(key);
+            this.lock.readLock().unlock();
+            int counter = atomicCounter == null ? 0 : atomicCounter.get();
+            for (int i = 0; i < nValues; i++) {
+                if (counter >= counters[i]) {
+                    // Move everything back by one
+                    for (int j = nValues - 2; j >= i; j--) {
+                        counters[j + 1] = counters[j];
+                        keys[j + 1] = keys[j];
+                        values[j + 1] = values[j];
+                    }
+                    counters[i] = counter;
+                    keys[i] = key;
+                    values[i] = value;
+                    break;
+                }
+            }
+        }
+    }
+
+    @Override
+    protected Cache<K, V> delegate() {
+        return this.delegate;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/lock/AbstractLock.java b/src/main/java/me/mikex86/velox/utils/lock/AbstractLock.java
new file mode 100644
index 0000000..8931022
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/lock/AbstractLock.java
@@ -0,0 +1,42 @@
+package me.mikex86.velox.utils.lock;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+
+public abstract class AbstractLock implements Lock {
+
+    @Override
+    public abstract void lock();
+
+    @Override
+    public void lockInterruptibly() {
+        lock();
+    }
+
+    @Override
+    public boolean tryLock() {
+        throw new UnsupportedOperationException("tryLock() not implemented");
+    }
+
+
+    @Override
+    public boolean tryLock(long time, TimeUnit unit) {
+        long nanos = unit.toNanos(time);
+        long start = System.nanoTime();
+        while (System.nanoTime() - start < nanos) {
+            if (tryLock()) {
+                return true;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public abstract void unlock();
+
+    @Override
+    public Condition newCondition() {
+        throw new UnsupportedOperationException("newCondition() not implemented");
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/lock/DummyLock.java b/src/main/java/me/mikex86/velox/utils/lock/DummyLock.java
new file mode 100644
index 0000000..1f35585
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/lock/DummyLock.java
@@ -0,0 +1,38 @@
+package me.mikex86.velox.utils.lock;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+
+public class DummyLock implements Lock {
+
+    @Override
+    public void lock() {
+
+    }
+
+    @Override
+    public void lockInterruptibly() throws InterruptedException {
+
+    }
+
+    @Override
+    public boolean tryLock() {
+        return false;
+    }
+
+    @Override
+    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
+        return false;
+    }
+
+    @Override
+    public void unlock() {
+
+    }
+
+    @Override
+    public Condition newCondition() {
+        return null;
+    }
+}
diff --git a/src/main/java/me/mikex86/velox/utils/lock/DummyReadWriteLock.java b/src/main/java/me/mikex86/velox/utils/lock/DummyReadWriteLock.java
new file mode 100644
index 0000000..0f4225a
--- /dev/null
+++ b/src/main/java/me/mikex86/velox/utils/lock/DummyReadWriteLock.java
@@ -0,0 +1,20 @@
+package me.mikex86.velox.utils.lock;
+
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+
+public class DummyReadWriteLock implements ReadWriteLock {
+
+    private final Lock lock = new DummyLock();
+
+    @Override
+    public Lock readLock() {
+        return lock;
+    }
+
+    @Override
+    public Lock writeLock() {
+        return lock;
+    }
+
+}
diff --git a/build/mcp_diff_src/net/minecraft/command/impl/FillCommand.java b/src/main/java/net/minecraft/command/impl/FillCommand.java
index f4b569e..d0b6792 100644
--- a/build/mcp_diff_src/net/minecraft/command/impl/FillCommand.java
+++ b/src/main/java/net/minecraft/command/impl/FillCommand.java
@@ -56,40 +56,37 @@ public class FillCommand {
    }
 
    private static int fillBlocks(CommandSource p_198463_0_, MutableBoundingBox p_198463_1_, BlockStateInput p_198463_2_, FillCommand.Mode p_198463_3_, @Nullable Predicate<CachedBlockInfo> p_198463_4_) throws CommandSyntaxException {
-      int i = p_198463_1_.getXSpan() * p_198463_1_.getYSpan() * p_198463_1_.getZSpan();
-      if (i > 32768) {
-         throw ERROR_AREA_TOO_LARGE.create(32768, i);
-      } else {
-         List<BlockPos> list = Lists.newArrayList();
-         ServerWorld serverworld = p_198463_0_.getLevel();
-         int j = 0;
+      // Velox start: Remove fill block limit
+      List<BlockPos> list = Lists.newArrayList();
+      ServerWorld serverworld = p_198463_0_.getLevel();
+      int j = 0;
 
-         for(BlockPos blockpos : BlockPos.betweenClosed(p_198463_1_.x0, p_198463_1_.y0, p_198463_1_.z0, p_198463_1_.x1, p_198463_1_.y1, p_198463_1_.z1)) {
-            if (p_198463_4_ == null || p_198463_4_.test(new CachedBlockInfo(serverworld, blockpos, true))) {
-               BlockStateInput blockstateinput = p_198463_3_.filter.filter(p_198463_1_, blockpos, p_198463_2_, serverworld);
-               if (blockstateinput != null) {
-                  TileEntity tileentity = serverworld.getBlockEntity(blockpos);
-                  IClearable.tryClear(tileentity);
-                  if (blockstateinput.place(serverworld, blockpos, 2)) {
-                     list.add(blockpos.immutable());
-                     ++j;
-                  }
+      for(BlockPos blockpos : BlockPos.betweenClosed(p_198463_1_.x0, p_198463_1_.y0, p_198463_1_.z0, p_198463_1_.x1, p_198463_1_.y1, p_198463_1_.z1)) {
+         if (p_198463_4_ == null || p_198463_4_.test(new CachedBlockInfo(serverworld, blockpos, true))) {
+            BlockStateInput blockstateinput = p_198463_3_.filter.filter(p_198463_1_, blockpos, p_198463_2_, serverworld);
+            if (blockstateinput != null) {
+               TileEntity tileentity = serverworld.getBlockEntity(blockpos);
+               IClearable.tryClear(tileentity);
+               if (blockstateinput.place(serverworld, blockpos, 2)) {
+                  list.add(blockpos.immutable());
+                  ++j;
                }
             }
          }
+      }
 
-         for(BlockPos blockpos1 : list) {
-            Block block = serverworld.getBlockState(blockpos1).getBlock();
-            serverworld.blockUpdated(blockpos1, block);
-         }
+      for(BlockPos blockpos1 : list) {
+         Block block = serverworld.getBlockState(blockpos1).getBlock();
+         serverworld.blockUpdated(blockpos1, block);
+      }
 
-         if (j == 0) {
-            throw ERROR_FAILED.create();
-         } else {
-            p_198463_0_.sendSuccess(new TranslationTextComponent("commands.fill.success", j), true);
-            return j;
-         }
+      if (j == 0) {
+         throw ERROR_FAILED.create();
+      } else {
+         p_198463_0_.sendSuccess(new TranslationTextComponent("commands.fill.success", j), true);
+         return j;
       }
+      // Velox end
    }
 
    static enum Mode {
diff --git a/build/mcp_diff_src/net/minecraft/entity/player/ServerPlayerEntity.java b/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
index 339b18a..1a31073 100644
--- a/build/mcp_diff_src/net/minecraft/entity/player/ServerPlayerEntity.java
+++ b/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
@@ -3,13 +3,9 @@ package net.minecraft.entity.player;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Optional;
-import java.util.OptionalInt;
-import java.util.Random;
-import java.util.UUID;
+
+import java.util.*;
+import java.util.concurrent.LinkedBlockingDeque;
 import javax.annotation.Nullable;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.advancements.PlayerAdvancements;
@@ -136,7 +132,9 @@ public class ServerPlayerEntity extends PlayerEntity implements IContainerListen
    public ServerPlayNetHandler connection;
    public final MinecraftServer server;
    public final PlayerInteractionManager gameMode;
-   private final List<Integer> entitiesToRemove = Lists.newLinkedList();
+   // Velox start: entitiesToRemove threadsafe
+   private final Queue<Integer> entitiesToRemove = new LinkedBlockingDeque<>();
+   // Velox end
    private final PlayerAdvancements advancements;
    private final ServerStatisticsManager stats;
    private float lastRecordedHealthAndAbsorption = Float.MIN_VALUE;
diff --git a/build/mcp_diff_src/net/minecraft/profiler/Profiler.java b/src/main/java/net/minecraft/profiler/Profiler.java
index 11d9594..b61b7fc 100644
--- a/build/mcp_diff_src/net/minecraft/profiler/Profiler.java
+++ b/src/main/java/net/minecraft/profiler/Profiler.java
@@ -35,6 +35,9 @@ public class Profiler implements IResultableProfiler {
    @Nullable
    private Profiler.Section currentEntry;
    private final boolean warn;
+   // Velox start: Profiler thread-aware
+   private Thread drivingThread;
+   // Velox end
 
    public Profiler(LongSupplier p_i231482_1_, IntSupplier p_i231482_2_, boolean p_i231482_3_) {
       this.startTimeNano = p_i231482_1_.getAsLong();
@@ -48,6 +51,9 @@ public class Profiler implements IResultableProfiler {
       if (this.started) {
          LOGGER.error("Profiler tick already started - missing endTick()?");
       } else {
+         // Velox start: Profiler set driving thread
+         this.drivingThread = Thread.currentThread();
+         // Velox end
          this.started = true;
          this.path = "";
          this.paths.clear();
@@ -74,6 +80,11 @@ public class Profiler implements IResultableProfiler {
       if (!this.started) {
          LOGGER.error("Cannot push '{}' to profiler if profiler tick hasn't started - missing startTick()?", (Object)p_76320_1_);
       } else {
+         // Velox start: Check current thread on profiler calls
+         if (Thread.currentThread() != this.drivingThread){
+            return;
+         }
+         // Velox end
          if (!this.path.isEmpty()) {
             this.path = this.path + '\u001e';
          }
@@ -95,6 +106,11 @@ public class Profiler implements IResultableProfiler {
       } else if (this.startTimes.isEmpty()) {
          LOGGER.error("Tried to pop one too many times! Mismatched push() and pop()?");
       } else {
+         // Velox start: Check current thread on profiler calls
+         if (Thread.currentThread() != this.drivingThread){
+            return;
+         }
+         // Velox end
          long i = Util.getNanos();
          long j = this.startTimes.removeLong(this.startTimes.size() - 1);
          this.paths.remove(this.paths.size() - 1);
@@ -137,10 +153,20 @@ public class Profiler implements IResultableProfiler {
    }
 
    public void incrementCounter(String p_230035_1_) {
+      // Velox start: Check current thread on profiler calls
+      if (Thread.currentThread() != this.drivingThread){
+         return;
+      }
+      // Velox end
       this.getCurrentEntry().counters.addTo(p_230035_1_, 1L);
    }
 
    public void incrementCounter(Supplier<String> p_230036_1_) {
+      // Velox start: Check current thread on profiler calls
+      if (Thread.currentThread() != this.drivingThread){
+         return;
+      }
+      // Velox end
       this.getCurrentEntry().counters.addTo(p_230036_1_.get(), 1L);
    }
 
diff --git a/build/mcp_diff_src/net/minecraft/server/CustomServerBossInfo.java b/src/main/java/net/minecraft/server/CustomServerBossInfo.java
index 0cc4ce8..85ecca1 100644
--- a/build/mcp_diff_src/net/minecraft/server/CustomServerBossInfo.java
+++ b/src/main/java/net/minecraft/server/CustomServerBossInfo.java
@@ -19,7 +19,10 @@ import net.minecraft.world.server.ServerBossInfo;
 
 public class CustomServerBossInfo extends ServerBossInfo {
    private final ResourceLocation id;
-   private final Set<UUID> players = Sets.newHashSet();
+   // Velox start: players threadsafe
+   // Reason: players modified concurrently on player tracker (stop/startSeenByPlayer)
+   private final Set<UUID> players = Sets.newConcurrentHashSet();
+   // Velox end
    private int value;
    private int max = 100;
 
diff --git a/build/mcp_diff_src/net/minecraft/util/ClassInheritanceMultiMap.java b/src/main/java/net/minecraft/util/ClassInheritanceMultiMap.java
index 0ba4fdf..cf5f6bd 100644
--- a/build/mcp_diff_src/net/minecraft/util/ClassInheritanceMultiMap.java
+++ b/src/main/java/net/minecraft/util/ClassInheritanceMultiMap.java
@@ -4,6 +4,8 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import me.mikex86.velox.utils.CollectionUtils;
+
 import java.util.AbstractCollection;
 import java.util.Collection;
 import java.util.Collections;
@@ -11,12 +13,16 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.stream.Collectors;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
    private final Map<Class<?>, List<T>> byClass = Maps.newHashMap();
    private final Class<T> baseClass;
    private final List<T> allInstances = Lists.newArrayList();
+   // Velox start: ClassInheritanceMultiMap#lock
+   private final ReadWriteLock lock = new ReentrantReadWriteLock();
+   // Velox end
 
    public ClassInheritanceMultiMap(Class<T> p_i45909_1_) {
       this.baseClass = p_i45909_1_;
@@ -24,6 +30,8 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
    }
 
    public boolean add(T p_add_1_) {
+      // Velox start: ClassInheritanceMultiMap#add threadsafe
+      this.lock.writeLock().lock();
       boolean flag = false;
 
       for(Entry<Class<?>, List<T>> entry : this.byClass.entrySet()) {
@@ -31,11 +39,14 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
             flag |= entry.getValue().add(p_add_1_);
          }
       }
-
+      this.lock.writeLock().unlock();
+      // Velox end
       return flag;
    }
 
    public boolean remove(Object p_remove_1_) {
+      // Velox start: ClassInheritanceMultiMap#remove threadsafe
+      this.lock.writeLock().lock();
       boolean flag = false;
 
       for(Entry<Class<?>, List<T>> entry : this.byClass.entrySet()) {
@@ -44,7 +55,8 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
             flag |= list.remove(p_remove_1_);
          }
       }
-
+      this.lock.writeLock().unlock();
+      // Velox end
       return flag;
    }
 
@@ -53,25 +65,58 @@ public class ClassInheritanceMultiMap<T> extends AbstractCollection<T> {
    }
 
    public <S> Collection<S> find(Class<S> p_219790_1_) {
+      // Velox start: ClassInheritanceMultiMap#find threadsafe
       if (!this.baseClass.isAssignableFrom(p_219790_1_)) {
          throw new IllegalArgumentException("Don't know how to search for " + p_219790_1_);
       } else {
-         List<T> list = this.byClass.computeIfAbsent(p_219790_1_, (p_219791_1_) -> {
-            return this.allInstances.stream().filter(p_219791_1_::isInstance).collect(Collectors.toList());
-         });
-         return (Collection<S>) Collections.unmodifiableCollection(list);
+         this.lock.readLock().lock();
+         List<S> classList = (List<S>) this.byClass.get(p_219790_1_);
+         this.lock.readLock().unlock();
+         if (classList == null) {
+            this.lock.writeLock().lock();
+            classList = buildClassList(p_219790_1_);
+            this.byClass.put(p_219790_1_, (List<T>) classList);
+            this.lock.writeLock().unlock();
+         }
+         return CollectionUtils.immutableCopy(classList);
+      }
+      // Velox end
+   }
+
+   // Velox start: ClassInheritanceMultiMap#buildClassList
+   private <S> List<S> buildClassList(Class<S> clazz) {
+      List<S> classList = Lists.newArrayList();
+      for (T instance : this.allInstances) {
+         if (clazz.isInstance(instance)) {
+            classList.add((S) instance);
+         }
       }
+      return classList;
    }
+   // Velox end
 
    public Iterator<T> iterator() {
-      return (Iterator<T>)(this.allInstances.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(this.allInstances.iterator()));
+      // Velox start: ClassInheritanceMultiMap#iterator threadsafe
+      List<T> allInstances = getAllInstances();
+      return allInstances.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(allInstances.iterator());
+      // Velox end
    }
 
    public List<T> getAllInstances() {
-      return ImmutableList.copyOf(this.allInstances);
+      // Velox start: ClassInheritanceMultiMap#getAllInstances threadsafe
+      this.lock.readLock().lock();
+      ImmutableList<T> immutableCopy = ImmutableList.copyOf(this.allInstances);
+      this.lock.readLock().unlock();
+      return immutableCopy;
+      // Velox end
    }
 
    public int size() {
-      return this.allInstances.size();
+      // Velox start: ClassInheritanceMultiMap#size threadsafe
+      this.lock.readLock().lock();
+      int size = this.allInstances.size();
+      this.lock.readLock().unlock();
+      return size;
+      // Velox end
    }
 }
diff --git a/build/mcp_diff_src/net/minecraft/util/palette/PalettedContainer.java b/src/main/java/net/minecraft/util/palette/PalettedContainer.java
index 929a1e5..401bb26 100644
--- a/build/mcp_diff_src/net/minecraft/util/palette/PalettedContainer.java
+++ b/src/main/java/net/minecraft/util/palette/PalettedContainer.java
@@ -35,17 +35,9 @@ public class PalettedContainer<T> implements IResizeCallback<T> {
    private final ReentrantLock lock = new ReentrantLock();
 
    public void acquire() {
-      if (this.lock.isLocked() && !this.lock.isHeldByCurrentThread()) {
-         String s = Thread.getAllStackTraces().keySet().stream().filter(Objects::nonNull).map((p_210458_0_) -> {
-            return p_210458_0_.getName() + ": \n\tat " + (String)Arrays.stream(p_210458_0_.getStackTrace()).map(Object::toString).collect(Collectors.joining("\n\tat "));
-         }).collect(Collectors.joining("\n"));
-         CrashReport crashreport = new CrashReport("Writing into PalettedContainer from multiple threads", new IllegalStateException());
-         CrashReportCategory crashreportcategory = crashreport.addCategory("Thread dumps");
-         crashreportcategory.setDetail("Thread dumps", s);
-         throw new ReportedException(crashreport);
-      } else {
-         this.lock.lock();
-      }
+      // Velox start: Make PalettedContainer threadsafe
+      this.lock.lock();
+      // Velox end
    }
 
    public void release() {
diff --git a/build/mcp_diff_src/net/minecraft/village/PointOfInterestManager.java b/src/main/java/net/minecraft/village/PointOfInterestManager.java
index de4b6ec..83cf9df 100644
--- a/build/mcp_diff_src/net/minecraft/village/PointOfInterestManager.java
+++ b/src/main/java/net/minecraft/village/PointOfInterestManager.java
@@ -18,6 +18,8 @@ import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
+
+import me.mikex86.velox.utils.StreamUtils;
 import net.minecraft.block.BlockState;
 import net.minecraft.util.SectionDistanceGraph;
 import net.minecraft.util.Util;
@@ -39,69 +41,94 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
       this.distanceTracker = new PointOfInterestManager.DistanceGraph();
    }
 
-   public void add(BlockPos p_219135_1_, PointOfInterestType p_219135_2_) {
+   // Velox start: PointOfInterestManager#add threadsafe
+   public synchronized void add(BlockPos p_219135_1_, PointOfInterestType p_219135_2_) {
       this.getOrCreate(SectionPos.of(p_219135_1_).asLong()).add(p_219135_1_, p_219135_2_);
    }
+   // Velox end
+
 
-   public void remove(BlockPos p_219140_1_) {
+   // Velox start: PointOfInterestManager#remove threadsafe
+   public synchronized void remove(BlockPos p_219140_1_) {
       this.getOrCreate(SectionPos.of(p_219140_1_).asLong()).remove(p_219140_1_);
    }
+   // Velox end
+
 
-   public long getCountInRange(Predicate<PointOfInterestType> p_219145_1_, BlockPos p_219145_2_, int p_219145_3_, PointOfInterestManager.Status p_219145_4_) {
+   // Velox start: PointOfInterestManager#getCountInRange threadsafe
+   public synchronized long getCountInRange(Predicate<PointOfInterestType> p_219145_1_, BlockPos p_219145_2_, int p_219145_3_, PointOfInterestManager.Status p_219145_4_) {
       return this.getInRange(p_219145_1_, p_219145_2_, p_219145_3_, p_219145_4_).count();
    }
+   // Velox end
 
-   public boolean existsAtPosition(PointOfInterestType p_234135_1_, BlockPos p_234135_2_) {
+   // Velox start: PointOfInterestManager#existsAtPosition threadsafe
+   public synchronized boolean existsAtPosition(PointOfInterestType p_234135_1_, BlockPos p_234135_2_) {
       Optional<PointOfInterestType> optional = this.getOrCreate(SectionPos.of(p_234135_2_).asLong()).getType(p_234135_2_);
       return optional.isPresent() && optional.get().equals(p_234135_1_);
    }
+   // Velox end
 
-   public Stream<PointOfInterest> getInSquare(Predicate<PointOfInterestType> p_226353_1_, BlockPos p_226353_2_, int p_226353_3_, PointOfInterestManager.Status p_226353_4_) {
+   // Velox start: PointOfInterestManager#getInSquare threadsafe
+   public synchronized Stream<PointOfInterest> getInSquare(Predicate<PointOfInterestType> p_226353_1_, BlockPos p_226353_2_, int p_226353_3_, PointOfInterestManager.Status p_226353_4_) {
       int i = Math.floorDiv(p_226353_3_, 16) + 1;
-      return ChunkPos.rangeClosed(new ChunkPos(p_226353_2_), i).flatMap((p_226350_3_) -> {
+      return StreamUtils.prefetch(ChunkPos.rangeClosed(new ChunkPos(p_226353_2_), i).flatMap((p_226350_3_) -> {
          return this.getInChunk(p_226353_1_, p_226350_3_, p_226353_4_);
       }).filter((p_242322_2_) -> {
          BlockPos blockpos = p_242322_2_.getPos();
          return Math.abs(blockpos.getX() - p_226353_2_.getX()) <= p_226353_3_ && Math.abs(blockpos.getZ() - p_226353_2_.getZ()) <= p_226353_3_;
-      });
+      }));
    }
+   // Velox end
 
-   public Stream<PointOfInterest> getInRange(Predicate<PointOfInterestType> p_219146_1_, BlockPos p_219146_2_, int p_219146_3_, PointOfInterestManager.Status p_219146_4_) {
+   // Velox start: PointOfInterestManager#getInRange threadsafe
+   public synchronized Stream<PointOfInterest> getInRange(Predicate<PointOfInterestType> p_219146_1_, BlockPos p_219146_2_, int p_219146_3_, PointOfInterestManager.Status p_219146_4_) {
       int i = p_219146_3_ * p_219146_3_;
-      return this.getInSquare(p_219146_1_, p_219146_2_, p_219146_3_, p_219146_4_).filter((p_226349_2_) -> {
+      return StreamUtils.prefetch(this.getInSquare(p_219146_1_, p_219146_2_, p_219146_3_, p_219146_4_).filter((p_226349_2_) -> {
          return p_226349_2_.getPos().distSqr(p_219146_2_) <= (double)i;
-      });
+      }));
    }
+   // Velox end
 
-   public Stream<PointOfInterest> getInChunk(Predicate<PointOfInterestType> p_219137_1_, ChunkPos p_219137_2_, PointOfInterestManager.Status p_219137_3_) {
-      return IntStream.range(0, 16).boxed().map((p_219149_2_) -> {
+   // Velox start: PointOfInterestManager#getInChunk threadsafe
+   public synchronized Stream<PointOfInterest> getInChunk(Predicate<PointOfInterestType> p_219137_1_, ChunkPos p_219137_2_, PointOfInterestManager.Status p_219137_3_) {
+      return StreamUtils.prefetch(IntStream.range(0, 16).boxed().map((p_219149_2_) -> {
          return this.getOrLoad(SectionPos.of(p_219137_2_, p_219149_2_).asLong());
       }).filter(Optional::isPresent).flatMap((p_241393_2_) -> {
          return p_241393_2_.get().getRecords(p_219137_1_, p_219137_3_);
-      });
+      }));
    }
+   // Velox end
 
-   public Stream<BlockPos> findAll(Predicate<PointOfInterestType> p_225399_1_, Predicate<BlockPos> p_225399_2_, BlockPos p_225399_3_, int p_225399_4_, PointOfInterestManager.Status p_225399_5_) {
-      return this.getInRange(p_225399_1_, p_225399_3_, p_225399_4_, p_225399_5_).map(PointOfInterest::getPos).filter(p_225399_2_);
+   // Velox start: PointOfInterestManager#findAll threadsafe
+   public synchronized Stream<BlockPos> findAll(Predicate<PointOfInterestType> p_225399_1_, Predicate<BlockPos> p_225399_2_, BlockPos p_225399_3_, int p_225399_4_, PointOfInterestManager.Status p_225399_5_) {
+      return StreamUtils.prefetch(this.getInRange(p_225399_1_, p_225399_3_, p_225399_4_, p_225399_5_).map(PointOfInterest::getPos).filter(p_225399_2_));
    }
+   // Velox end
 
-   public Stream<BlockPos> findAllClosestFirst(Predicate<PointOfInterestType> p_242324_1_, Predicate<BlockPos> p_242324_2_, BlockPos p_242324_3_, int p_242324_4_, PointOfInterestManager.Status p_242324_5_) {
-      return this.findAll(p_242324_1_, p_242324_2_, p_242324_3_, p_242324_4_, p_242324_5_).sorted(Comparator.comparingDouble((p_242323_1_) -> {
+   // Velox start: PointOfInterestManager#findAllClosestFirst threadsafe
+   public synchronized Stream<BlockPos> findAllClosestFirst(Predicate<PointOfInterestType> p_242324_1_, Predicate<BlockPos> p_242324_2_, BlockPos p_242324_3_, int p_242324_4_, PointOfInterestManager.Status p_242324_5_) {
+      return StreamUtils.prefetch(this.findAll(p_242324_1_, p_242324_2_, p_242324_3_, p_242324_4_, p_242324_5_).sorted(Comparator.comparingDouble((p_242323_1_) -> {
          return p_242323_1_.distSqr(p_242324_3_);
-      }));
+      })));
    }
+   // Velox end
 
-   public Optional<BlockPos> find(Predicate<PointOfInterestType> p_219127_1_, Predicate<BlockPos> p_219127_2_, BlockPos p_219127_3_, int p_219127_4_, PointOfInterestManager.Status p_219127_5_) {
+   // Velox start: PointOfInterestManager#find threadsafe
+   public synchronized Optional<BlockPos> find(Predicate<PointOfInterestType> p_219127_1_, Predicate<BlockPos> p_219127_2_, BlockPos p_219127_3_, int p_219127_4_, PointOfInterestManager.Status p_219127_5_) {
       return this.findAll(p_219127_1_, p_219127_2_, p_219127_3_, p_219127_4_, p_219127_5_).findFirst();
    }
+   // Velox end
 
-   public Optional<BlockPos> findClosest(Predicate<PointOfInterestType> p_234148_1_, BlockPos p_234148_2_, int p_234148_3_, PointOfInterestManager.Status p_234148_4_) {
+   // Velox start: PointOfInterestManager#findClosest threadsafe
+   public synchronized Optional<BlockPos> findClosest(Predicate<PointOfInterestType> p_234148_1_, BlockPos p_234148_2_, int p_234148_3_, PointOfInterestManager.Status p_234148_4_) {
       return this.getInRange(p_234148_1_, p_234148_2_, p_234148_3_, p_234148_4_).map(PointOfInterest::getPos).min(Comparator.comparingDouble((p_219160_1_) -> {
          return p_219160_1_.distSqr(p_234148_2_);
       }));
    }
+   // Velox end
 
-   public Optional<BlockPos> take(Predicate<PointOfInterestType> p_219157_1_, Predicate<BlockPos> p_219157_2_, BlockPos p_219157_3_, int p_219157_4_) {
+   // Velox start: PointOfInterestManager#take threadsafe
+   public synchronized Optional<BlockPos> take(Predicate<PointOfInterestType> p_219157_1_, Predicate<BlockPos> p_219157_2_, BlockPos p_219157_3_, int p_219157_4_) {
       return this.getInRange(p_219157_1_, p_219157_3_, p_219157_4_, PointOfInterestManager.Status.HAS_SPACE).filter((p_219129_1_) -> {
          return p_219157_2_.test(p_219129_1_.getPos());
       }).findFirst().map((p_219152_0_) -> {
@@ -109,57 +136,78 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
          return p_219152_0_.getPos();
       });
    }
+   // Velox end
 
-   public Optional<BlockPos> getRandom(Predicate<PointOfInterestType> p_219163_1_, Predicate<BlockPos> p_219163_2_, PointOfInterestManager.Status p_219163_3_, BlockPos p_219163_4_, int p_219163_5_, Random p_219163_6_) {
+   // Velox start: PointOfInterestManager#getRandom threadsafe
+   public synchronized Optional<BlockPos> getRandom(Predicate<PointOfInterestType> p_219163_1_, Predicate<BlockPos> p_219163_2_, PointOfInterestManager.Status p_219163_3_, BlockPos p_219163_4_, int p_219163_5_, Random p_219163_6_) {
       List<PointOfInterest> list = this.getInRange(p_219163_1_, p_219163_4_, p_219163_5_, p_219163_3_).collect(Collectors.toList());
       Collections.shuffle(list, p_219163_6_);
       return list.stream().filter((p_234143_1_) -> {
          return p_219163_2_.test(p_234143_1_.getPos());
       }).findFirst().map(PointOfInterest::getPos);
    }
+   // Velox end
 
-   public boolean release(BlockPos p_219142_1_) {
+   // Velox start: PointOfInterestManager#release threadsafe
+   public synchronized boolean release(BlockPos p_219142_1_) {
       return this.getOrCreate(SectionPos.of(p_219142_1_).asLong()).release(p_219142_1_);
    }
+   // Velox end
 
+   // Velox start: PointOfInterestManager#exists threadsafe
    public boolean exists(BlockPos p_219138_1_, Predicate<PointOfInterestType> p_219138_2_) {
       return this.getOrLoad(SectionPos.of(p_219138_1_).asLong()).map((p_234141_2_) -> {
          return p_234141_2_.exists(p_219138_1_, p_219138_2_);
       }).orElse(false);
    }
+   // Velox end
 
-   public Optional<PointOfInterestType> getType(BlockPos p_219148_1_) {
+   // Velox start: PointOfInterestManager#getType threadsafe
+   public synchronized Optional<PointOfInterestType> getType(BlockPos p_219148_1_) {
       PointOfInterestData pointofinterestdata = this.getOrCreate(SectionPos.of(p_219148_1_).asLong());
       return pointofinterestdata.getType(p_219148_1_);
    }
+   // Velox end
 
-   public int sectionsToVillage(SectionPos p_219150_1_) {
+   // Velox start: PointOfInterestManager#sectionsToVillage threadsafe
+   public synchronized int sectionsToVillage(SectionPos p_219150_1_) {
       this.distanceTracker.runAllUpdates();
       return this.distanceTracker.getLevel(p_219150_1_.asLong());
    }
+   // Velox end
+
 
-   private boolean isVillageCenter(long p_219154_1_) {
+   // Velox start: PointOfInterestManager#isVillageCenter threadsafe
+   private synchronized boolean isVillageCenter(long p_219154_1_) {
       Optional<PointOfInterestData> optional = this.get(p_219154_1_);
       return optional == null ? false : optional.map((p_234134_0_) -> {
          return p_234134_0_.getRecords(PointOfInterestType.ALL, PointOfInterestManager.Status.IS_OCCUPIED).count() > 0L;
       }).orElse(false);
    }
+   // Velox end
 
-   public void tick(BooleanSupplier p_219115_1_) {
+   // Velox start: PointOfInterestManager#tick threadsafe
+   public synchronized void tick(BooleanSupplier p_219115_1_) {
       super.tick(p_219115_1_);
       this.distanceTracker.runAllUpdates();
    }
+   // Velox end
 
-   protected void setDirty(long p_219116_1_) {
+   // Velox start: PointOfInterestManager#setDirty threadsafe
+   protected synchronized void setDirty(long p_219116_1_) {
       super.setDirty(p_219116_1_);
       this.distanceTracker.update(p_219116_1_, this.distanceTracker.getLevelFromSource(p_219116_1_), false);
    }
+   // Velox end
 
-   protected void onSectionLoad(long p_219111_1_) {
+   // Velox start: PointOfInterestManager#onSectionLoad threadsafe
+   protected synchronized void onSectionLoad(long p_219111_1_) {
       this.distanceTracker.update(p_219111_1_, this.distanceTracker.getLevelFromSource(p_219111_1_), false);
    }
+   // Velox end
 
-   public void checkConsistencyWithBlocks(ChunkPos p_219139_1_, ChunkSection p_219139_2_) {
+   // Velox start: PointOfInterestManager#checkConsistencyWithBlocks threadsafe
+   public synchronized void checkConsistencyWithBlocks(ChunkPos p_219139_1_, ChunkSection p_219139_2_) {
       SectionPos sectionpos = SectionPos.of(p_219139_1_, p_219139_2_.bottomBlockY() >> 4);
       Util.ifElse(this.getOrLoad(sectionpos.asLong()), (p_234138_3_) -> {
          p_234138_3_.refresh((p_234145_3_) -> {
@@ -176,12 +224,16 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
 
       });
    }
+   // Velox end
 
-   private static boolean mayHavePoi(ChunkSection p_219151_0_) {
+   // Velox start: PointOfInterestManager#mayHavePoi threadsafe
+   private static synchronized boolean mayHavePoi(ChunkSection p_219151_0_) {
       return p_219151_0_.maybeHas(PointOfInterestType.ALL_STATES::contains);
    }
+   // Velox end
 
-   private void updateFromSection(ChunkSection p_219132_1_, SectionPos p_219132_2_, BiConsumer<BlockPos, PointOfInterestType> p_219132_3_) {
+   // Velox start: PointOfInterestManager#updateFromSection threadsafe
+   private synchronized void updateFromSection(ChunkSection p_219132_1_, SectionPos p_219132_2_, BiConsumer<BlockPos, PointOfInterestType> p_219132_3_) {
       p_219132_2_.blocksInside().forEach((p_234139_2_) -> {
          BlockState blockstate = p_219132_1_.getBlockState(SectionPos.sectionRelative(p_234139_2_.getX()), SectionPos.sectionRelative(p_234139_2_.getY()), SectionPos.sectionRelative(p_234139_2_.getZ()));
          PointOfInterestType.forState(blockstate).ifPresent((p_234142_2_) -> {
@@ -189,8 +241,10 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
          });
       });
    }
+   // Velox end
 
-   public void ensureLoadedAndValid(IWorldReader p_226347_1_, BlockPos p_226347_2_, int p_226347_3_) {
+   // Velox start: PointOfInterestManager#ensureLoadedAndValid threadsafe
+   public synchronized void ensureLoadedAndValid(IWorldReader p_226347_1_, BlockPos p_226347_2_, int p_226347_3_) {
       SectionPos.aroundChunk(new ChunkPos(p_226347_2_), Math.floorDiv(p_226347_3_, 16)).map((p_234147_1_) -> {
          return Pair.of(p_234147_1_, this.getOrLoad(p_234147_1_.asLong()));
       }).filter((p_234146_0_) -> {
@@ -203,6 +257,7 @@ public class PointOfInterestManager extends RegionSectionCache<PointOfInterestDa
          p_226347_1_.getChunk(p_234136_1_.x, p_234136_1_.z, ChunkStatus.EMPTY);
       });
    }
+   // Velox end
 
    final class DistanceGraph extends SectionDistanceGraph {
       private final Long2ByteMap levels = new Long2ByteOpenHashMap();
diff --git a/build/mcp_diff_src/net/minecraft/world/World.java b/src/main/java/net/minecraft/world/World.java
index d5fbf20..3332e08 100644
--- a/build/mcp_diff_src/net/minecraft/world/World.java
+++ b/src/main/java/net/minecraft/world/World.java
@@ -7,10 +7,14 @@ import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.tick.TickRegionManager;
 import net.minecraft.block.AbstractFireBlock;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockState;
@@ -70,10 +74,12 @@ public abstract class World implements IWorld, AutoCloseable {
    public static final RegistryKey<World> NETHER = RegistryKey.create(Registry.DIMENSION_REGISTRY, new ResourceLocation("the_nether"));
    public static final RegistryKey<World> END = RegistryKey.create(Registry.DIMENSION_REGISTRY, new ResourceLocation("the_end"));
    private static final Direction[] DIRECTIONS = Direction.values();
-   public final List<TileEntity> blockEntityList = Lists.newArrayList();
-   public final List<TileEntity> tickableBlockEntities = Lists.newArrayList();
-   protected final List<TileEntity> pendingBlockEntities = Lists.newArrayList();
-   protected final List<TileEntity> blockEntitiesToUnload = Lists.newArrayList();
+   // Velox start: Make tile entity lists threadsafe
+   public final List<TileEntity> blockEntityList = Lists.newCopyOnWriteArrayList();
+   public final List<TileEntity> tickableBlockEntities = Lists.newCopyOnWriteArrayList();
+   protected final List<TileEntity> pendingBlockEntities = Lists.newCopyOnWriteArrayList();
+   protected final List<TileEntity> blockEntitiesToUnload = Lists.newCopyOnWriteArrayList();
+   // Velox end
    private final Thread thread;
    private final boolean isDebug;
    private int skyDarken;
@@ -92,6 +98,9 @@ public abstract class World implements IWorld, AutoCloseable {
    private final WorldBorder worldBorder;
    private final BiomeManager biomeManager;
    private final RegistryKey<World> dimension;
+   // Velox start: TickRegionManager
+   public final TickRegionManager tickRegionManager = new TickRegionManager();
+   // Velox end
 
    protected World(ISpawnWorldInfo p_i241925_1_, RegistryKey<World> p_i241925_2_, final DimensionType p_i241925_3_, Supplier<IProfiler> p_i241925_4_, boolean p_i241925_5_, boolean p_i241925_6_, long p_i241925_7_) {
       this.profiler = p_i241925_4_;
@@ -168,58 +177,74 @@ public abstract class World implements IWorld, AutoCloseable {
       }
    }
 
+   // Velox start: block change lock
+   private final Lock blockChangeLock = new ReentrantLock();
+   // Velox end
+
    public boolean setBlock(BlockPos p_180501_1_, BlockState p_180501_2_, int p_180501_3_) {
-      return this.setBlock(p_180501_1_, p_180501_2_, p_180501_3_, 512);
+      // Velox start setBlock threadsafe
+      this.blockChangeLock.lock();
+      boolean changed = this.setBlock(p_180501_1_, p_180501_2_, p_180501_3_, 512);
+      this.blockChangeLock.unlock();
+      // Velox end
+      return changed;
    }
 
    public boolean setBlock(BlockPos p_241211_1_, BlockState p_241211_2_, int p_241211_3_, int p_241211_4_) {
-      if (isOutsideBuildHeight(p_241211_1_)) {
-         return false;
-      } else if (!this.isClientSide && this.isDebug()) {
-         return false;
-      } else {
-         Chunk chunk = this.getChunkAt(p_241211_1_);
-         Block block = p_241211_2_.getBlock();
-         BlockState blockstate = chunk.setBlockState(p_241211_1_, p_241211_2_, (p_241211_3_ & 64) != 0);
-         if (blockstate == null) {
+      // Velox start setBlock threadsafe
+      this.blockChangeLock.lock();
+      try {
+         if (isOutsideBuildHeight(p_241211_1_)) {
+            return false;
+         } else if (!this.isClientSide && this.isDebug()) {
             return false;
          } else {
-            BlockState blockstate1 = this.getBlockState(p_241211_1_);
-            if ((p_241211_3_ & 128) == 0 && blockstate1 != blockstate && (blockstate1.getLightBlock(this, p_241211_1_) != blockstate.getLightBlock(this, p_241211_1_) || blockstate1.getLightEmission() != blockstate.getLightEmission() || blockstate1.useShapeForLightOcclusion() || blockstate.useShapeForLightOcclusion())) {
-               this.getProfiler().push("queueCheckLight");
-               this.getChunkSource().getLightEngine().checkBlock(p_241211_1_);
-               this.getProfiler().pop();
-            }
-
-            if (blockstate1 == p_241211_2_) {
-               if (blockstate != blockstate1) {
-                  this.setBlocksDirty(p_241211_1_, blockstate, blockstate1);
+            Chunk chunk = this.getChunkAt(p_241211_1_);
+            Block block = p_241211_2_.getBlock();
+            BlockState blockstate = chunk.setBlockState(p_241211_1_, p_241211_2_, (p_241211_3_ & 64) != 0);
+            if (blockstate == null) {
+               return false;
+            } else {
+               BlockState blockstate1 = this.getBlockState(p_241211_1_);
+               if ((p_241211_3_ & 128) == 0 && blockstate1 != blockstate && (blockstate1.getLightBlock(this, p_241211_1_) != blockstate.getLightBlock(this, p_241211_1_) || blockstate1.getLightEmission() != blockstate.getLightEmission() || blockstate1.useShapeForLightOcclusion() || blockstate.useShapeForLightOcclusion())) {
+                  this.getProfiler().push("queueCheckLight");
+                  this.getChunkSource().getLightEngine().checkBlock(p_241211_1_);
+                  this.getProfiler().pop();
                }
 
-               if ((p_241211_3_ & 2) != 0 && (!this.isClientSide || (p_241211_3_ & 4) == 0) && (this.isClientSide || chunk.getFullStatus() != null && chunk.getFullStatus().isOrAfter(ChunkHolder.LocationType.TICKING))) {
-                  this.sendBlockUpdated(p_241211_1_, blockstate, p_241211_2_, p_241211_3_);
-               }
+               if (blockstate1 == p_241211_2_) {
+                  if (blockstate != blockstate1) {
+                     this.setBlocksDirty(p_241211_1_, blockstate, blockstate1);
+                  }
 
-               if ((p_241211_3_ & 1) != 0) {
-                  this.blockUpdated(p_241211_1_, blockstate.getBlock());
-                  if (!this.isClientSide && p_241211_2_.hasAnalogOutputSignal()) {
-                     this.updateNeighbourForOutputSignal(p_241211_1_, block);
+                  if ((p_241211_3_ & 2) != 0 && (!this.isClientSide || (p_241211_3_ & 4) == 0) && (this.isClientSide || chunk.getFullStatus() != null && chunk.getFullStatus().isOrAfter(ChunkHolder.LocationType.TICKING))) {
+                     this.sendBlockUpdated(p_241211_1_, blockstate, p_241211_2_, p_241211_3_);
+                  }
+
+                  if ((p_241211_3_ & 1) != 0) {
+                     this.blockUpdated(p_241211_1_, blockstate.getBlock());
+                     if (!this.isClientSide && p_241211_2_.hasAnalogOutputSignal()) {
+                        this.updateNeighbourForOutputSignal(p_241211_1_, block);
+                     }
                   }
-               }
 
-               if ((p_241211_3_ & 16) == 0 && p_241211_4_ > 0) {
-                  int i = p_241211_3_ & -34;
-                  blockstate.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
-                  p_241211_2_.updateNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
-                  p_241211_2_.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
+                  if ((p_241211_3_ & 16) == 0 && p_241211_4_ > 0) {
+                     int i = p_241211_3_ & -34;
+                     blockstate.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
+                     p_241211_2_.updateNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
+                     p_241211_2_.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
+                  }
+
+                  this.onBlockStateChange(p_241211_1_, blockstate, blockstate1);
                }
 
-               this.onBlockStateChange(p_241211_1_, blockstate, blockstate1);
+               return true;
             }
-
-            return true;
          }
+      } finally {
+         this.blockChangeLock.unlock();
       }
+      // Velox end
    }
 
    public void onBlockStateChange(BlockPos p_217393_1_, BlockState p_217393_2_, BlockState p_217393_3_) {
@@ -527,9 +552,9 @@ public abstract class World implements IWorld, AutoCloseable {
    public TileEntity getBlockEntity(BlockPos p_175625_1_) {
       if (isOutsideBuildHeight(p_175625_1_)) {
          return null;
-      } else if (!this.isClientSide && Thread.currentThread() != this.thread) {
-         return null;
+      // Velox start: remove getBlockEntity mainThread check
       } else {
+      // Velox end
          TileEntity tileentity = null;
          if (this.updatingBlockEntities) {
             tileentity = this.getPendingBlockEntityAt(p_175625_1_);
diff --git a/build/mcp_diff_src/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index 551fa3d..df80403 100644
--- a/build/mcp_diff_src/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -65,11 +65,15 @@ public class Chunk implements IChunk {
    private final ChunkSection[] sections = new ChunkSection[16];
    private BiomeContainer biomes;
    private final Map<BlockPos, CompoundNBT> pendingBlockEntities = Maps.newHashMap();
-   private boolean loaded;
+   // Velox start: make Chunk#loaded public
+   public boolean loaded;
+   // Velox end
    private final World level;
    private final Map<Heightmap.Type, Heightmap> heightmaps = Maps.newEnumMap(Heightmap.Type.class);
    private final UpgradeData upgradeData;
-   private final Map<BlockPos, TileEntity> blockEntities = Maps.newHashMap();
+   // Velox start: Make blockEntities map thread-safe
+   private final Map<BlockPos, TileEntity> blockEntities = Maps.newConcurrentMap();
+   // Velox end
    private final ClassInheritanceMultiMap<Entity>[] entitySections;
    private final Map<Structure<?>, StructureStart<?>> structureStarts = Maps.newHashMap();
    private final Map<Structure<?>, LongSet> structuresRefences = Maps.newHashMap();
@@ -573,6 +577,9 @@ public class Chunk implements IChunk {
    }
 
    public void setLoaded(boolean p_177417_1_) {
+      // Velox start: inform tick region manager of chunk load state change
+      this.level.tickRegionManager.informChunkLoadStateChange(this, p_177417_1_);
+      // Velox end
       this.loaded = p_177417_1_;
    }
 
diff --git a/build/mcp_diff_src/net/minecraft/world/chunk/PlayerGenerationTracker.java b/src/main/java/net/minecraft/world/chunk/PlayerGenerationTracker.java
index 2ab06fe..3f91bd9 100644
--- a/build/mcp_diff_src/net/minecraft/world/chunk/PlayerGenerationTracker.java
+++ b/src/main/java/net/minecraft/world/chunk/PlayerGenerationTracker.java
@@ -1,15 +1,21 @@
 package net.minecraft.world.chunk;
 
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
+import it.unimi.dsi.fastutil.objects.Object2BooleanMaps;
 import it.unimi.dsi.fastutil.objects.Object2BooleanOpenHashMap;
+
 import java.util.stream.Stream;
+
+import me.mikex86.velox.utils.StreamUtils;
 import net.minecraft.entity.player.ServerPlayerEntity;
 
+// Velox start: PlayerGenerationTracker threadsafe
+// Reason: used by EntityTracker (invoked concurrently by ServerPlayerEntity#tick)
 public final class PlayerGenerationTracker {
-   private final Object2BooleanMap<ServerPlayerEntity> players = new Object2BooleanOpenHashMap<>();
+   private final Object2BooleanMap<ServerPlayerEntity> players = Object2BooleanMaps.synchronize(new Object2BooleanOpenHashMap<>());
 
    public Stream<ServerPlayerEntity> getPlayers(long p_219444_1_) {
-      return this.players.keySet().stream();
+      return StreamUtils.prefetchSynchronizedCollection(this.players.keySet());
    }
 
    public void addPlayer(long p_219442_1_, ServerPlayerEntity p_219442_3_, boolean p_219442_4_) {
@@ -39,3 +45,4 @@ public final class PlayerGenerationTracker {
    public void updatePlayer(long p_219445_1_, long p_219445_3_, ServerPlayerEntity p_219445_5_) {
    }
 }
+// Velox end
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ChunkManager.java b/src/main/java/net/minecraft/world/server/ChunkManager.java
index 5ebcd28..ec1aba2 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ChunkManager.java
+++ b/src/main/java/net/minecraft/world/server/ChunkManager.java
@@ -9,27 +9,19 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
-import java.util.Collection;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.function.BooleanSupplier;
 import java.util.function.IntFunction;
 import java.util.function.IntSupplier;
@@ -37,6 +29,8 @@ import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.utils.CollectionUtils;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ReportedException;
@@ -97,7 +91,11 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    public static final int MAX_CHUNK_DISTANCE = 33 + ChunkStatus.maxDistance();
    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new Long2ObjectLinkedOpenHashMap<>();
    private volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = this.updatingChunkMap.clone();
-   private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads = new Long2ObjectLinkedOpenHashMap<>();
+   // Velox start: visibleChunkMap lock
+   private final ReadWriteLock visibleChunkMapLock = new ReentrantReadWriteLock();
+   // Velox start: Make ChunkManager#pendingUnloads public
+   public final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads = new Long2ObjectLinkedOpenHashMap<>();
+   // Velox end
    private final LongSet entitiesInLevel = new LongOpenHashSet();
    private final ServerWorld level;
    private final ServerWorldLightManager lightEngine;
@@ -116,6 +114,10 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    private final TemplateManager structureManager;
    private final File storageFolder;
    private final PlayerGenerationTracker playerMap = new PlayerGenerationTracker();
+   // Velox comment:
+   // #entityMap seems to not be modified during entity tick, as removing and adding entities is
+   // validated to only happen when entities are not being ticked.
+   // Concurrent read access should be safe with Velox's ticking model
    private final Int2ObjectMap<ChunkManager.EntityTracker> entityMap = new Int2ObjectOpenHashMap<>();
    private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
    private final Queue<Runnable> unloadQueue = Queues.newConcurrentLinkedQueue();
@@ -182,7 +184,12 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 
    @Nullable
    protected ChunkHolder getVisibleChunkIfPresent(long p_219219_1_) {
-      return this.visibleChunkMap.get(p_219219_1_);
+      // Velox start: threadsafe visibleChunkMap access
+      this.visibleChunkMapLock.readLock().lock();
+      ChunkHolder chunkHolder = this.visibleChunkMap.get(p_219219_1_);
+      this.visibleChunkMapLock.readLock().unlock();
+      // Velox end
+      return chunkHolder;
    }
 
    protected IntSupplier getChunkQueueLevel(long p_219191_1_) {
@@ -319,7 +326,12 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 
    protected void saveAllChunks(boolean p_219177_1_) {
       if (p_219177_1_) {
+         // Velox start: visible chunk map thread-safe access
+         this.visibleChunkMapLock.readLock().lock();
          List<ChunkHolder> list = this.visibleChunkMap.values().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).peek(ChunkHolder::refreshAccessibility).collect(Collectors.toList());
+         this.visibleChunkMapLock.readLock().unlock();
+         // Velox end
+
          MutableBoolean mutableboolean = new MutableBoolean();
 
          do {
@@ -345,6 +357,8 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
          this.flushWorker();
          LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", (Object)this.storageFolder.getName());
       } else {
+         // Velox start: threadsafe visibleChunkMap
+         this.visibleChunkMapLock.readLock().lock();
          this.visibleChunkMap.values().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).forEach((p_222965_1_) -> {
             IChunk ichunk = p_222965_1_.getChunkToSave().getNow((IChunk)null);
             if (ichunk instanceof ChunkPrimerWrapper || ichunk instanceof Chunk) {
@@ -353,6 +367,8 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
             }
 
          });
+         this.visibleChunkMapLock.readLock().unlock();
+         // Velox end
       }
 
    }
@@ -426,7 +442,11 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
       if (!this.modified) {
          return false;
       } else {
+         // Velox start: visibleChunkMap threadsafe refresh
+         this.visibleChunkMapLock.writeLock().lock();
          this.visibleChunkMap = this.updatingChunkMap.clone();
+         this.visibleChunkMapLock.writeLock().unlock();
+         // Velox end
          this.modified = false;
          return true;
       }
@@ -754,7 +774,12 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    }
 
    public int size() {
-      return this.visibleChunkMap.size();
+      // Velox start: visibleChunkMap threadsafe access
+      this.visibleChunkMapLock.readLock().lock();
+      int size = this.visibleChunkMap.size();
+      this.visibleChunkMapLock.readLock().unlock();
+      // Velox end
+      return size;
    }
 
    protected ChunkManager.ProxyTicketManager getDistanceManager() {
@@ -762,13 +787,24 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
    }
 
    protected Iterable<ChunkHolder> getChunks() {
-      return Iterables.unmodifiableIterable(this.visibleChunkMap.values());
+      // Velox start: visibleChunkMap threadsafe access
+      this.visibleChunkMapLock.readLock().lock();
+      Iterable<ChunkHolder> iterable = CollectionUtils.prefetchIterable(Iterables.unmodifiableIterable(this.visibleChunkMap.values()));
+      this.visibleChunkMapLock.readLock().unlock();
+      // Velox end
+      return iterable;
    }
 
    void dumpChunks(Writer p_225406_1_) throws IOException {
       CSVWriter csvwriter = CSVWriter.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("entity_count").addColumn("block_entity_count").build(p_225406_1_);
 
-      for(Entry<ChunkHolder> entry : this.visibleChunkMap.long2ObjectEntrySet()) {
+      // Velox start: visibleChunkMap threadsafe access
+      this.visibleChunkMapLock.readLock().lock();
+      List<Entry<ChunkHolder>> entrySet = CollectionUtils.collectToList(this.visibleChunkMap.long2ObjectEntrySet().iterator());
+      this.visibleChunkMapLock.readLock().unlock();
+      // Velox end
+
+      for(Entry<ChunkHolder> entry : entrySet) {
          ChunkPos chunkpos = new ChunkPos(entry.getLongKey());
          ChunkHolder chunkholder = entry.getValue();
          Optional<IChunk> optional = Optional.ofNullable(chunkholder.getLastAvailable());
@@ -851,84 +887,84 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
       return sectionpos;
    }
 
-   public void move(ServerPlayerEntity p_219183_1_) {
-      for(ChunkManager.EntityTracker chunkmanager$entitytracker : this.entityMap.values()) {
-         if (chunkmanager$entitytracker.entity == p_219183_1_) {
-            chunkmanager$entitytracker.updatePlayers(this.level.players());
+   // Velox start: EntityTracker#move threadsafe
+   // Reason: Invoked concurrently by EntityServerPlayer#tick
+   public void move(ServerPlayerEntity player) {
+      Collection<EntityTracker> entityTrackers = CollectionUtils.immutableCopy(this.entityMap.values());
+      for(ChunkManager.EntityTracker tracker : entityTrackers) {
+         if (tracker.entity == player) {
+            tracker.updatePlayers(this.level.players());
          } else {
-            chunkmanager$entitytracker.updatePlayer(p_219183_1_);
+            tracker.updatePlayer(player);
          }
       }
 
-      int l1 = MathHelper.floor(p_219183_1_.getX()) >> 4;
-      int i2 = MathHelper.floor(p_219183_1_.getZ()) >> 4;
-      SectionPos sectionpos = p_219183_1_.getLastSectionPos();
-      SectionPos sectionpos1 = SectionPos.of(p_219183_1_);
-      long i = sectionpos.chunk().toLong();
-      long j = sectionpos1.chunk().toLong();
-      boolean flag = this.playerMap.ignored(p_219183_1_);
-      boolean flag1 = this.skipPlayer(p_219183_1_);
-      boolean flag2 = sectionpos.asLong() != sectionpos1.asLong();
-      if (flag2 || flag != flag1) {
-         this.updatePlayerPos(p_219183_1_);
-         if (!flag) {
-            this.distanceManager.removePlayer(sectionpos, p_219183_1_);
+      int chunkX = MathHelper.floor(player.getX()) >> 4;
+      int chunkZ = MathHelper.floor(player.getZ()) >> 4;
+      SectionPos lastSection = player.getLastSectionPos();
+      SectionPos currentSection = SectionPos.of(player);
+      long lastSectionPacked = lastSection.chunk().toLong();
+      long currentSectionPacked = currentSection.chunk().toLong();
+      boolean ignored = this.playerMap.ignored(player);
+      boolean skipPlayer = this.skipPlayer(player);
+      boolean flag2 = lastSection.asLong() != currentSection.asLong();
+      if (flag2 || ignored != skipPlayer) {
+         this.updatePlayerPos(player);
+         if (!ignored) {
+            this.distanceManager.removePlayer(lastSection, player);
          }
 
-         if (!flag1) {
-            this.distanceManager.addPlayer(sectionpos1, p_219183_1_);
+         if (!skipPlayer) {
+            this.distanceManager.addPlayer(currentSection, player);
          }
 
-         if (!flag && flag1) {
-            this.playerMap.ignorePlayer(p_219183_1_);
+         if (!ignored && skipPlayer) {
+            this.playerMap.ignorePlayer(player);
          }
 
-         if (flag && !flag1) {
-            this.playerMap.unIgnorePlayer(p_219183_1_);
+         if (ignored && !skipPlayer) {
+            this.playerMap.unIgnorePlayer(player);
          }
 
-         if (i != j) {
-            this.playerMap.updatePlayer(i, j, p_219183_1_);
+         if (lastSectionPacked != currentSectionPacked) {
+            this.playerMap.updatePlayer(lastSectionPacked, currentSectionPacked, player);
          }
       }
 
-      int k = sectionpos.x();
-      int l = sectionpos.z();
-      if (Math.abs(k - l1) <= this.viewDistance * 2 && Math.abs(l - i2) <= this.viewDistance * 2) {
-         int k2 = Math.min(l1, k) - this.viewDistance;
-         int i3 = Math.min(i2, l) - this.viewDistance;
-         int j3 = Math.max(l1, k) + this.viewDistance;
-         int k3 = Math.max(i2, l) + this.viewDistance;
+      int k = lastSection.x();
+      int l = lastSection.z();
+      if (Math.abs(k - chunkX) <= this.viewDistance * 2 && Math.abs(l - chunkZ) <= this.viewDistance * 2) {
+         int k2 = Math.min(chunkX, k) - this.viewDistance;
+         int i3 = Math.min(chunkZ, l) - this.viewDistance;
+         int j3 = Math.max(chunkX, k) + this.viewDistance;
+         int k3 = Math.max(chunkZ, l) + this.viewDistance;
 
          for(int l3 = k2; l3 <= j3; ++l3) {
             for(int k1 = i3; k1 <= k3; ++k1) {
                ChunkPos chunkpos1 = new ChunkPos(l3, k1);
                boolean flag5 = checkerboardDistance(chunkpos1, k, l) <= this.viewDistance;
-               boolean flag6 = checkerboardDistance(chunkpos1, l1, i2) <= this.viewDistance;
-               this.updateChunkTracking(p_219183_1_, chunkpos1, new IPacket[2], flag5, flag6);
+               boolean flag6 = checkerboardDistance(chunkpos1, chunkX, chunkZ) <= this.viewDistance;
+               this.updateChunkTracking(player, chunkpos1, new IPacket[2], flag5, flag6);
             }
          }
       } else {
          for(int i1 = k - this.viewDistance; i1 <= k + this.viewDistance; ++i1) {
             for(int j1 = l - this.viewDistance; j1 <= l + this.viewDistance; ++j1) {
                ChunkPos chunkpos = new ChunkPos(i1, j1);
-               boolean flag3 = true;
-               boolean flag4 = false;
-               this.updateChunkTracking(p_219183_1_, chunkpos, new IPacket[2], true, false);
+               this.updateChunkTracking(player, chunkpos, new IPacket[2], true, false);
             }
          }
 
-         for(int j2 = l1 - this.viewDistance; j2 <= l1 + this.viewDistance; ++j2) {
-            for(int l2 = i2 - this.viewDistance; l2 <= i2 + this.viewDistance; ++l2) {
+         for(int j2 = chunkX - this.viewDistance; j2 <= chunkX + this.viewDistance; ++j2) {
+            for(int l2 = chunkZ - this.viewDistance; l2 <= chunkZ + this.viewDistance; ++l2) {
                ChunkPos chunkpos2 = new ChunkPos(j2, l2);
-               boolean flag7 = false;
-               boolean flag8 = true;
-               this.updateChunkTracking(p_219183_1_, chunkpos2, new IPacket[2], false, true);
+               this.updateChunkTracking(player, chunkpos2, new IPacket[2], false, true);
             }
          }
       }
 
    }
+   // Velox end
 
    public Stream<ServerPlayerEntity> getPlayers(ChunkPos p_219097_1_, boolean p_219097_2_) {
       return this.playerMap.getPlayers(p_219097_1_.toLong()).filter((p_219192_3_) -> {
@@ -1082,7 +1118,9 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
       private final Entity entity;
       private final int range;
       private SectionPos lastSectionPos;
-      private final Set<ServerPlayerEntity> seenBy = Sets.newHashSet();
+      // Velox start: EntityTracker#seenBy threadsafe
+      private final Set<ServerPlayerEntity> seenBy = Sets.newConcurrentHashSet();
+      // Velox end
 
       public EntityTracker(Entity p_i50468_2_, int p_i50468_3_, int p_i50468_4_, boolean p_i50468_5_) {
          this.serverEntity = new TrackedEntity(ChunkManager.this.level, p_i50468_2_, p_i50468_4_, p_i50468_5_, this::broadcast);
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerBossInfo.java b/src/main/java/net/minecraft/world/server/ServerBossInfo.java
index c17fea8..3e777f3 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerBossInfo.java
+++ b/src/main/java/net/minecraft/world/server/ServerBossInfo.java
@@ -13,7 +13,10 @@ import net.minecraft.util.text.ITextComponent;
 import net.minecraft.world.BossInfo;
 
 public class ServerBossInfo extends BossInfo {
-   private final Set<ServerPlayerEntity> players = Sets.newHashSet();
+   // Velox start: players threadsafe
+   // Reason: changed concurrently by entity tracker (start/stopSeenByPlayer)
+   private final Set<ServerPlayerEntity> players = Sets.newConcurrentHashSet();
+   // Velox end
    private final Set<ServerPlayerEntity> unmodifiablePlayers = Collections.unmodifiableSet(this.players);
    private boolean visible = true;
 
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerChunkProvider.java b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
index f0207fb..0dcd774 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerChunkProvider.java
+++ b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
@@ -59,9 +59,7 @@ public class ServerChunkProvider extends AbstractChunkProvider {
    private long lastInhabitedUpdate;
    private boolean spawnEnemies = true;
    private boolean spawnFriendlies = true;
-   private final long[] lastChunkPos = new long[4];
-   private final ChunkStatus[] lastChunkStatus = new ChunkStatus[4];
-   private final IChunk[] lastChunk = new IChunk[4];
+   // Velox deletion: Removed minecraft chunk cache for thread safety and performance reasons
    @Nullable
    private WorldEntitySpawner.EntityDensityManager lastSpawnState;
 
@@ -77,7 +75,6 @@ public class ServerChunkProvider extends AbstractChunkProvider {
       this.chunkMap = new ChunkManager(p_i232603_1_, p_i232603_2_, p_i232603_3_, p_i232603_4_, p_i232603_5_, this.mainThreadProcessor, this, this.getGenerator(), p_i232603_9_, p_i232603_10_, p_i232603_7_, p_i232603_8_);
       this.lightEngine = this.chunkMap.getLightEngine();
       this.distanceManager = this.chunkMap.getDistanceManager();
-      this.clearCache();
    }
 
    public ServerWorldLightManager getLightEngine() {
@@ -93,97 +90,101 @@ public class ServerChunkProvider extends AbstractChunkProvider {
       return this.chunkMap.getTickingGenerated();
    }
 
-   private void storeInCache(long p_225315_1_, IChunk p_225315_3_, ChunkStatus p_225315_4_) {
-      for(int i = 3; i > 0; --i) {
-         this.lastChunkPos[i] = this.lastChunkPos[i - 1];
-         this.lastChunkStatus[i] = this.lastChunkStatus[i - 1];
-         this.lastChunk[i] = this.lastChunk[i - 1];
-      }
-
-      this.lastChunkPos[0] = p_225315_1_;
-      this.lastChunkStatus[0] = p_225315_4_;
-      this.lastChunk[0] = p_225315_3_;
-   }
-
    @Nullable
    public IChunk getChunk(int p_212849_1_, int p_212849_2_, ChunkStatus p_212849_3_, boolean p_212849_4_) {
-      if (Thread.currentThread() != this.mainThread) {
-         return CompletableFuture.supplyAsync(() -> {
-            return this.getChunk(p_212849_1_, p_212849_2_, p_212849_3_, p_212849_4_);
-         }, this.mainThreadProcessor).join();
-      } else {
-         IProfiler iprofiler = this.level.getProfiler();
-         iprofiler.incrementCounter("getChunk");
-         long i = ChunkPos.asLong(p_212849_1_, p_212849_2_);
-
-         for(int j = 0; j < 4; ++j) {
-            if (i == this.lastChunkPos[j] && p_212849_3_ == this.lastChunkStatus[j]) {
-               IChunk ichunk = this.lastChunk[j];
-               if (ichunk != null || !p_212849_4_) {
-                  return ichunk;
-               }
-            }
-         }
-
-         iprofiler.incrementCounter("getChunkCacheMiss");
-         CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.getChunkFutureMainThread(p_212849_1_, p_212849_2_, p_212849_3_, p_212849_4_);
-         this.mainThreadProcessor.managedBlock(completablefuture::isDone);
-         IChunk ichunk1 = completablefuture.join().map((p_222874_0_) -> {
-            return p_222874_0_;
-         }, (p_222870_1_) -> {
-            if (p_212849_4_) {
-               throw (IllegalStateException)Util.pauseInIde(new IllegalStateException("Chunk not there when requested: " + p_222870_1_));
-            } else {
-               return null;
-            }
-         });
-         this.storeInCache(i, ichunk1, p_212849_3_);
-         return ichunk1;
+      // Velox start: remove getChunk mainThread check
+      IProfiler iprofiler = this.level.getProfiler();
+      iprofiler.incrementCounter("getChunk");
+      // Velox start: Lookup chunk cache
+      long packedChunkPos = ChunkPos.asLong(p_212849_1_, p_212849_2_);
+      IChunk chunk = lookupChunkCache(packedChunkPos, p_212849_3_, p_212849_4_);
+      if (chunk != null) {
+         return chunk;
       }
+      // Velox end
+      iprofiler.incrementCounter("getChunkCacheMiss");
+
+      // Velox start: invoke fallbackLookup
+      IChunk ichunk1 = this.fallbackLookup(p_212849_1_, p_212849_2_, p_212849_3_, p_212849_4_);
+      // Velox end
+
+      // Velox start: populate chunk cache
+      if (ichunk1 != null)
+         this.populateChunkCache(p_212849_1_, p_212849_2_, ichunk1, p_212849_3_, p_212849_4_);
+      // Velox end
+      return ichunk1;
+      // Velox end
    }
 
    @Nullable
    public Chunk getChunkNow(int p_225313_1_, int p_225313_2_) {
-      if (Thread.currentThread() != this.mainThread) {
+      // Velox start: remove getChunkNow mainThread check
+      this.level.getProfiler().incrementCounter("getChunkNow");
+      long i = ChunkPos.asLong(p_225313_1_, p_225313_2_);
+
+      // Velox start: Lookup chunk cache
+      long packedChunkPos = ChunkPos.asLong(p_225313_1_, p_225313_2_);
+      IChunk chunk = lookupChunkCache(packedChunkPos, ChunkStatus.FULL, true);
+      if (chunk != null) {
+         return chunk instanceof Chunk ? (Chunk) chunk : null;
+      }
+      // Velox end
+
+      ChunkHolder chunkholder = this.getVisibleChunkIfPresent(i);
+      if (chunkholder == null) {
          return null;
       } else {
-         this.level.getProfiler().incrementCounter("getChunkNow");
-         long i = ChunkPos.asLong(p_225313_1_, p_225313_2_);
-
-         for(int j = 0; j < 4; ++j) {
-            if (i == this.lastChunkPos[j] && this.lastChunkStatus[j] == ChunkStatus.FULL) {
-               IChunk ichunk = this.lastChunk[j];
-               return ichunk instanceof Chunk ? (Chunk)ichunk : null;
-            }
-         }
-
-         ChunkHolder chunkholder = this.getVisibleChunkIfPresent(i);
-         if (chunkholder == null) {
+         Either<IChunk, ChunkHolder.IChunkLoadingError> either = chunkholder.getFutureIfPresent(ChunkStatus.FULL).getNow((Either<IChunk, ChunkHolder.IChunkLoadingError>)null);
+         if (either == null) {
             return null;
          } else {
-            Either<IChunk, ChunkHolder.IChunkLoadingError> either = chunkholder.getFutureIfPresent(ChunkStatus.FULL).getNow((Either<IChunk, ChunkHolder.IChunkLoadingError>)null);
-            if (either == null) {
-               return null;
-            } else {
-               IChunk ichunk1 = either.left().orElse((IChunk)null);
-               if (ichunk1 != null) {
-                  this.storeInCache(i, ichunk1, ChunkStatus.FULL);
-                  if (ichunk1 instanceof Chunk) {
-                     return (Chunk)ichunk1;
-                  }
+            IChunk ichunk1 = either.left().orElse((IChunk)null);
+            if (ichunk1 != null) {
+                // Velox start: Populate chunk cache
+                this.populateChunkCache(p_225313_1_, p_225313_2_, ichunk1, ChunkStatus.FULL, true);
+                // Velox end
+                if (ichunk1 instanceof Chunk) {
+                  return (Chunk)ichunk1;
                }
-
-               return null;
             }
+
+            return null;
          }
       }
+      // Velox end
+   }
+
+   // Velox start: fallbackLookup
+   protected IChunk fallbackLookup(int chunkX, int chunkZ, ChunkStatus requiredStatus, boolean load) {
+      CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.getChunkFutureMainThread(chunkX, chunkZ, requiredStatus, load);
+      this.mainThreadProcessor.managedBlock(completablefuture::isDone);
+      return completablefuture.join().map((p_222874_0_) -> {
+         return p_222874_0_;
+      }, (p_222870_1_) -> {
+         if (load) {
+            throw (IllegalStateException)Util.pauseInIde(new IllegalStateException("Chunk not there when requested: " + p_222870_1_));
+         } else {
+            return null;
+         }
+      });
+   }
+   // Velox end
+
+   // Velox start: Expose populateChunkCache to implement chunk cache
+   protected void populateChunkCache(int chunkX, int chunkZ, IChunk chunk, ChunkStatus requiredStatus, boolean load) {
+   }
+   // Velox end
+
+   // Velox start: Expose lookupChunkCache to implement chunk cache
+   protected IChunk lookupChunkCache(long packedChunkPos, ChunkStatus requiredStatus, boolean load) {
+      return null;
    }
+   // Velox end
 
-   private void clearCache() {
-      Arrays.fill(this.lastChunkPos, ChunkPos.INVALID_CHUNK_POS);
-      Arrays.fill(this.lastChunkStatus, (Object)null);
-      Arrays.fill(this.lastChunk, (Object)null);
+   // Velox start: Expose clearCache to implement chunk cache. Attention: Invoked after every tick!
+   protected void clearCache() {
    }
+   // Velox end
 
    @OnlyIn(Dist.CLIENT)
    public CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> getChunkFuture(int p_217232_1_, int p_217232_2_, ChunkStatus p_217232_3_, boolean p_217232_4_) {
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerTickList.java b/src/main/java/net/minecraft/world/server/ServerTickList.java
index a78bb2e..bd92735 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerTickList.java
+++ b/src/main/java/net/minecraft/world/server/ServerTickList.java
@@ -10,6 +10,8 @@ import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -37,6 +39,10 @@ public class ServerTickList<T> implements ITickList<T> {
    private final Queue<NextTickListEntry<T>> currentlyTicking = Queues.newArrayDeque();
    private final List<NextTickListEntry<T>> alreadyTicked = Lists.newArrayList();
    private final Consumer<NextTickListEntry<T>> ticker;
+   // Velox start: Make ServerTickList threadsafe
+   // Reason: ServerTick list is modified concurrently by world generation
+   private final ReadWriteLock lock = new ReentrantReadWriteLock();
+   // Velox end
 
    public ServerTickList(ServerWorld p_i231625_1_, Predicate<T> p_i231625_2_, Function<T, ResourceLocation> p_i231625_3_, Consumer<NextTickListEntry<T>> p_i231625_4_) {
       this.ignore = p_i231625_2_;
@@ -46,59 +52,71 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    public void tick() {
-      int i = this.tickNextTickList.size();
-      if (i != this.tickNextTickSet.size()) {
-         throw new IllegalStateException("TickNextTick list out of synch");
-      } else {
-         if (i > 65536) {
-            i = 65536;
-         }
+      // Velox start: ServerTickList#tick threadsafe
+      this.lock.writeLock().lock();
+      try {
+         int i = this.tickNextTickList.size();
+         if (i != this.tickNextTickSet.size()) {
+            throw new IllegalStateException("TickNextTick list out of synch");
+         } else {
+            if (i > 65536) {
+               i = 65536;
+            }
 
-         ServerChunkProvider serverchunkprovider = this.level.getChunkSource();
-         Iterator<NextTickListEntry<T>> iterator = this.tickNextTickList.iterator();
-         this.level.getProfiler().push("cleaning");
+            ServerChunkProvider serverchunkprovider = this.level.getChunkSource();
+            Iterator<NextTickListEntry<T>> iterator = this.tickNextTickList.iterator();
+            this.level.getProfiler().push("cleaning");
 
-         while(i > 0 && iterator.hasNext()) {
-            NextTickListEntry<T> nextticklistentry = iterator.next();
-            if (nextticklistentry.triggerTick > this.level.getGameTime()) {
-               break;
-            }
+            while (i > 0 && iterator.hasNext()) {
+               NextTickListEntry<T> nextticklistentry = iterator.next();
+               if (nextticklistentry.triggerTick > this.level.getGameTime()) {
+                  break;
+               }
 
-            if (serverchunkprovider.isTickingChunk(nextticklistentry.pos)) {
-               iterator.remove();
-               this.tickNextTickSet.remove(nextticklistentry);
-               this.currentlyTicking.add(nextticklistentry);
-               --i;
+               if (serverchunkprovider.isTickingChunk(nextticklistentry.pos)) {
+                  iterator.remove();
+                  this.tickNextTickSet.remove(nextticklistentry);
+                  this.currentlyTicking.add(nextticklistentry);
+                  --i;
+               }
             }
-         }
 
-         this.level.getProfiler().popPush("ticking");
-
-         NextTickListEntry<T> nextticklistentry1;
-         while((nextticklistentry1 = this.currentlyTicking.poll()) != null) {
-            if (serverchunkprovider.isTickingChunk(nextticklistentry1.pos)) {
-               try {
-                  this.alreadyTicked.add(nextticklistentry1);
-                  this.ticker.accept(nextticklistentry1);
-               } catch (Throwable throwable) {
-                  CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception while ticking");
-                  CrashReportCategory crashreportcategory = crashreport.addCategory("Block being ticked");
-                  CrashReportCategory.populateBlockDetails(crashreportcategory, nextticklistentry1.pos, (BlockState)null);
-                  throw new ReportedException(crashreport);
+            this.level.getProfiler().popPush("ticking");
+
+            NextTickListEntry<T> nextticklistentry1;
+            while ((nextticklistentry1 = this.currentlyTicking.poll()) != null) {
+               if (serverchunkprovider.isTickingChunk(nextticklistentry1.pos)) {
+                  try {
+                     this.alreadyTicked.add(nextticklistentry1);
+                     this.ticker.accept(nextticklistentry1);
+                  } catch (Throwable throwable) {
+                     CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception while ticking");
+                     CrashReportCategory crashreportcategory = crashreport.addCategory("Block being ticked");
+                     CrashReportCategory.populateBlockDetails(crashreportcategory, nextticklistentry1.pos, (BlockState) null);
+                     throw new ReportedException(crashreport);
+                  }
+               } else {
+                  this.scheduleTick(nextticklistentry1.pos, nextticklistentry1.getType(), 0);
                }
-            } else {
-               this.scheduleTick(nextticklistentry1.pos, nextticklistentry1.getType(), 0);
             }
-         }
 
-         this.level.getProfiler().pop();
-         this.alreadyTicked.clear();
-         this.currentlyTicking.clear();
+            this.level.getProfiler().pop();
+            this.alreadyTicked.clear();
+            this.currentlyTicking.clear();
+         }
+      } finally {
+         this.lock.writeLock().unlock();
       }
+      // Velox end
    }
 
    public boolean willTickThisTick(BlockPos p_205361_1_, T p_205361_2_) {
-      return this.currentlyTicking.contains(new NextTickListEntry(p_205361_1_, p_205361_2_));
+      // Velox start: ServerTickList#fetchTicksInArea threadsafe
+      this.lock.readLock().lock();
+      boolean contains = this.currentlyTicking.contains(new NextTickListEntry(p_205361_1_, p_205361_2_));
+      this.lock.readLock().unlock();
+      // Velox end
+      return contains;
    }
 
    public List<NextTickListEntry<T>> fetchTicksInChunk(ChunkPos p_223188_1_, boolean p_223188_2_, boolean p_223188_3_) {
@@ -110,6 +128,8 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    public List<NextTickListEntry<T>> fetchTicksInArea(MutableBoundingBox p_205366_1_, boolean p_205366_2_, boolean p_205366_3_) {
+      // Velox start: ServerTickList#fetchTicksInArea threadsafe
+      this.lock.writeLock().lock();
       List<NextTickListEntry<T>> list = this.fetchTicksInArea((List<NextTickListEntry<T>>)null, this.tickNextTickList, p_205366_1_, p_205366_2_);
       if (p_205366_2_ && list != null) {
          this.tickNextTickSet.removeAll(list);
@@ -119,7 +139,8 @@ public class ServerTickList<T> implements ITickList<T> {
       if (!p_205366_3_) {
          list = this.fetchTicksInArea(list, this.alreadyTicked, p_205366_1_, p_205366_2_);
       }
-
+      this.lock.writeLock().unlock();
+      // Velox end
       return list == null ? Collections.emptyList() : list;
    }
 
@@ -191,14 +212,22 @@ public class ServerTickList<T> implements ITickList<T> {
    }
 
    private void addTickData(NextTickListEntry<T> p_219504_1_) {
+      // Velox start: ServerTickList#addTickData threadsafe
+      this.lock.writeLock().lock();
       if (!this.tickNextTickSet.contains(p_219504_1_)) {
          this.tickNextTickSet.add(p_219504_1_);
          this.tickNextTickList.add(p_219504_1_);
       }
-
+      this.lock.writeLock().unlock();
+      // Velox end
    }
 
    public int size() {
-      return this.tickNextTickSet.size();
+      // Velox start: ServerTickList#size threadsafe
+      this.lock.readLock().lock();
+      int size = this.tickNextTickSet.size();
+      this.lock.readLock().unlock();
+      // Velox end
+      return size;
    }
 }
diff --git a/build/mcp_diff_src/net/minecraft/world/server/ServerWorld.java b/src/main/java/net/minecraft/world/server/ServerWorld.java
index 7120174..20cc49b 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/ServerWorld.java
+++ b/src/main/java/net/minecraft/world/server/ServerWorld.java
@@ -35,6 +35,9 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+
+import me.mikex86.velox.chunk.ConcurrentChunkProvider;
+import me.mikex86.velox.tick.MadMaxTickManager;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockEventData;
 import net.minecraft.block.BlockState;
@@ -180,9 +183,11 @@ public class ServerWorld extends World implements ISeedReader {
       this.server = p_i241885_1_;
       this.customSpawners = p_i241885_12_;
       this.serverLevelData = p_i241885_4_;
+      // Velox start: Use ConcurrentChunkProvider
       this.chunkSource = new ServerChunkProvider(this, p_i241885_3_, p_i241885_1_.getFixerUpper(), p_i241885_1_.getStructureManager(), p_i241885_2_, p_i241885_8_, p_i241885_1_.getPlayerList().getViewDistance(), p_i241885_1_.forceSynchronousWrites(), p_i241885_7_, () -> {
          return p_i241885_1_.overworld().getDataStorage();
       });
+      // Velox end
       this.portalForcer = new Teleporter(this);
       this.updateSkyBrightness();
       this.prepareWeather();
@@ -344,75 +349,109 @@ public class ServerWorld extends World implements ISeedReader {
       }
 
       if (flag3 || this.emptyTime++ < 300) {
-         if (this.dragonFight != null) {
-            this.dragonFight.tick();
-         }
 
-         this.tickingEntities = true;
-         ObjectIterator<Entry<Entity>> objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();
+         // Velox start: Call Velox tick entities method
+         this.tickEntitiesVelox();
+         // Velox end
+      }
 
-         label164:
-         while(true) {
-            Entity entity1;
-            while(true) {
-               if (!objectiterator.hasNext()) {
-                  this.tickingEntities = false;
+      iprofiler.pop();
+   }
 
-                  Entity entity;
-                  while((entity = this.toAddAfterTick.poll()) != null) {
-                     this.add(entity);
-                  }
+   // Velox start: Velox tick entity method
+   private void tickEntitiesVelox() {
+      IProfiler profiler = this.getProfiler();
 
-                  this.tickBlockEntities();
-                  break label164;
-               }
+      if (this.dragonFight != null) {
+         this.dragonFight.tick();
+      }
 
-               Entry<Entity> entry = objectiterator.next();
-               entity1 = entry.getValue();
-               Entity entity2 = entity1.getVehicle();
-               if (!this.server.isSpawningAnimals() && (entity1 instanceof AnimalEntity || entity1 instanceof WaterMobEntity)) {
-                  entity1.remove();
-               }
+      this.tickingEntities = true;
 
-               if (!this.server.areNpcsEnabled() && entity1 instanceof INPC) {
-                  entity1.remove();
-               }
 
-               iprofiler.push("checkDespawn");
-               if (!entity1.removed) {
-                  entity1.checkDespawn();
-               }
+      // check entities for removal
+      {
+         Stream<Entry<Entity>> entityStream = this.entitiesById.int2ObjectEntrySet().stream();
+         entityStream.forEach(entry -> {
+            Entity entity = entry.getValue();
 
-               iprofiler.pop();
-               if (entity2 == null) {
-                  break;
-               }
+            // Marks all animals for removal, if spawning of animals is disabled
+            if (!this.server.isSpawningAnimals() && (entity instanceof AnimalEntity || entity instanceof WaterMobEntity)) {
+               entity.remove();
+            }
 
-               if (entity2.removed || !entity2.hasPassenger(entity1)) {
-                  entity1.stopRiding();
-                  break;
-               }
+            // Marks all NPCs for removal, if spawning of NPCs is disabled
+            if (!this.server.areNpcsEnabled() && entity instanceof INPC) {
+               entity.remove();
             }
 
-            iprofiler.push("tick");
-            if (!entity1.removed && !(entity1 instanceof EnderDragonPartEntity)) {
-               this.guardEntityTick(this::tickNonPassenger, entity1);
+            profiler.push("checkDespawn");
+            // check if the entity should be de-spawned, if it isn't marked to get removed already
+            if (!entity.removed) {
+               entity.checkDespawn();
             }
+            profiler.pop();
 
-            iprofiler.pop();
-            iprofiler.push("remove");
-            if (entity1.removed) {
-               this.removeFromChunk(entity1);
-               objectiterator.remove();
-               this.onEntityRemoved(entity1);
+            // if a vehicle is present and it is marked for removal, the entity should stop riding that vehicle
+            Entity vehicle = entity.getVehicle();
+            if (vehicle != null && (vehicle.removed || !vehicle.hasPassenger(entity))) {
+               entity.stopRiding();
             }
+         });
+      }
+      // tick entities
+      {
+         if (MadMaxTickManager.MAD_MAX_MODE) {
+            MadMaxTickManager.tickMadMax(this.entitiesById.values(), this::tickEntity);
+         } else {
+            // build tick list. Predicate: entity.getVehicle() is null.
+            // Passengers are ticked after main entity tick in #tickNonPassenger.
+            // Avoid double ticking passengers.
+            this.tickRegionManager.buildEntityTickList(this.entitiesById.values().iterator(), entity -> entity.getVehicle() == null);
 
-            iprofiler.pop();
+            // tick entities
+            this.tickRegionManager.applyEntityTask(this::tickEntity);
+         }
+      }
+      // remove all entities marked for removal from the entity lists (server global, chunk local, invoke listeners etc...)
+      {
+         Stream<Entry<Entity>> entityStream = this.entitiesById.int2ObjectEntrySet().stream();
+         entityStream.forEach(entry -> {
+            Entity entity = entry.getValue();
+            profiler.push("remove");
+            if (entity.removed) {
+               this.removeFromChunk(entity);
+               this.onEntityRemoved(entity);
+            }
+            profiler.pop();
+         });
+         this.entitiesById.int2ObjectEntrySet().removeIf(e -> e.getValue().removed);
+      }
+      this.tickingEntities = false;
+
+      // Add pending entities
+      {
+         Entity entity;
+         while ((entity = this.toAddAfterTick.poll()) != null) {
+            this.add(entity);
          }
       }
 
-      iprofiler.pop();
+      // tick block entities
+      this.tickBlockEntities();
+   }
+   // Velox end
+
+   // Velox start: individual entity tick method
+   private void tickEntity(Entity entity) {
+      IProfiler profiler = this.getProfiler();
+      profiler.push("tick");
+      if (!entity.removed && !(entity instanceof EnderDragonPartEntity)) {
+         this.guardEntityTick(this::tickNonPassenger, entity);
+      }
+      profiler.pop();
    }
+   // Velox end
 
    protected void tickTime() {
       if (this.tickTime) {
diff --git a/build/mcp_diff_src/net/minecraft/world/server/TicketManager.java b/src/main/java/net/minecraft/world/server/TicketManager.java
index 49f8f4a..caf86b2 100644
--- a/build/mcp_diff_src/net/minecraft/world/server/TicketManager.java
+++ b/src/main/java/net/minecraft/world/server/TicketManager.java
@@ -1,25 +1,19 @@
 package net.minecraft.world.server;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2IntMap;
-import it.unimi.dsi.fastutil.longs.Long2IntMaps;
-import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
-import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import javax.annotation.Nullable;
 import net.minecraft.entity.player.ServerPlayerEntity;
 import net.minecraft.util.SortedArraySet;
@@ -36,7 +30,10 @@ import org.apache.logging.log4j.Logger;
 public abstract class TicketManager {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final int PLAYER_TICKET_LEVEL = 33 + ChunkStatus.getDistance(ChunkStatus.FULL) - 2;
-   private final Long2ObjectMap<ObjectSet<ServerPlayerEntity>> playersPerChunk = new Long2ObjectOpenHashMap<>();
+   // Velox start: Generalize to Map and Set
+   // Reason: Set and Map implementation now concurrent because EntityTracker modifies it concurrently
+   private final Map<Long, Set<ServerPlayerEntity>> playersPerChunk = Maps.newConcurrentMap();
+   // Velox end
    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap<>();
    private final TicketManager.ChunkTicketTracker ticketTracker = new TicketManager.ChunkTicketTracker();
    private final TicketManager.PlayerChunkTracker naturalSpawnChunkCounter = new TicketManager.PlayerChunkTracker(8);
@@ -58,7 +55,8 @@ public abstract class TicketManager {
       this.mainThreadExecutor = p_i50707_2_;
    }
 
-   protected void purgeStaleTickets() {
+   // Velox start: purgeStaleTickets threadsafe
+   protected synchronized void purgeStaleTickets() {
       ++this.ticketTickCounter;
       ObjectIterator<Entry<SortedArraySet<Ticket<?>>>> objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
 
@@ -76,6 +74,7 @@ public abstract class TicketManager {
       }
 
    }
+   // Velox end
 
    private static int getTicketLevelAt(SortedArraySet<Ticket<?>> p_229844_0_) {
       return !p_229844_0_.isEmpty() ? p_229844_0_.first().getTicketLevel() : ChunkManager.MAX_CHUNK_DISTANCE + 1;
@@ -89,7 +88,8 @@ public abstract class TicketManager {
    @Nullable
    protected abstract ChunkHolder updateChunkScheduling(long p_219372_1_, int p_219372_3_, @Nullable ChunkHolder p_219372_4_, int p_219372_5_);
 
-   public boolean runAllUpdates(ChunkManager p_219353_1_) {
+   // Velox start: runAllUpdates threadsafe
+   public synchronized boolean runAllUpdates(ChunkManager p_219353_1_) {
       this.naturalSpawnChunkCounter.runAllUpdates();
       this.playerTicketManager.runAllUpdates();
       int i = Integer.MAX_VALUE - this.ticketTracker.runDistanceUpdates(Integer.MAX_VALUE);
@@ -133,6 +133,7 @@ public abstract class TicketManager {
          return flag;
       }
    }
+   // Velox end
 
    private void addTicket(long p_219347_1_, Ticket<?> p_219347_3_) {
       SortedArraySet<Ticket<?>> sortedarrayset = this.getTickets(p_219347_1_);
@@ -157,23 +158,31 @@ public abstract class TicketManager {
       this.ticketTracker.update(p_219349_1_, getTicketLevelAt(sortedarrayset), false);
    }
 
-   public <T> void addTicket(TicketType<T> p_219356_1_, ChunkPos p_219356_2_, int p_219356_3_, T p_219356_4_) {
+   // Velox start: addTicket threadsafe
+   public synchronized <T> void addTicket(TicketType<T> p_219356_1_, ChunkPos p_219356_2_, int p_219356_3_, T p_219356_4_) {
       this.addTicket(p_219356_2_.toLong(), new Ticket<>(p_219356_1_, p_219356_3_, p_219356_4_));
    }
+   // Velox end
 
-   public <T> void removeTicket(TicketType<T> p_219345_1_, ChunkPos p_219345_2_, int p_219345_3_, T p_219345_4_) {
+   // Velox start: removeTicket threadsafe
+   public synchronized <T> void removeTicket(TicketType<T> p_219345_1_, ChunkPos p_219345_2_, int p_219345_3_, T p_219345_4_) {
       Ticket<T> ticket = new Ticket<>(p_219345_1_, p_219345_3_, p_219345_4_);
       this.removeTicket(p_219345_2_.toLong(), ticket);
    }
+   // Velox end
 
-   public <T> void addRegionTicket(TicketType<T> p_219331_1_, ChunkPos p_219331_2_, int p_219331_3_, T p_219331_4_) {
+   // Velox start: addRegionTicket threadsafe
+   public synchronized  <T> void addRegionTicket(TicketType<T> p_219331_1_, ChunkPos p_219331_2_, int p_219331_3_, T p_219331_4_) {
       this.addTicket(p_219331_2_.toLong(), new Ticket<>(p_219331_1_, 33 - p_219331_3_, p_219331_4_));
    }
+   // Velox end
 
-   public <T> void removeRegionTicket(TicketType<T> p_219362_1_, ChunkPos p_219362_2_, int p_219362_3_, T p_219362_4_) {
+   // Velox start: addRegionTicket threadsafe
+   public synchronized <T> void removeRegionTicket(TicketType<T> p_219362_1_, ChunkPos p_219362_2_, int p_219362_3_, T p_219362_4_) {
       Ticket<T> ticket = new Ticket<>(p_219362_1_, 33 - p_219362_3_, p_219362_4_);
       this.removeTicket(p_219362_2_.toLong(), ticket);
    }
+   // Velox end
 
    private SortedArraySet<Ticket<?>> getTickets(long p_229848_1_) {
       return this.tickets.computeIfAbsent(p_229848_1_, (p_229851_0_) -> {
@@ -181,7 +190,8 @@ public abstract class TicketManager {
       });
    }
 
-   protected void updateChunkForced(ChunkPos p_219364_1_, boolean p_219364_2_) {
+   // Velox start: updateChunkForced threadsafe
+   protected synchronized void updateChunkForced(ChunkPos p_219364_1_, boolean p_219364_2_) {
       Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, 31, p_219364_1_);
       if (p_219364_2_) {
          this.addTicket(p_219364_1_.toLong(), ticket);
@@ -190,11 +200,15 @@ public abstract class TicketManager {
       }
 
    }
+   // Velox end
 
    public void addPlayer(SectionPos p_219341_1_, ServerPlayerEntity p_219341_2_) {
       long i = p_219341_1_.chunk().toLong();
       this.playersPerChunk.computeIfAbsent(i, (p_219361_0_) -> {
-         return new ObjectOpenHashSet();
+         // Velox start: Use concurrent hash set
+         // Reason: Entity tracker modifies concurrently
+         return Sets.newConcurrentHashSet();
+         // Velox end
       }).add(p_219341_2_);
       this.naturalSpawnChunkCounter.update(i, 0, true);
       this.playerTicketManager.update(i, 0, true);
@@ -202,7 +216,10 @@ public abstract class TicketManager {
 
    public void removePlayer(SectionPos p_219367_1_, ServerPlayerEntity p_219367_2_) {
       long i = p_219367_1_.chunk().toLong();
-      ObjectSet<ServerPlayerEntity> objectset = this.playersPerChunk.get(i);
+      // Velox start: Generalize to Set
+      // Reason: Set implementation now concurrent because EntityTracker modifies it concurrently
+      Set<ServerPlayerEntity> objectset = this.playersPerChunk.get(i);
+      // Velox end
       objectset.remove(p_219367_2_);
       if (objectset.isEmpty()) {
          this.playersPerChunk.remove(i);
@@ -212,7 +229,8 @@ public abstract class TicketManager {
 
    }
 
-   protected String getTicketDebugString(long p_225413_1_) {
+   // Velox start: getTicketDebugString threadsafe
+   protected synchronized String getTicketDebugString(long p_225413_1_) {
       SortedArraySet<Ticket<?>> sortedarrayset = this.tickets.get(p_225413_1_);
       String s;
       if (sortedarrayset != null && !sortedarrayset.isEmpty()) {
@@ -223,10 +241,13 @@ public abstract class TicketManager {
 
       return s;
    }
+   // Velox end
 
-   protected void updatePlayerTickets(int p_219354_1_) {
+   // Velox start: updatePlayerTickets threadsafe
+   protected synchronized void updatePlayerTickets(int p_219354_1_) {
       this.playerTicketManager.updateViewDistance(p_219354_1_);
    }
+   // Velox end
 
    public int getNaturalSpawnChunkCount() {
       this.naturalSpawnChunkCounter.runAllUpdates();
@@ -284,9 +305,12 @@ public abstract class TicketManager {
       }
    }
 
+   // Velox start: PlayerChunkTracker threadsafe.
+   // Reason: Invoked by EntityTracker
    class PlayerChunkTracker extends ChunkDistanceGraph {
-      protected final Long2ByteMap chunks = new Long2ByteOpenHashMap();
+      protected final Long2ByteMap chunks = Long2ByteMaps.synchronize(new Long2ByteOpenHashMap());
       protected final int maxDistance;
+      private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
       protected PlayerChunkTracker(int p_i50684_2_) {
          super(p_i50684_2_ + 2, 16, 256);
@@ -294,19 +318,30 @@ public abstract class TicketManager {
          this.chunks.defaultReturnValue((byte)(p_i50684_2_ + 2));
       }
 
+      @Override
+      public void update(long p_215491_1_, int p_215491_3_, boolean p_215491_4_) {
+         this.lock.writeLock().lock();
+         super.update(p_215491_1_, p_215491_3_, p_215491_4_);
+         this.lock.writeLock().unlock();
+      }
+
       protected int getLevel(long p_215471_1_) {
-         return this.chunks.get(p_215471_1_);
+         this.lock.readLock().lock();
+         byte level = this.chunks.get(p_215471_1_);
+         this.lock.readLock().unlock();
+         return level;
       }
 
       protected void setLevel(long p_215476_1_, int p_215476_3_) {
+         this.lock.writeLock().lock();
          byte b0;
          if (p_215476_3_ > this.maxDistance) {
             b0 = this.chunks.remove(p_215476_1_);
          } else {
             b0 = this.chunks.put(p_215476_1_, (byte)p_215476_3_);
          }
-
          this.onLevelChange(p_215476_1_, b0, p_215476_3_);
+         this.lock.writeLock().unlock();
       }
 
       protected void onLevelChange(long p_215495_1_, int p_215495_3_, int p_215495_4_) {
@@ -317,19 +352,28 @@ public abstract class TicketManager {
       }
 
       private boolean havePlayer(long p_215496_1_) {
-         ObjectSet<ServerPlayerEntity> objectset = TicketManager.this.playersPerChunk.get(p_215496_1_);
+         this.lock.readLock().lock();
+         Set<ServerPlayerEntity> objectset = TicketManager.this.playersPerChunk.get(p_215496_1_);
+         this.lock.readLock().unlock();
          return objectset != null && !objectset.isEmpty();
       }
 
       public void runAllUpdates() {
+         this.lock.writeLock().lock();
          this.runUpdates(Integer.MAX_VALUE);
+         this.lock.writeLock().unlock();
       }
    }
+   // Velox end
 
+   // Velox start: PlayerChunkTracker threadsafe.
+   // Reason: Invoked by EntityTracker
+   // Comment: The vanilla version seems partially threadsafe. WTF?
    class PlayerTicketTracker extends TicketManager.PlayerChunkTracker {
       private int viewDistance;
       private final Long2IntMap queueLevels = Long2IntMaps.synchronize(new Long2IntOpenHashMap());
-      private final LongSet toUpdate = new LongOpenHashSet();
+      private final LongSet toUpdate = LongSets.synchronize(new LongOpenHashSet());
+      private final ReadWriteLock toUpdateLock = new ReentrantReadWriteLock();
 
       protected PlayerTicketTracker(int p_i50682_2_) {
          super(p_i50682_2_);
@@ -338,7 +382,9 @@ public abstract class TicketManager {
       }
 
       protected void onLevelChange(long p_215495_1_, int p_215495_3_, int p_215495_4_) {
+         this.toUpdateLock.writeLock().lock();
          this.toUpdate.add(p_215495_1_);
+         this.toUpdateLock.writeLock().unlock();
       }
 
       public void updateViewDistance(int p_215508_1_) {
@@ -381,6 +427,7 @@ public abstract class TicketManager {
       }
 
       public void runAllUpdates() {
+         this.toUpdateLock.writeLock().lock();
          super.runAllUpdates();
          if (!this.toUpdate.isEmpty()) {
             LongIterator longiterator = this.toUpdate.iterator();
@@ -406,11 +453,12 @@ public abstract class TicketManager {
 
             this.toUpdate.clear();
          }
-
+         this.toUpdateLock.writeLock().unlock();
       }
 
       private boolean haveTicketFor(int p_215505_1_) {
          return p_215505_1_ <= this.viewDistance - 2;
       }
    }
+   // Velox end
 }
